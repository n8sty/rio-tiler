{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"rio-tiler","text":"<p> User friendly Rasterio plugin to read raster datasets. </p> <p> </p> <p>Documentation: cogeotiff.github.io/rio-tiler/</p> <p>Source Code: cogeotiff/rio-tiler</p>"},{"location":"#description","title":"Description","text":"<p><code>rio-tiler</code> was initially designed to create slippy map tiles from large raster data sources and render these tiles dynamically on a web map. Since <code>rio-tiler</code> v2.0, we added many more helper methods to read data and metadata from any raster source supported by Rasterio/GDAL. This includes local and remote files via HTTP, AWS S3, Google Cloud Storage, etc.</p> <p>At the low level, <code>rio-tiler</code> is just a wrapper around the rasterio and GDAL libraries.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Read any dataset supported by GDAL/Rasterio</p> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"my.tif\") as image:\n    print(image.dataset)  # rasterio opened dataset\n    img = image.read()    # similar to rasterio.open(\"my.tif\").read() but returns a rio_tiler.models.ImageData object\n</code></pre> </li> <li> <p>User friendly <code>tile</code>, <code>part</code>, <code>feature</code>, <code>point</code> reading methods</p> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"my.tif\") as image:\n    img = image.tile(x, y, z)            # read mercator tile z-x-y\n    img = image.part(bbox)               # read the data intersecting a bounding box\n    img = image.feature(geojson_feature) # read the data intersecting a geojson feature\n    img = image.point(lon,lat)           # get pixel values for a lon/lat coordinates\n</code></pre> </li> <li> <p>Enable property assignment (e.g nodata) on data reading</p> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"my.tif\") as image:\n    img = image.tile(x, y, z, nodata=-9999) # read mercator tile z-x-y\n</code></pre> </li> <li> <p>STAC support</p> <pre><code>from rio_tiler.io import STACReader\n\nwith STACReader(\"item.json\") as stac:\n    print(stac.assets)  # available asset\n    img = stac.tile(  # read tile for asset1 and indexes 1,2,3\n        x,\n        y,\n        z,\n        assets=\"asset1\",\n        indexes=(1, 2, 3),  # same as asset_indexes={\"asset1\": (1, 2, 3)},\n    )\n\n    # Merging data from different assets\n    img = stac.tile(  # create an image from assets 1,2,3 using their first band\n        x,\n        y,\n        z,\n        assets=(\"asset1\", \"asset2\", \"asset3\",),\n        asset_indexes={\"asset1\": 1, \"asset2\": 1, \"asset3\": 1},\n    )\n</code></pre> </li> <li> <p>Xarray support (&gt;=4.0)</p> <p><pre><code>import xarray\nfrom rio_tiler.io import XarrayReader\n\nds = xarray.open_dataset(\n    \"https://pangeo.blob.core.windows.net/pangeo-public/daymet-rio-tiler/na-wgs84.zarr/\",\n    engine=\"zarr\",\n    decode_coords=\"all\",\n    consolidated=True,\n)\nda = ds[\"tmax\"]\nwith XarrayReader(da) as dst:\n    print(dst.info())\n    img = dst.tile(1, 1, 2)\n</code></pre> Note: The XarrayReader needs optional dependencies to be installed <code>pip install rio-tiler[\"xarray\"]</code>.</p> </li> <li> <p>Non-Geo Image support (&gt;=4.0)</p> <pre><code>from rio_tiler.io import ImageReader\n\nwith ImageReader(\"image.jpeg\") as src:\n    im = src.tile(0, 0, src.maxzoom)  # read top-left `tile`\n    im = src.part((0, 100, 100, 0))  # read top-left 100x100 pixels\n    pt = src.point(0, 0)  # read pixel value\n</code></pre> <p>Note: <code>ImageReader</code> is also compatible with proper geo-referenced raster datasets.</p> </li> <li> <p>Mosaic (merging or stacking)</p> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.mosaic import mosaic_reader\n\ndef reader(file, x, y, z, **kwargs):\n    with Reader(file) as image:\n        return image.tile(x, y, z, **kwargs)\n\nimg, assets = mosaic_reader([\"image1.tif\", \"image2.tif\"], reader, x, y, z)\n</code></pre> </li> <li> <p>Native support for multiple TileMatrixSet via morecantile</p> <pre><code>import morecantile\nfrom rio_tiler.io import Reader\n\n# Use EPSG:4326 (WGS84) grid\nwgs84_grid = morecantile.tms.get(\"WorldCRS84Quad\")\nwith Reader(\"my.tif\", tms=wgs84_grid) as src:\n    img = src.tile(1, 1, 1)\n</code></pre> </li> </ul>"},{"location":"#install","title":"Install","text":"<p>You can install <code>rio-tiler</code> using pip</p> <pre><code>$ pip install -U pip\n$ pip install -U rio-tiler\n</code></pre> <p>or install from source:</p> <pre><code>$ git clone https://github.com/cogeotiff/rio-tiler.git\n$ cd rio-tiler\n$ pip install -U pip\n$ pip install -e .\n</code></pre>"},{"location":"#plugins","title":"Plugins","text":""},{"location":"#rio-tiler-pds","title":"rio-tiler-pds","text":"<p><code>rio-tiler</code> v1 included several helpers for reading popular public datasets (e.g. Sentinel 2, Sentinel 1, Landsat 8, CBERS) from cloud providers. This functionality is now in a separate plugin, enabling easier access to more public datasets.</p>"},{"location":"#rio-tiler-mvt","title":"rio-tiler-mvt","text":"<p>Create Mapbox Vector Tiles from raster sources</p>"},{"location":"#implementations","title":"Implementations","text":"<p>titiler: A lightweight Cloud Optimized GeoTIFF dynamic tile server.</p> <p>cogeo-mosaic: Create mosaics of Cloud Optimized GeoTIFF based on the mosaicJSON specification.</p>"},{"location":"#contribution-development","title":"Contribution &amp; Development","text":"<p>See CONTRIBUTING.md</p>"},{"location":"#authors","title":"Authors","text":"<p>The <code>rio-tiler</code> project was begun at Mapbox and was transferred to the <code>cogeotiff</code> Github organization in January 2019.</p> <p>See AUTHORS.txt for a listing of individual contributors.</p>"},{"location":"#changes","title":"Changes","text":"<p>See CHANGES.md.</p>"},{"location":"#license","title":"License","text":"<p>See LICENSE</p>"},{"location":"colormap/","title":"Colormaps","text":"<p>Rio-tiler includes many colormaps, some derived from Matplotlib and some custom ones that are commonly used with raster data.</p> <p>You can load one of <code>rio-tiler</code>'s default colormaps from the <code>rio_tiler.colormap.cmap</code> object, and then pass it to <code>rio_tiler.utils.render</code>:</p> <pre><code>from rio_tiler.colormap import cmap\nfrom rio_tiler.io import Reader\n\n# Get Colormap\n# You can list available colormap names with `cmap.list()`\ncm = cmap.get(\"cfastie\")\n\nwith Reader(\n  \"https://sentinel-cogs.s3.amazonaws.com/sentinel-s2-l2a-cogs/29/R/KH/2020/2/S2A_29RKH_20200219_0_L2A/B01.tif\",\n) as src:\n    img = src.tile(239, 220, 9)\n\n    # Rescale the data linearly from 0-10000 to 0-255\n    img.rescale(\n        in_range=((0, 10000),),\n        out_range=((0, 255),)\n    )\n\n    # Apply colormap and create a PNG buffer\n    buff = img.render(colormap=cm) # this returns a buffer (PNG by default)\n</code></pre> <p>The <code>render</code> method accept colormap in form of: <pre><code>{\n  value1: (R, G, B, Alpha),\n  value2: (R, G, B, Alpha),\n  ...\n}\n</code></pre></p> <p>Colormaps can be <code>discrete</code> (having sparse value) or <code>linear</code> (with values strictly from 0 to 255).</p>"},{"location":"colormap/#custom-colormaps","title":"Custom colormaps","text":"<p>The <code>rio_tiler.colormap.cmap</code> object holds the list of default colormaps and also allow users to registered new ones.</p> <p>discrete (with custom entries, not limited to uint8 type)</p> <pre><code>from rio_tiler.colormap import cmap\n\ncmap = cmap.register(\n    {\n        \"custom_classes\": {\n          0: (0, 0, 0, 0),\n          100: (255, 0, 0, 255),\n          200: (0, 255, 0, 255),\n          300: (0, 0, 255, 255),\n        }\n    }\n)\n</code></pre> <p>linear (with 256 values from 0 to 255)</p> <pre><code># ref: https://github.com/cogeotiff/rio-tiler/issues/382\nimport matplotlib\nimport numpy\n\nndvi = matplotlib.colors.LinearSegmentedColormap.from_list(\n    'ndvi', [\n        '#422112',\n        '#724C01',\n        '#CEA712',\n        '#FFA904',\n        '#FDFE00',\n        '#E6EC06',\n        '#BACF00',\n        '#8BB001',\n        '#72A002',\n        '#5B8D03',\n        '#448102',\n        '#2C7001',\n        '#176100',\n    ],\n    256,\n)\n\nx = numpy.linspace(0, 1, 256)\ncmap_vals = ndvi(x)[:, :]\ncmap_uint8 = (cmap_vals * 255).astype('uint8')\nndvi_dict = {idx: tuple(value) for idx, value in enumerate(cmap_uint8)}\n\ncmap = cmap.register({\"ndvi\": ndvi_dict})\n</code></pre>"},{"location":"colormap/#intervals-colormaps","title":"Intervals colormaps","text":"<p>Starting with <code>rio-tiler</code> 3.0, intervals colormap support has been added. This is useful when you want to define color breaks for a given data.</p> <p>Warnings</p> <p>For <code>intervals</code>, colormap has to be in form of <code>Sequence[Tuple[Sequence, Sequence]]</code>: <pre><code>[\n  ((min, max), (r, g, b, a)),\n  ((min, max), (r, g, b, a)),\n  ...\n]\n</code></pre></p> <pre><code>from rio_tiler.colormap import apply_cmap\n\ndata = numpy.random.randint(0, 255, size=(1, 256, 256))\ncmap = [\n    ((0, 1), (0, 0, 0, 0)),\n    ((1, 10), (255, 255, 255, 255)),\n    ((10, 100), (255, 0, 0, 255)),\n    ((100, 256), (255, 255, 0, 255)),\n]\n\ndata, mask = apply_cmap(data, cmap)\n</code></pre>"},{"location":"colormap/#default-rio-tilers-colormaps","title":"Default rio-tiler's colormaps","text":""},{"location":"colormap/#references","title":"References","text":"<ul> <li>Matplotlib colormaps: matplotlib.org/3.1.0/tutorials/colors/colormaps.html</li> <li><code>cfastie</code>: publiclab.org/notes/cfastie/08-26-2014/new-ndvi-colormap</li> <li><code>rplumbo</code>: cogeotiff/rio-tiler!90</li> <li><code>schwarzwald</code>: soliton.vm.bytemark.co.uk/pub/cpt-city/wkp/schwarzwald/tn/wiki-schwarzwald-cont.png.index.html</li> </ul>"},{"location":"colormap/#update-images-for-new-colormaps","title":"Update images for new colormaps","text":"<p>To regenerate these images for new colormaps, update the list of colormaps at the top of <code>docs/scripts/colormap_thumb.py</code> and then run</p> <pre><code>python docs/scripts/colormap_thumb.py\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Issues and pull requests are more than welcome.</p>"},{"location":"contributing/#dev-install","title":"dev install","text":"<pre><code>git clone https://github.com/cogeotiff/rio-tiler.git\ncd rio-tiler\npython -m pip install -e \".[test,dev]\"\n</code></pre> <p>You can then run the tests with the following command:</p> <pre><code>python -m pytest --cov rio_tiler --cov-report term-missing\n</code></pre>"},{"location":"contributing/#performance-tests","title":"Performance tests","text":"<pre><code>python -m pip install -e \".[benchmark]\"\npython -m pytest tests/benchmarks/benchmarks.py --benchmark-only --benchmark-columns 'min, max, mean, median' --benchmark-sort 'min'\n</code></pre>"},{"location":"contributing/#pre-commit","title":"pre-commit","text":"<p>This repo is set to use <code>pre-commit</code> to run isort, flake8, pydocstring, black (\"uncompromising Python code formatter\") and mypy when committing new code.</p> <pre><code>$ pre-commit install\n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<pre><code>git clone https://github.com/cogeotiff/rio-tiler.git\ncd rio-tiler\npython -m pip install -e .[\"docs\"]\n</code></pre> <p>Hot-reloading docs:</p> <pre><code>$ mkdocs serve -f docs/mkdocs.yml\n</code></pre> <p>To manually deploy docs (note you should never need to do this because Github Actions deploys automatically for new commits.):</p> <pre><code>$ mkdocs gh-deploy -f docs/mkdocs.yml\n</code></pre> <pre><code>pdocs as_markdown \\\n   --output_dir docs/src/api/ \\\n   --exclude_source \\\n   --overwrite \\\n   rio_tiler.colormap \\\n   rio_tiler.constants \\\n   rio_tiler.errors \\\n   rio_tiler.expression \\\n   rio_tiler.models \\\n   rio_tiler.io.base \\\n   rio_tiler.io.rasterio \\\n   rio_tiler.io.stac \\\n   rio_tiler.io.xarray \\\n   rio_tiler.mosaic.methods.base \\\n   rio_tiler.mosaic.methods.defaults \\\n   rio_tiler.mosaic.reader \\\n   rio_tiler.profiles \\\n   rio_tiler.reader \\\n   rio_tiler.tasks \\\n   rio_tiler.utils\n</code></pre>"},{"location":"intro/","title":"Introduction","text":""},{"location":"intro/#read-data","title":"Read data","text":"<p><code>rio-tiler</code> has Readers classes which have methods to access data in <code>Tile</code>, <code>Part</code> (bbox), <code>Feature</code> (GeoJSON), <code>Point</code> (lon, lat) or as a whole.</p> <p>Here is a quick overview of how to use rio-tiler's main reader <code>rio_tiler.io.rasterio.Reader</code>:</p> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import ImageData, PointData\n\ntile_x = 691559\ntile_y = 956905\ntile_zoom = 21\n\nwith Reader(\n  \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\"\n) as dst:\n    # Read data for a slippy map tile\n    img = dst.tile(tile_x, tile_y, tile_zoom, tilesize=256)\n    assert isinstance(img, ImageData)  # Image methods return data as rio_tiler.models.ImageData object\n\n    print(img.data.shape)\n    &gt;&gt;&gt; (3, 256, 256)\n    print(img.mask.shape)\n    &gt;&gt;&gt; (256, 256)\n\n    # Read the entire data\n    img = dst.read()\n    print(img.data.shape)\n    &gt;&gt;&gt; (3, 11666, 19836)\n\n    # Read part of a data for a given bbox (we use `max_size=1024` to limit the data transfer and read lower resolution data)\n    img = dst.part([-61.281, 15.539, -61.279, 15.541], max_size=1024)\n    print(img.data.shape)\n    &gt;&gt;&gt; (3, 1024, 1024)\n\n    # Read data for a given geojson polygon (we use `max_size=1024` to limit the data transfer and read lower resolution data)\n    img = dst.feature(geojson_feature, max_size=1024)\n\n    # Get a preview (size is maxed out to 1024 by default to limit the data transfer and read lower resolution data)\n    img = dst.preview()\n    print(img.data.shape)\n    &gt;&gt;&gt; (3, 603, 1024)\n\n    # Get pixel values for a given lon/lat coordinate\n    values = dst.point(-61.281, 15.539)\n    assert isinstance(img, PointData)  # Point methods return data as rio_tiler.models.PointData object\n    print(values.data)\n    &gt;&gt;&gt; [47, 62, 43]\n</code></pre> <p>The <code>rio_tiler.io.rasterio.Reader</code> class has other interesting features, please see User Guide - Readers.</p>"},{"location":"intro/#render-the-data-as-an-image-pngjpeg","title":"Render the data as an image (PNG/JPEG)","text":"<pre><code>with Reader(\n  \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\"\n) as dst:\n    img = dst.tile(691559, 956905, 21, tilesize=256)\n\n    # Encode the data in PNG (default)\n    buff = img.render()\n\n    # Encode the data in JPEG\n    buff = img.render(img_format=\"JPEG\")\n</code></pre>"},{"location":"intro/#rescale-non-byte-data-andor-apply-colormap","title":"Rescale non-byte data and/or apply colormap","text":"<pre><code>from rio_tiler.colormap import cmap\n\n# Get Colormap\ncm = cmap.get(\"viridis\")\n\nwith Reader(\n  \"https://sentinel-cogs.s3.amazonaws.com/sentinel-s2-l2a-cogs/29/R/KH/2020/2/S2A_29RKH_20200219_0_L2A/B01.tif\",\n) as dst:\n    img = dst.tile(239, 220, 9)\n\n    # Rescale the data from 0-10000 to 0-255\n    img.rescale(\n        in_range=((0, 10000),),\n        out_range=((0, 255),),\n    )\n\n    # Apply colormap and create a PNG buffer\n    buff = img.render(colormap=cm) # this returns a buffer (PNG by default)\n</code></pre>"},{"location":"intro/#use-creation-options-to-match-mapnik-defaults","title":"Use creation options to match <code>mapnik</code> defaults.","text":"<pre><code>from rio_tiler.profiles import img_profiles\n\nwith Reader(\n  \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\"\n) as dst:\n    img = dst.tile(691559, 956905, 21, tilesize=256)\n\n    options = img_profiles.get(\"webp\")\n\n    print(options)\n    &gt;&gt;&gt; {'quality': 75, 'lossless': False}\n\n    buff = img.render(img_format=\"webp\", **options)\n</code></pre> <p>Note: Starting with <code>rio-tiler==2.1</code>, when the output datatype is not valid for a driver (e.g <code>float</code> for <code>PNG</code>), <code>rio-tiler</code> will automatically rescale the data using the <code>min/max</code> value for the datatype (ref: cogeotiff/rio-tiler!391).</p>"},{"location":"intro/#write-image-to-file","title":"Write image to file","text":"<pre><code>with open(\"my.png\", \"wb\") as f:\n  f.write(buff)\n</code></pre>"},{"location":"intro/#numpytile","title":"NumpyTile","text":"<p>You can also export image data to a numpy binary format (<code>NPY</code>).</p> <pre><code>with Reader(\n  \"https://sentinel-cogs.s3.amazonaws.com/sentinel-s2-l2a-cogs/29/R/KH/2020/2/S2A_29RKH_20200219_0_L2A/B01.tif\",\n) as dst:\n    img = dst.tile(239, 220, 9)\n\n    buff = img.render(img_format=\"npy\")\n\n    npy_tile = numpy.load(BytesIO(buff))\n    assert npy_tile.shape == (2, 256, 256)  # mask is added to the end of the data\n\n    buff = img.render(img_format=\"npy\", add_mask=False)\n\n    npy_tile = numpy.load(BytesIO(buff))\n    assert npy_tile.shape == (1, 256, 256)\n</code></pre> <p>Learn more about the NumpyTile specification here.</p>"},{"location":"intro/#rio-tilers-magic-partial-reading","title":"<code>rio-tiler</code>'s magic: Partial reading","text":"<p>When the output image size, or the AOI is smaller than the input image, <code>GDAL</code> will try to perform decimated and/or spatial reads on the raster source, minimizing the amount data to transfer. Because of this, performance will be optimal when the source format permits efficient partial reads.</p> <p>The Cloud-Optimized GeoTIFF (COG) format is the recommended format for rio-tiler because it's natively: - internally tiled - has a header with a <code>map</code> of all the tiles - can have internal overviews</p> <p>To learn more about efficiency of COG vs other file formats, check out this blog post.</p>"},{"location":"models/","title":"Models","text":""},{"location":"models/#imagedata","title":"ImageData","text":"<p>Reader methods returning image data  (<code>tile</code>, <code>part</code>, <code>feature</code> and <code>preview</code>) return a data holding class: <code>rio_tiler.models.ImageData</code>.</p> <p>This class has helper methods like <code>render</code> which forward internal data and mask to <code>rio_tiler.utils.render</code> method, but also helps preserving geospatial information (<code>bounds</code> and <code>crs</code>) about the data.</p>"},{"location":"models/#attributes","title":"Attributes","text":"<ul> <li>array: image array (numpy.ma.MaskedArray)</li> <li>assets: assets list used to create the data array (list, optional)</li> <li>bounds: bounds of the data (rasterio.coords.BoundingBox, optional)</li> <li>crs: coordinate reference system for the data (rasterio.crs.CRS, optional)</li> <li>metadata: additional metadata (dict, optional)</li> <li>band_names: image band's names</li> <li>dataset_statistics: Dataset's min/max values (list of (min,max), optional)</li> <li>cutline_mask: array representing the mask for <code>feature</code> methods</li> </ul> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\nd = numpy.zeros((3, 256, 256))\nm = numpy.zeros((3, 256, 256), dtype=\"bool\")\n\ndata = numpy.ma.MaskedArray(d, mask=m)\n\nprint(ImageData(data))\n&gt;&gt;&gt; ImageData(\n    array=masked_array(...),\n    assets=None,\n    bounds=None,\n    crs=None,\n    metadata={},\n    band_names=['b1', 'b2', 'b3'],\n    dataset_statistics=None,\n    cutline_mask=array(),\n)\n</code></pre>"},{"location":"models/#properties","title":"Properties","text":"<ul> <li>width: number of column in the data array (int)</li> <li>height: number of row in the data array (int)</li> <li>count: number of bands in the data array (int)</li> <li>transform: Affine transform created from the bounds and crs (affine.Affine)</li> <li>data: Return data part of the masked array.</li> <li>mask: Return the mask part in form of rasterio dataset mask.</li> </ul>"},{"location":"models/#methods","title":"Methods","text":"<ul> <li> <p>data_as_image(): Return the data array reshaped into an image processing/visualization software friendly order</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\nd = numpy.zeros((3, 256, 256))\nm = numpy.zeros((3, 256, 256), dtype=\"bool\")\ndata = numpy.ma.MaskedArray(d, mask=m)\n\nimg = ImageData(data)\nprint(img.data.shape)\n&gt;&gt;&gt; (3, 256, 256)\n\nimage = img.data_as_image()\nprint(image.shape)\n&gt;&gt;&gt; (256, 256, 3)\n</code></pre> </li> <li> <p>clip(): Clip data and mask to a bbox (in the ImageData CRS).</p> <p>New in version 4.0.0</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.zeros((3, 1024, 1024), dtype=\"uint8\")\nimg = ImageData(data, crs=\"epsg:4326\", bounds=(-180, -90, 180, 90))\n\nimg_c = img.clip((-100, -50, 100, 50))\nassert img_c.count == 3\nassert img_c.bounds == (-100, -50, 100, 50)\n</code></pre> </li> <li> <p>resize(): Resize data and mask.</p> <p>New in version 4.0.0</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.zeros((3, 1024, 1024), dtype=\"uint8\")\nimg = ImageData(data)\n\nimg_r = img.resize(256, 256)\nassert img_r.count == 3\nassert img_r.width == 256\nassert img_r.height == 256\n</code></pre> </li> <li> <p>post_process(): Apply rescaling or/and <code>color-operations</code> formula to the data array. Returns a new ImageData instance.</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.random.randint(0, 3000, (3, 256, 256))\nimg = ImageData(data)\n\nprint(img.data.dtype)\n&gt;&gt;&gt; 'int64'\n\nprint(img.data.max())\n&gt;&gt;&gt; 2999\n\n# rescale the data from 0 -&gt; 3000 to 0 -&gt; 255\n# by default rio-tiler will apply the same `in_range` for all the bands\nimage = img.post_process(in_range=((0, 3000),))\n\n# or provide range for each bands\nimage = img.post_process(in_range=((0, 3000), (0, 1000), (0, 2000)))\n\nassert isinstance(image, ImageData)\n\nprint(image.data.dtype)\n&gt;&gt;&gt; 'uint8'\n\nprint(image.data.max())\n&gt;&gt;&gt; 254\n\n# rescale and apply color-operations formula\nimage = img.post_process(\n    in_range=((0, 3000),),\n    color_formula=\"Gamma RGB 3.1\",\n)\nassert isinstance(image, ImageData)\n</code></pre> </li> <li> <p>statistics(): Return statistics from ImageData.</p> <p>New in version 4.1.7</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.zeros((1, 256, 256), dtype=\"uint8\")\ndata[0, 0:10, 0:10] = 0\ndata[0, 10:11, 10:11] = 100\nimg = ImageData(data)\nstats = img.statistics(categorical=True)\n\nprint(stats[\"b1\"].min)\n&gt;&gt;&gt; 0\n\nprint(stats[\"b1\"].max)\n&gt;&gt;&gt; 100\n\nprint(stats[\"b1\"].majority)\n&gt;&gt;&gt; 0\n\nprint(stats[\"b1\"].minority)\n&gt;&gt;&gt; 100\n\nprint(stats[\"b1\"].unique)\n&gt;&gt;&gt; 2.0\n</code></pre> </li> <li> <p>rescale(): linear rescaling of the data in place</p> <p>New in version 3.1.5</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.random.randint(0, 3000, (3, 256, 256))\nimg = ImageData(data)\n\nprint(img.data.dtype)\n&gt;&gt;&gt; 'int64'\n\nprint(img.data.max())\n&gt;&gt;&gt; 2999\n\n# rescale and apply color-operations formula\nimg.rescale(in_range=((0, 3000),),)\nprint(img.data.max())\n&gt;&gt;&gt; 254\n\nprint(img.data.dtype)\n&gt;&gt;&gt; 'uint8'\n</code></pre> </li> <li> <p>apply_color_formula(): Apply <code>color-operations</code>'s color formula in place</p> <p>New in version 3.1.5</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.random.randint(0, 16000, (3, 256, 256)).astype(\"uint16\")\nimg = ImageData(data)\n\nprint(img.data.dtype)\n&gt;&gt;&gt; 'uint16'\n\nimg.apply_color_formula(\"Gamma RGB 3.5\")\nprint(img.data.dtype)\n&gt;&gt;&gt; 'uint8'\n\nprint(img.data.max())\n&gt;&gt;&gt; 170\n</code></pre> </li> <li> <p>apply_colormap(): Apply colormap to the image data</p> <p>New in version 4.1.6</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ncm = {0: (0, 0, 0, 255), 1: (255, 255, 255, 255)}\nim = ImageData(numpy.zeros((1, 256, 256), dtype=\"uint8\")).apply_colormap(cm)\nassert im.data.shape == (3, 256, 256)\nassert im.data[:, 0, 0].tolist() == [0, 0, 0]\nassert im.mask[0, 0] == 255\nassert im.mask.all()\n</code></pre> </li> <li> <p>apply_expression(): Apply band math expression</p> <p>New in version 4.0</p> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.random.randint(0, 3000, (3, 256, 256))\n\nimg = ImageData(data)\nprint(img.band_names)\n&gt;&gt;&gt; [\"b1\", \"b2\", \"b3\"]  # Defaults\n\nratio = img.apply_expression(\"b1/b2\")  # Returns a new ImageData object\nassert isinstance(ratio, ImageData)\n\nprint(ratio.band_names)\n&gt;&gt;&gt; [\"b1/b2\"]\n\nprint(ratio.data.shape)\n&gt;&gt;&gt; (1, 256, 256)\n</code></pre> </li> <li> <p>render(): Render the data/mask to an image buffer (forward data and mask to rio_tiler.utils.render).</p> <pre><code>import numpy\nfrom rasterio.io import MemoryFile\nfrom rio_tiler.models import ImageData\n\ndef get_meta(content):\n    with MemoryFile(content) as mem:\n        with mem.open() as dst:\n            return dst.meta\n\ndata = numpy.zeros((3, 256, 256), dtype=\"uint8\")\n\nimg = ImageData(data)\n\n# create a PNG image\nbuf = img.render(img_format=\"png\")\nprint(get_meta(buf))\n&gt;&gt;&gt; {\n    'driver': 'PNG',\n    'dtype': 'uint8',\n    'nodata': None,\n    'width': 256,\n    'height': 256,\n    'count': 4,\n    'crs': None,\n    'transform': Affine(1.0, 0.0, 0.0, 0.0, 1.0, 0.0)\n}\n\n# create a JPEG image\nbuf = img.render(img_format=\"jpeg\")\nprint(get_meta(buf))\n&gt;&gt;&gt; {\n    'driver': 'JPEG',\n    'dtype': 'uint8',\n    'nodata': None,\n    'width': 256,\n    'height': 256,\n    'count': 3,\n    'crs': None,\n    'transform': Affine(1.0, 0.0, 0.0, 0.0, 1.0, 0.0)\n}\n</code></pre> </li> </ul> <p>Note: Starting with <code>rio-tiler==2.1</code>, when the output datatype is not valid for a driver (e.g <code>float</code> for <code>PNG</code>), <code>rio-tiler</code> will automatically rescale the data using the <code>min/max</code> value for the datatype (ref: cogeotiff/rio-tiler!391).</p>"},{"location":"models/#pointdata","title":"PointData","text":"<p>New in version 4.0</p>"},{"location":"models/#attributes_1","title":"Attributes","text":"<ul> <li>array: image array (numpy.ma.MaskedArray)</li> <li>assets: assets list used to create the data array (list, optional)</li> <li>coordinates: Coordinates of the point (Tuple[float, float], optional)</li> <li>crs: coordinate reference system for the data (rasterio.crs.CRS, optional)</li> <li>metadata: additional metadata (dict, optional)</li> <li>band_names: values band's names</li> </ul> <pre><code>import numpy\nfrom rio_tiler.models import PointData\n\nd = numpy.zeros((3))\nm = numpy.zeros((1), dtype=\"bool\")\n\ndata = numpy.ma.MaskedArray(d, mask=m)\n\nprint(PointData(data))\n&gt;&gt;&gt; PointData(\n    array=masked_array(data=[0.0, 0.0, 0.0], mask=[False, False, False], fill_value=1e+20),\n    band_names=['b1', 'b2', 'b3'],\n    coordinates=None,\n    crs=None,\n    assets=None,\n    metadata={},\n)\n)\n</code></pre>"},{"location":"models/#properties_1","title":"Properties","text":"<ul> <li>count: number of bands in the data array (int)</li> <li>data: Return data part of the masked array.</li> <li>mask: Return the mask part in form of rasterio dataset mask.</li> </ul>"},{"location":"models/#methods_1","title":"Methods","text":"<ul> <li>as_masked(): Return the data array as a <code>numpy.ma.MaskedArray</code> deprecated</li> </ul> <pre><code>import numpy\nfrom rio_tiler.models import PointData\n\ndata = numpy.zeros((3))\nmasked = PointData(data).as_masked()\nprint(type(masked))\n&gt;&gt;&gt; numpy.ma.core.MaskedArray\n</code></pre> <ul> <li>apply_expression(): Apply band math expression</li> </ul> <pre><code>import numpy\nfrom rio_tiler.models import PointData\n\ndata = numpy.random.randint(0, 3000, (3))\n\npts = PointData(data)\nprint(pts.band_names)\n&gt;&gt;&gt; [\"b1\", \"b2\", \"b3\"]  # Defaults\n\nratio = pts.apply_expression(\"b1/b2\")  # Returns a new PointData object\nassert isinstance(ratio, PointData)\n\nprint(ratio.band_names)\n&gt;&gt;&gt; [\"b1/b2\"]\n\nprint(ratio.count)\n&gt;&gt;&gt; 1\n</code></pre>"},{"location":"models/#others","title":"Others","text":"<p>Readers methods returning metadata like results (<code>info()</code> and <code>statistics()</code>) return pydantic models to make sure the values are valids.</p>"},{"location":"models/#info","title":"Info","text":"<pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import Info\n\n# Schema\nprint(Info.schema())\n&gt;&gt;&gt; {\n    \"title\": \"Info\",\n    \"description\": \"Dataset Info.\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"bounds\": {\n            \"title\": \"Bounds\",\n            \"type\": \"array\",\n            \"items\": [\n                {\n                    \"title\": \"Left\"\n                },\n                {\n                    \"title\": \"Bottom\"\n                },\n                {\n                    \"title\": \"Right\"\n                },\n                {\n                    \"title\": \"Top\"\n                }\n            ]\n        },\n        \"minzoom\": {\n            \"title\": \"Minzoom\",\n            \"type\": \"integer\"\n        },\n        \"maxzoom\": {\n            \"title\": \"Maxzoom\",\n            \"type\": \"integer\"\n        },\n        \"band_metadata\": {\n            \"title\": \"Band Metadata\",\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"array\",\n                \"items\": [\n                    {\n                        \"type\": \"string\"\n                    },\n                    {\n                        \"type\": \"object\"\n                    }\n                ]\n            }\n        },\n        \"band_descriptions\": {\n            \"title\": \"Band Descriptions\",\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"array\",\n                \"items\": [\n                    {\n                        \"type\": \"string\"\n                    },\n                    {\n                        \"type\": \"string\"\n                    }\n                ]\n            }\n        },\n        \"dtype\": {\n            \"title\": \"Dtype\",\n            \"type\": \"string\"\n        },\n        \"nodata_type\": {\n            \"$ref\": \"#/definitions/NodataTypes\"\n        },\n        \"colorinterp\": {\n            \"title\": \"Colorinterp\",\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"string\"\n            }\n        },\n        \"scale\": {\n            \"title\": \"Scale\",\n            \"type\": \"number\"\n        },\n        \"offset\": {\n            \"title\": \"Offset\",\n            \"type\": \"number\"\n        },\n        \"colormap\": {\n            \"title\": \"Colormap\",\n            \"type\": \"object\",\n            \"additionalProperties\": {\n                \"type\": \"array\",\n                \"items\": [\n                    {\n                        \"type\": \"integer\"\n                    },\n                    {\n                        \"type\": \"integer\"\n                    },\n                    {\n                        \"type\": \"integer\"\n                    },\n                    {\n                        \"type\": \"integer\"\n                    }\n                ]\n            }\n        }\n    },\n    \"required\": [\n        \"bounds\",\n        \"minzoom\",\n        \"maxzoom\",\n        \"band_metadata\",\n        \"band_descriptions\",\n        \"dtype\",\n        \"nodata_type\"\n    ],\n    \"definitions\": {\n        \"NodataTypes\": {\n            \"title\": \"NodataTypes\",\n            \"description\": \"rio-tiler Nodata types.\",\n            \"enum\": [\n                \"Alpha\",\n                \"Mask\",\n                \"Internal\",\n                \"Nodata\",\n                \"None\"\n            ],\n            \"type\": \"string\"\n        }\n    }\n}\n\n# Example\nwith Reader(\n  \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\"\n) as src:\n    info = src.info()\n\nprint(info[\"nodata_type\"])\n&gt;&gt;&gt; \"None\"\n\nprint(info.nodata_type)\n&gt;&gt;&gt; \"None\"\n\nprint(info.json(exclude_none=True))\n&gt;&gt;&gt; {\n    'bounds': [-61.287001876638215, 15.537756794450583, -61.27877967704677, 15.542486503997608],\n    'minzoom': 16,\n    'maxzoom': 22,\n    'band_metadata': [('b1', {}), ('b2', {}), ('b3', {})],\n    'band_descriptions': [('b1', ''), ('b2', ''), ('b3', '')],\n    'dtype': 'uint8',\n    'nodata_type': 'None',\n    'colorinterp': ['red', 'green', 'blue'],\n    'count': 3,\n    'driver': 'GTiff',\n    'height': 11666,\n    'overviews': [2, 4, 8, 16, 32, 64],\n    'width': 19836\n}\n</code></pre> <p>Note: starting with <code>rio-tiler&gt;=2.0.8</code>, additional metadata can be set (e.g. driver, count, width, height, overviews in <code>Reader.info()</code>)</p>"},{"location":"models/#bandstatistics","title":"BandStatistics","text":"<pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import BandStatistics\n\n# Schema\nprint(BandStatistics.schema())\n&gt;&gt;&gt; {\n    \"title\": \"BandStatistics\",\n    \"description\": \"Image statistics\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"min\": {\n            \"title\": \"Min\",\n            \"type\": \"number\"\n        },\n        \"max\": {\n            \"title\": \"Max\",\n            \"type\": \"number\"\n        },\n        \"mean\": {\n            \"title\": \"Mean\",\n            \"type\": \"number\"\n        },\n        \"count\": {\n            \"title\": \"Count\",\n            \"type\": \"number\"\n        },\n        \"sum\": {\n            \"title\": \"Sum\",\n            \"type\": \"number\"\n        },\n        \"std\": {\n            \"title\": \"Std\",\n            \"type\": \"number\"\n        },\n        \"median\": {\n            \"title\": \"Median\",\n            \"type\": \"number\"\n        },\n        \"majority\": {\n            \"title\": \"Majority\",\n            \"type\": \"number\"\n        },\n        \"minority\": {\n            \"title\": \"Minority\",\n            \"type\": \"number\"\n        },\n        \"unique\": {\n            \"title\": \"Unique\",\n            \"type\": \"number\"\n        },\n        \"histogram\": {\n            \"title\": \"Histogram\",\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"anyOf\": [\n                        {\n                            \"type\": \"number\"\n                        },\n                        {\n                            \"type\": \"integer\"\n                        }\n                    ]\n                }\n            }\n        },\n        \"valid_percent\": {\n            \"title\": \"Valid Percent\",\n            \"type\": \"number\"\n        },\n        \"masked_pixels\": {\n            \"title\": \"Masked Pixels\",\n            \"type\": \"number\"\n        },\n        \"valid_pixels\": {\n            \"title\": \"Valid Pixels\",\n            \"type\": \"number\"\n        }\n    },\n    \"required\": [\n        \"min\",\n        \"max\",\n        \"mean\",\n        \"count\",\n        \"sum\",\n        \"std\",\n        \"median\",\n        \"majority\",\n        \"minority\",\n        \"unique\",\n        \"histogram\",\n        \"valid_percent\",\n        \"masked_pixels\",\n        \"valid_pixels\"\n    ]\n}\n\n# Example\nwith Reader(\n  \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\"\n) as src:\n    stats = src.statistics()\n    assert isinstance(stats[\"b1\"], BandStatistics)\n\nprint(stats[\"b1\"][\"min\"])\n&gt;&gt;&gt; 0.0\n\nprint(stats[\"b1\"].min)\n&gt;&gt;&gt; 0.0\n\nprint(stats[\"b1\"].json(exclude_none=True))\n&gt;&gt;&gt; {\n    \"min\": 0,\n    \"max\": 255,\n    \"mean\": 93.16424226523633,\n    \"count\": 617472,\n    \"sum\": 57526311,\n    \"std\": 59.261322978176324,\n    \"median\": 94,\n    \"majority\": 0,\n    \"minority\": 253,\n    \"unique\": 256,\n    \"histogram\": [\n        [\n            100540,\n            43602,\n            87476,\n            112587,\n            107599,\n            73453,\n            43623,\n            21971,\n            15006,\n            11615\n        ],\n        [\n            0,\n            25.5,\n            51,\n            76.5,\n            102,\n            127.5,\n            153,\n            178.5,\n            204,\n            229.5,\n            255\n        ]\n    ],\n    \"valid_percent\": 100,\n    \"masked_pixels\": 0,\n    \"valid_pixels\": 617472,\n    \"percentile_2\": 0,\n    \"percentile_98\": 228\n}\n</code></pre>"},{"location":"models/#links","title":"Links","text":"<p>Attrs - Classes Without Boilerplate https://www.attrs.org/en/stable/</p> <p>Pydantic - Define how data should be in pure, canonical python https://pydantic-docs.helpmanual.io</p>"},{"location":"mosaic/","title":"Mosaic","text":"<p>The <code>rio-tiler-mosaic</code> library has been moved into <code>rio-tiler</code>. The goal of the <code>rio_tiler.mosaic</code> module is to create a mercator tile from multiple observations. This is useful when a source image doesn't fill the entire mercator tile of interest.</p> <p>Often when creating a mercator tile from multiple assets, there will be portions of overlap where a pixel could be chosen from multiple datasets. To handle this, the <code>rio-tiler.mosaic</code> module provides pixel selection methods which define how to handle these cases for each pixel:</p> <ul> <li>First: select value from the first non-missing asset</li> <li>Highest: loop though all the assets and return the highest value</li> <li>Lowest: loop though all the assets and return the lowest value</li> <li>Mean: compute the mean value of the whole stack</li> <li>Median: compute the median value of the whole stack</li> <li>Stdev: compute the standard deviation value of the whole stack</li> <li>LastBandHigh: Use last band (highest) as a decision factor (note: the last band will be excluded from in the output)</li> <li>LastBandLow: Use last band (lowest) as a decision factor (note: the last band will be excluded from in the output)</li> </ul>"},{"location":"mosaic/#api","title":"API","text":""},{"location":"mosaic/#image","title":"Image","text":"<p><pre><code>rio_tiler.mosaic.mosaic_reader(\n    mosaic_assets: Sequence[str],\n    reader: Callable[..., ImageData],\n    *args: Any,\n    pixel_selection: Union[Type[MosaicMethodBase], MosaicMethodBase] = FirstMethod,\n    chunk_size: Optional[int] = None,\n    threads: int = MAX_THREADS,\n    allowed_exceptions: Tuple = (TileOutsideBounds,),\n    **kwargs,\n)\n</code></pre> Inputs:</p> <ul> <li>mosaic_assets : list, tuple of rio-tiler compatible assets (url or sceneid)</li> <li>reader: Callable that returns a <code>ImageData</code> instance or a tuple of <code>numpy.array</code></li> <li>*args: arguments to be forwarded to the callable.</li> <li>pixel_selection : optional pixel selection algorithm (default: \"first\").</li> <li>chunk_size: optional, control the number of assets to process per loop.</li> <li>threads: optional, number of threads to use in each loop.</li> <li>allowed_exceptions: optional, allow some exceptions to be ignored.</li> <li>**kwargs: tiler specific keyword arguments.</li> </ul> <p>Returns: - img, assets_used : tuple of ImageData and list of used assets to construct the output data.</p>"},{"location":"mosaic/#examples","title":"Examples","text":"<pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.mosaic import mosaic_reader\nfrom rio_tiler.mosaic.methods import defaults\nfrom rio_tiler.models import ImageData\n\n\ndef tiler(src_path: str, *args, **kwargs) -&gt; ImageData:\n    with Reader(src_path) as src:\n        return src.tile(*args, **kwargs)\n\nmosaic_assets = [\"mytif1.tif\", \"mytif2.tif\", \"mytif3.tif\"]\nx = 1000\ny = 1000\nz = 9\n\n# Use Default First value method\nimg, _ = mosaic_reader(mosaic_assets, tiler, x, y, z)\nassert isinstance(img, ImageData)\nassert img.data.shape == (3, 256, 256)\n\n# Use Highest value: defaults.HighestMethod()\nimg, _ = mosaic_reader(\n    mosaic_assets,\n    tiler,\n    x,\n    y,\n    z,\n    pixel_selection=defaults.HighestMethod()\n)\n</code></pre>"},{"location":"mosaic/#point","title":"Point","text":"<p><pre><code>rio_tiler.mosaic.mosaic_point_reader(\n    mosaic_assets: Sequence[str],\n    reader: Callable[..., PointData],\n    *args: Any,\n    pixel_selection: Union[Type[MosaicMethodBase], MosaicMethodBase] = FirstMethod,\n    chunk_size: Optional[int] = None,\n    threads: int = MAX_THREADS,\n    allowed_exceptions: Tuple = (TileOutsideBounds,),\n    **kwargs,\n)\n</code></pre> Inputs:</p> <ul> <li>mosaic_assets : list, tuple of rio-tiler compatible assets (url or sceneid)</li> <li>reader: Callable that returns a <code>PointData</code> instance</li> <li>*args: arguments to be forwarded to the callable.</li> <li>pixel_selection : optional pixel selection algorithm (default: \"first\").</li> <li>chunk_size: optional, control the number of assets to process per loop.</li> <li>threads: optional, number of threads to use in each loop.</li> <li>allowed_exceptions: optional, allow some exceptions to be ignored.</li> <li>**kwargs: tiler specific keyword arguments.</li> </ul> <p>Returns: - point, assets_used : tuple of PointData and list of used assets to construct the output data.</p>"},{"location":"mosaic/#examples_1","title":"Examples","text":"<pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.mosaic import mosaic_reader\nfrom rio_tiler.mosaic.methods import defaults\nfrom rio_tiler.models import PointData\n\n\ndef point_reader(src_path: str, *args, **kwargs) -&gt; PointData:\n    with Reader(src_path) as src:\n        return src.point(*args, **kwargs)\n\nmosaic_assets = [\"mytif1.tif\", \"mytif2.tif\", \"mytif3.tif\"]\n\n\n# Use Default First value method\npt, _ = mosaic_point_reader(mosaic_assets, point_reader, -40, 32)\nassert isinstance(pt, PointData)\nassert len(pt.data) == 3\n\n# Use Highest value: defaults.HighestMethod()\nimg, _ = mosaic_point_reader(\n    mosaic_assets,\n    point_reader,\n    -40,\n    32,\n    pixel_selection=defaults.HighestMethod()\n)\n</code></pre>"},{"location":"mosaic/#the-mosaicmethod-interface","title":"The <code>MosaicMethod</code> interface","text":"<p>the <code>rio_tiler.mosaic.methods.base.MosaicMethodBase</code> abstract base class defines an interface for all <code>pixel selection</code> methods allowed by <code>rio_tiler.mosaic.mosaic_reader</code>. its methods and properties are:</p>"},{"location":"mosaic/#properties","title":"Properties","text":"<ul> <li>is_done: returns a boolean indicating if the process is done filling the array</li> <li>data: returns the output mosaic array (numpy.masked.array)</li> </ul>"},{"location":"mosaic/#methods","title":"Methods","text":"<ul> <li>feed(array: numpy.ma.ndarray): update the tile and mask</li> </ul>"},{"location":"mosaic/#writing-your-own-pixel-selection-method","title":"Writing your own Pixel Selection method","text":"<p>The rules for writing your own <code>pixel selection algorithm</code> class are as follows:</p> <ul> <li>Must inherit from <code>MosaicMethodBase</code></li> <li>Must provide concrete implementations of all the above methods.</li> </ul> <p>See <code>rio_tiler.mosaic.methods.defaults</code> classes for examples.</p>"},{"location":"mosaic/#smart-multi-threading","title":"Smart Multi-Threading","text":"<p>When dealing with an important number of image, you might not want to process the whole stack, especially if the pixel selection method stops when the tile is filled. To allow better optimization, <code>rio_tiler.mosaic.mosaic_reader</code> is fetching the tiles in parallel (threads) but to limit the number of files we also embedded the fetching in a loop (creating 2 level of processing):</p> <p><pre><code>mosaic_assets = [\"1.tif\", \"2.tif\", \"3.tif\", \"4.tif\", \"5.tif\", \"6.tif\"]\n\n# 1st level loop - Creates chunks of assets\nfor chunks in _chunks(mosaic_assets, chunk_size):\n\n    # 2nd level loop - Uses threads for process each `chunk`\n    with futures.ThreadPoolExecutor(max_workers=max_threads) as executor:\n        future_tasks = [(executor.submit(_tiler, asset), asset) for asset in chunks]\n</code></pre> By default the chunk_size is equal to the number or threads (or the number of assets if no threads=0)</p>"},{"location":"mosaic/#more-on-threading","title":"More on threading","text":"<p>The number of threads used can be set in the function call with the <code>threads=</code> options. By default it will be equal to <code>multiprocessing.cpu_count() * 5</code> or to the <code>RIO_TILER_MAX_THREADS</code> environment variable. In some case, threading can slow down your application. You can set threads to <code>0</code> or <code>1</code> to run the tiler in a loop without using a ThreadPool (ref: #207).</p> <p>Benchmark: <pre><code>--------------------------------- benchmark '1images': 6 tests ---------------------------------\nName (time in ms)         Min                Max               Mean             Median\n------------------------------------------------------------------------------------------------\n1images-0threads      64.3108 (1.0)      66.9192 (1.0)      65.0202 (1.0)      64.9370 (1.0)\n1images-4threads      69.0893 (1.07)     70.9919 (1.06)     69.6718 (1.07)     69.5102 (1.07)\n1images-1threads      69.4884 (1.08)     71.8967 (1.07)     70.0853 (1.08)     69.9804 (1.08)\n1images-5threads      69.5552 (1.08)     75.5498 (1.13)     71.7882 (1.10)     70.9849 (1.09)\n1images-3threads      69.7684 (1.08)     74.4098 (1.11)     70.6282 (1.09)     70.2353 (1.08)\n1images-2threads      69.9258 (1.09)     73.8798 (1.10)     70.8861 (1.09)     70.3682 (1.08)\n------------------------------------------------------------------------------------------------\n\n----------------------------------- benchmark '5images': 6 tests -----------------------------------\nName (time in ms)          Min                 Max                Mean              Median\n----------------------------------------------------------------------------------------------------\n5images-5threads      104.1609 (1.0)      123.4442 (1.0)      110.4130 (1.0)      110.0683 (1.0)\n5images-4threads      160.0952 (1.54)     170.7994 (1.38)     163.6062 (1.48)     161.8923 (1.47)\n5images-3threads      161.2354 (1.55)     172.0363 (1.39)     165.1222 (1.50)     164.6513 (1.50)\n5images-2threads      214.2413 (2.06)     220.7737 (1.79)     217.7740 (1.97)     217.9166 (1.98)\n5images-0threads      228.2062 (2.19)     242.9397 (1.97)     231.9848 (2.10)     229.2843 (2.08)\n5images-1threads      248.6630 (2.39)     251.8809 (2.04)     250.5195 (2.27)     251.2667 (2.28)\n----------------------------------------------------------------------------------------------------\n</code></pre> ref: github.com/cogeotiff/rio-tiler/issues/207#issuecomment-665958838</p>"},{"location":"readers/","title":"Readers","text":"<p><code>rio-tiler</code>'s  Reader are built from its abstract base classes (<code>BaseReader</code>, <code>MultiBandReader</code>, <code>MultiBaseReader</code>). Those Classes implements defaults interfaces which helps the integration in broader application. To learn more about <code>rio-tiler</code>'s base classes see Base classes and custom readers</p>"},{"location":"readers/#rio_tileriorasterioreader","title":"rio_tiler.io.rasterio.Reader","text":"<p>The <code>Reader</code> is designed to work with simple raster datasets (e.g COG, GeoTIFF, ...).</p> <p>The class is derived from the <code>rio_tiler.io.base.BaseReader</code> base class. <pre><code>from rio_tiler.io import Reader\n\nReader.__mro__\n&gt;&gt;&gt; (rio_tiler.io.rasterio.Reader,\n rio_tiler.io.base.BaseReader,\n rio_tiler.io.base.SpatialMixin,\n object)\n</code></pre></p>"},{"location":"readers/#attributes","title":"Attributes","text":"<ul> <li>input (str): filepath</li> <li>dataset (rasterio dataset, optional): rasterio opened dataset</li> <li>tms (morecantile.TileMatrixSet, optional): morecantile TileMatrixSet used for tile reading (defaults to WebMercator)</li> <li>geographic_crs (rasterio.crs.CRS, optional): CRS to use to calculate the geographic bounds (default to WGS84)</li> <li>colormap (dict, optional): dataset's colormap</li> <li>options (rio_tiler.reader.Options, optional): Options to forward to rio_tiler.reader functions (e.g nodata, vrt_options, resampling)</li> </ul>"},{"location":"readers/#properties","title":"Properties","text":"<ul> <li>bounds: dataset's bounds (in dataset crs)</li> <li>crs: dataset's crs</li> <li>geographic_bounds: dataset's bounds in WGS84</li> <li>minzoom: dataset minzoom (in TMS)</li> <li>maxzoom: dataset maxzoom (in TMS)</li> </ul> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"myfile.tif\") as src:\n    print(src.dataset)\n    print(src.tms.identifier)\n    print(src.minzoom)\n    print(src.maxzoom)\n    print(src.bounds)\n    print(src.crs)\n    print(src.geographic_bounds)\n    print(src.colormap)\n\n&gt;&gt; &lt;open DatasetReader name='myfile.tif' mode='r'&gt;\nWebMercatorQuad\n16\n22\n(683715.3266400001, 1718548.5702, 684593.2680000002, 1719064.90736)\nEPSG:32620\n(-61.287001876638215, 15.537756794450583, -61.27877967704677, 15.542486503997608)\n{}\n</code></pre>"},{"location":"readers/#methods","title":"Methods","text":"<ul> <li>read(): Read the entire dataset</li> </ul> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import ImageData\n\nwith Reader(\"myfile.tif\") as src:\n    img = src.read()\n    assert isinstance(img, ImageData)\n    assert img.crs == src.dataset.crs\n    assert img.assets == [\"myfile.tif\"]\n    assert img.width == src.dataset.width\n    assert img.height == src.dataset.height\n    assert img.count == src.dataset.count\n\n# With indexes\nwith Reader(\"myfile.tif\") as src:\n    img = src.read(indexes=1)  # or src.read(indexes=(1,))\n    assert img.count == 1\n    assert img.band_names == [\"b1\"]\n\n# With expression\nwith Reader(\"myfile.tif\") as src:\n    img = src.read(expression=\"b1/b2\")\n    assert img.count == 1\n    assert img.band_names == [\"b1/b2\"]\n</code></pre> <ul> <li>tile(): Read map tile from a raster</li> </ul> <pre><code>from rio_tiler.contants import WEB_MERCATOR_CRS\nfrom rio_tiler.io import Reader\nfrom rio_tiler.models import ImageData\n\nwith Reader(\"myfile.tif\") as src:\n    # src.tile(tile_x, tile_y, tile_z, **kwargs)\n    img = src.tile(1, 2, 3, tilesize=256)\n    assert isinstance(img, ImageData)\n    assert img.crs == WEB_MERCATOR_CRS\n    assert img.assets == [\"myfile.tif\"]\n\n# With indexes\nwith Reader(\"myfile.tif\") as src:\n    img = src.tile(1, 2, 3, tilesize=256, indexes=1)\n    assert img.count == 1\n\n# With expression\nwith Reader(\"myfile.tif\") as src:\n    img = src.tile(1, 2, 3, tilesize=256, expression=\"B1/B2\")\n    assert img.count == 1\n\n# Using buffer\n# Sometime, to avoid edge artefacts, you may want to read buffered tile data.\n# ref:\n# - https://github.com/cogeotiff/rio-tiler/issues/365\n# - https://github.com/cogeotiff/rio-tiler/pull/405\nwith Reader(\"myfile.tif\") as src:\n    # add 0.5 pixel on each side of the tile\n    img = src.tile(1, 2, 3, buffer=0.5)\n    assert img.width == 257\n    assert img.height == 257\n\n    # add 1 pixel on each side of the tile\n    img = src.tile(1, 2, 3, buffer=1)\n    assert img.width == 258\n    assert img.height == 258\n</code></pre> <ul> <li>part(): Read a raster for a given bounding box (<code>bbox</code>). By default the bbox is considered to be in WGS84.</li> </ul> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import ImageData\n\nwith Reader(\"myfile.tif\") as src:\n    # src.part((minx, miny, maxx, maxy), **kwargs)\n    img = src.part((10, 10, 20, 20))\n    assert isinstance(img, ImageData)\n    assert img.crs == WGS84_CRS\n    assert img.assets == [\"myfile.tif\"]\n    assert img.bounds == (10, 10, 20, 20)\n\n# Pass bbox in WGS84 (default) but return data in the input dataset CRS\nwith Reader(\"myfile.tif\") as src:\n    img = src.part((10, 10, 20, 20), dst_crs=src.dataset.crs)\n    assert img.crs == src.dataset.crs\n\n# Limit output size\nwith Reader(\"myfile.tif\") as src:\n    img = src.part((10, 10, 20, 20), max_size=2000)\n\n# With indexes\nwith Reader(\"myfile.tif\") as src:\n    img = src.part((10, 10, 20, 20), indexes=1)\n\n# With expression\nwith Reader(\"myfile.tif\") as src:\n    img = src.part((10, 10, 20, 20), expression=\"b1/b2\")\n</code></pre> <ul> <li>feature(): Read a raster for a geojson feature. By default the feature is considered to be in WGS84.</li> </ul> <pre><code>from rio_tiler.constants import WGS84_CRS\nfrom rio_tiler.io import Reader\nfrom rio_tiler.models import ImageData\n\nfeat = {\n    \"type\": \"Feature\",\n    \"properties\": {},\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n            [\n                [-54.45, 73.05],\n                [-55.05, 72.79],\n                [-55.61, 72.46],\n                [-53.83, 72.36],\n                [-54.45, 73.05],\n            ]\n        ],\n    },\n}\n\nwith Reader(\"myfile.tif\") as src:\n    # src.part(geojson_feature, **kwargs)\n    img = src.feature(feat)\n    assert isinstance(img, ImageData)\n    assert img.crs == WGS84_CRS\n    assert img.assets == [\"myfile.tif\"]\n    assert img.bounds == (-55.61, 72.36, -53.83, 73.05)  # bbox of the input feature\n\n# Pass bbox in WGS84 (default) but return data in the input dataset CRS\nwith Reader(\"myfile.tif\") as src:\n    img = src.feature(feat, dst_crs=src.dataset.crs)\n    assert img.crs == src.dataset.crs\n\n# Limit output size\nwith Reader(\"myfile.tif\") as src:\n    img = src.feature(feat, max_size=2000)\n\n# Read high resolution\nwith Reader(\"myfile.tif\") as src:\n    img = src.feature(feat, max_size=None)\n\n# With indexes\nwith Reader(\"myfile.tif\") as src:\n    img = src.feature(feat, indexes=1)\n\n# With expression\nwith Reader(\"myfile.tif\") as src:\n    img = src.feature(feat, expression=\"b1/b2\")\n</code></pre> <ul> <li>preview(): Read a preview of a raster</li> </ul> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import ImageData\n\nwith Reader(\"myfile.tif\") as src:\n    img = src.preview()\n    assert isinstance(img, ImageData)\n\n# With indexes\nwith Reader(\"myfile.tif\") as src:\n    img = src.preview(indexes=1)\n\n# With expression\nwith Reader(\"myfile.tif\") as src:\n    img = src.preview(expression=\"b1+2;b1*4\")\n</code></pre> <ul> <li>point(): Read the pixel values of a raster for a given <code>lon, lat</code> coordinates. By default the coordinates are considered to be in WGS84.</li> </ul> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import PointData\n\nwith Reader(\"myfile.tif\") as src:\n    # src.point(lon, lat)\n    pt = src.point(-100, 25)\n    assert isinstance(pt, PointData)\n\n# With indexes\nwith Reader(\"myfile.tif\") as src:\n    pt = src.point(-100, 25, indexes=1)\n    print(pt.data)\n&gt;&gt;&gt; [1]\n\n# With expression\nwith Reader(\"myfile.tif\") as src:\n    pt = src.point(-100, 25, expression=\"b1+2;b1*4\")\n    print(pt.data)\n&gt;&gt;&gt; [3, 4]\n</code></pre> <ul> <li>info(): Return simple metadata about the dataset</li> </ul> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import Info\n\nwith Reader(\"myfile.tif\") as src:\n    info = src.info()\n    assert isinstance(info, Info)\n\nprint(info.model_dump(exclude_none=True))\n&gt;&gt;&gt; {\n    \"bounds\": [-119.05915661478785, 13.102845359730287, -84.91821332299578, 33.995073647795806],\n    \"minzoom\": 3,\n    \"maxzoom\": 12,\n    \"band_metadata\": [[\"b1\", {}]],\n    \"band_descriptions\": [[\"b1\", \"\"]],\n    \"dtype\": \"int8\",\n    \"colorinterp\": [\"palette\"],\n    \"nodata_type\": \"Nodata\",\n    \"colormap\": {\n        \"0\": [0, 0, 0, 0],\n        \"1\": [0, 61, 0, 255],\n        ...\n    },\n    \"driver\": \"GTiff\",\n    \"count\": 1,\n    \"width\": 1000,\n    \"height\": 2000,\n    \"overviews\": [2, 4, 8],\n}\n</code></pre> <ul> <li>statistics(): Return image statistics (Min/Max/Stdev)</li> </ul> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"myfile.tif\") as src:\n    stats = src.statistics()\n    assert isinstance(stats, dict)\n\n# stats will be in form or {\"band\": BandStatistics(), ...}\nprint(stats)\n&gt;&gt;&gt; {\n    'b1': BandStatistics(...),\n    'b2': BandStatistics(...),\n    'b3': BandStatistics(...)\n}\n\nprint(stats[\"b1\"].model_dump())\n&gt;&gt;&gt; {\n    \"min\": 1,\n    \"max\": 7872,\n    \"mean\": 2107.524612053134,\n    \"count\": 1045504,\n    \"sum\": 2203425412,\n    \"std\": 2271.0065537857326,\n    \"median\": 2800,\n    \"majority\": 1,\n    \"minority\": 7072,\n    \"unique\": 15,\n    \"histogram\": [\n        [...],\n        [...]\n    ],\n    \"valid_percent\": 100,\n    \"masked_pixels\": 0,\n    \"valid_pixels\": 1045504,\n    \"percentile_98\": 6896,\n    \"percentile_2\": 1\n}\n\nwith Reader(\"myfile_with_colormap.tif\") as src:\n    stats = src.statistics(categorical=True, categories=[1, 2])  # we limit the categories to 2 defined value (defaults to all dataset values)\n    assert isinstance(stats, dict)\n\nprint(stats)\n&gt;&gt;&gt; {\n    'b1': BandStatistics(...)\n}\n# For categorical data, the histogram will represent the density of EACH value.\nprint(stats[\"b1\"].model_dump())\n&gt;&gt;&gt; {\n    ...\n    \"histogram\": [\n        [1, 2],\n        [100, 20000]\n    ],\n    ...\n}\n</code></pre>"},{"location":"readers/#read-options","title":"Read Options","text":"<p><code>Reader</code> accepts several input options which will be forwarded to the <code>rio_tiler.reader.read</code> function (low level function accessing the data), those options can be set as reader's attribute or within each method calls:</p> <ul> <li>nodata: Overwrite the nodata value (or set if not present)</li> <li>unscale: Apply internal rescaling factors</li> <li>vrt_options: Pass WarpedVRT Option (see: gdal.org/api/gdalwarp_cpp.html?highlight=vrt#_CPPv415GDALWarpOptions)</li> <li>resampling_method: Set default <code>resampling_method</code></li> <li>reprojection_method: Set default <code>reprojection_method</code></li> <li>post_process: Function to apply after the read operations</li> </ul> <pre><code>with Reader(\"my_cog.tif\", options={\"nodata\": 0}) as src:\n   src.tile(1, 1, 1)\n\n# is equivalent to\n\nwith Reader(\"my_cog.tif\") as src:\n    src.tile(1, 1, 1, nodata=0)\n</code></pre>"},{"location":"readers/#rio_tileriostacstacreader","title":"rio_tiler.io.stac.STACReader","text":"<p>In <code>rio-tiler</code> v2, we added a <code>rio_tiler.io.STACReader</code> to allow tile/metadata fetching of assets withing a STAC item.</p> <p>The class is derived from the <code>rio_tiler.io.base.MultiBaseReader</code> base class which help handling responses from multiple <code>BaseReader</code> (each asset will be read with a <code>BaseReader</code>). <pre><code>from rio_tiler.io import STACReader\n\nSTACReader.__mro__\n&gt;&gt;&gt; (rio_tiler.io.stac.STACReader,\n rio_tiler.io.base.MultiBaseReader,\n rio_tiler.io.base.BaseReader,\n rio_tiler.io.base.SpatialMixin,\n object)\n</code></pre></p>"},{"location":"readers/#attributes_1","title":"Attributes","text":"<ul> <li>input (str): STAC Item path, URL or S3 URL</li> <li>item: PySTAC item</li> <li>tms (morecantile.TileMatrixSet, optional): morecantile TileMatrixSet used for tile reading (defaults to WebMercator)</li> <li>minzoom (int, optional): dataset's minimum zoom level (for input tms)</li> <li>maxzoom (int, optional): dataset's maximum zoom level (for input tms)</li> <li>geographic_crs (rasterio.crs.CRS, optional): CRS to use to calculate the geographic bounds (default to WGS84)</li> <li>include_assets (set, optional): Set of assets to include from the <code>available</code> asset list</li> <li>exclude_assets (set, optional): Set of assets to exclude from the <code>available</code> asset list</li> <li>include_asset_types (set, optional): asset types to consider as valid type for the reader</li> <li>exclude_asset_types (set, optional): asset types to consider as invalid type for the reader</li> <li>reader (BaseReader, optional): Reader to use to read assets (defaults to rio_tiler.io.rasterio.Reader)</li> <li>reader_options (dict, optional): Options to forward to the reader init</li> <li>fetch_options (dict, optional): Options to pass to the <code>httpx.get</code> or <code>boto3</code> when fetching the STAC item</li> </ul>"},{"location":"readers/#properties_1","title":"Properties","text":"<ul> <li>assets: Asset list.</li> <li>bounds: dataset's bounds (in dataset crs)</li> <li>crs: dataset's crs</li> <li>geographic_bounds: dataset's bounds in WGS84</li> </ul> <pre><code>from rio_tiler.io import STACReader\n\nwith STACReader(\n    \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\",\n    exclude_assets={\"thumbnail\"}\n) as stac:\n    print(stac.input)\n    print(stac.item)\n    print(stac.assets)\n    print(stac.tms.identifier)\n    print(stac.minzoom)\n    print(stac.maxzoom)\n    print(stac.bounds)\n    print(stac.crs)\n    print(stac.geographic_bounds)\n\n&gt;&gt;&gt; https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\n&lt;Item id=S2A_34SGA_20200318_0_L2A&gt;\n['overview', 'visual', 'B01', 'B02', 'B03', 'B04', 'B05', 'B06', 'B07', 'B08', 'B8A', 'B09', 'B11', 'B12', 'AOT', 'WVP', 'SCL']\nWebMercatorQuad\n0\n24\n[23.293255090449595, 31.505183020453355, 24.296453548295318, 32.51147809805106]\nEPSG:4326\n(23.293255090449595, 31.505183020453355, 24.296453548295318, 32.51147809805106)\n</code></pre>"},{"location":"readers/#methods_1","title":"Methods","text":"<p>The <code>STACReader</code> has the same methods as the <code>Reader</code> (defined by the BaseReader/MultiBaseReader classes).</p> <p>Important</p> <ul> <li>Most of <code>STACReader</code> methods require to set either <code>assets=</code> or <code>expression=</code> option.</li> <li><code>asset_indexes</code> and <code>asset_expression</code> are available for all STACReader methods except <code>info</code>.</li> </ul> <ul> <li>tile(): Read map tile from a STAC Item</li> </ul> <pre><code>from rio_tiler.io import STACReader\n\nstac_url = \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\"\n\n# Using `assets=`\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.tile(x, y, z, assets=?, expression=?, asset_expression=?, asset_indexes=?, **kwargs)\n    img = stac.tile(\n        145,\n        103,\n        8,\n        tilesize=256,\n        assets=[\"B01\", \"B02\"],\n    )\n    assert img.count == 2  # each assets have one band\n\nprint(img.assets)\n&gt;&gt;&gt; [\n    'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/34/S/GA/2020/3/S2A_34SGA_20200318_0_L2A/B01.tif',\n    'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/34/S/GA/2020/3/S2A_34SGA_20200318_0_L2A/B02.tif',\n]\nprint(img.band_names)\n&gt;&gt;&gt; ['B01_b1', 'B02_b1']\n\n# Using `expression=`\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"}) as stac:\n    img = stac.tile(\n        145,\n        103,\n        8,\n        tilesize=256,\n        expression=\"B01_b1/B02_b1\",\n    )\n    assert img.count == 1\n\n# Using `assets=` + `asset_indexes` (select a specific index in an asset)\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    img = stac.tile(\n        145,\n        103,\n        8,\n        tilesize=256,\n        assets=[\"B01\"],\n        asset_indexes={\n            \"B01\": (1, 1, 1),  # return the first band 3 times\n        }\n    )\n    assert img.count == 3\n</code></pre> <ul> <li>part(): Read a STAC item for a given bounding box (<code>bbox</code>). By default the bbox is considered to be in WGS84.</li> </ul> <pre><code>bbox = (23.8, 31.9, 24.1, 32.2)\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.part((minx, miny, maxx, maxy), assets=?, expression=?, asset_expression=?, asset_indexes=?, **kwargs)\n    img = stac.part(bbox, assets=[\"B01\", \"B02\"], max_size=128)\n    assert img.count == 2  # each assets have one band\n</code></pre> <ul> <li>feature(): Read a STAC item for a geojson feature. By default the feature is considered to be in WGS84.</li> </ul> <pre><code>feat = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"coordinates\": [\n            [\n                [23.8, 32.2],\n                [23.8, 31.9],\n                [24.1, 31.9],\n                [24.1, 32.2],\n                [23.8, 32.2]\n            ]\n        ],\n        \"type\": \"Polygon\"\n    }\n}\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.feature(feature, assets=?, expression=?, asset_expression=?, asset_indexes=?, **kwargs)\n    img = stac.feature(feat, assets=[\"B01\", \"B02\"], max_size=128)\n    assert img.count == 2  # each assets have one band\n</code></pre> <ul> <li>preview(): Read a preview of STAC Item</li> </ul> <pre><code>with STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.preview(assets=?, expression=?, asset_expression=?, asset_indexes=?, **kwargs)\n    img = stac.preview(assets=[\"B01\", \"B02\"], max_size=128)\n    assert img.count == 2  # each assets have one band\n</code></pre> <ul> <li>point(): Read the pixel values for assets for a given <code>lon, lat</code> coordinates. By default the coordinates are considered to be in WGS84.</li> </ul> <pre><code>with STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.point(lon, lat, assets=?, expression=?, asset_expression=?, asset_indexes=?, **kwargs)\n    data = stac.point(24.1, 31.9, assets=[\"B01\", \"B02\"])\n\nprint(data.data)\n&gt;&gt;&gt; [\n    3595,  # values for B01\n    3198  # values for B02\n]\n</code></pre> <ul> <li>info(): Return simple metadata about the assets</li> </ul> <pre><code>with STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.info(assets=?, **kwargs)\n    info = stac.info(assets=[\"B01\", \"B02\"])\n\nprint(list(info))\n&gt;&gt;&gt; [\"B01\", \"B02\"]\n\nprint(info[\"B01\"].json(exclude_none=True))\n&gt;&gt;&gt; {\n    \"bounds\": [23.106076243528157, 31.505173744374172, 24.296464503939948, 32.519334871696195],\n    \"minzoom\": 8,\n    \"maxzoom\": 11,\n    \"band_metadata\": [[\"b1\", {}]],\n    \"band_descriptions\": [[\"b1\", \"\"]],\n    \"dtype\": \"uint16\",\n    \"nodata_type\": \"Nodata\",\n    \"colorinterp\": [\"gray\"],\n    \"nodata_value\": 0.0,\n    \"width\": 1830,\n    \"driver\": \"GTiff\",\n    \"height\": 1830,\n    \"overviews\": [2, 4, 8],\n    \"count\": 1\n}\n</code></pre> <ul> <li>statistics(): Return per assets statistics (Min/Max/Stdev)</li> </ul> <pre><code>with STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.statistics(assets=?, asset_expression=?, asset_indexes=?, **kwargs)\n    stats = stac.statistics(assets=[\"B01\", \"B02\"], max_size=128)\n\n# stats will be in form or {\"asset\": {\"band\": BandStatistics(), ...}, ...}\nprint(list(stats))\n&gt;&gt;&gt; [\"B01\", \"B02\"]\n\nprint(list(stats[\"B01\"]))\n&gt;&gt;&gt; [\"b1\"]  # B01 has only one band entry \"1\"\n\nprint(stats[\"B01\"][\"b1\"].json(exclude_none=True))\n{\n    \"min\": 283.0,\n    \"max\": 7734.0,\n    \"mean\": 1996.959687371452,\n    \"count\": 12155.0,\n    \"sum\": 24273045.0,\n    \"std\": 1218.4455268717047,\n    \"median\": 1866.0,\n    \"majority\": 322.0,\n    \"minority\": 283.0,\n    \"unique\": 4015.0,\n    \"histogram\": [\n        [3257.0, 2410.0, 2804.0, 1877.0, 1050.0, 423.0, 199.0, 93.0, 31.0, 11.0],\n        [283.0, 1028.1, 1773.2, 2518.3, 3263.4, 4008.5, 4753.6, 5498.7, 6243.8, 6988.900000000001, 7734.0]\n    ],\n    \"valid_percent\": 74.19,\n    \"masked_pixels\": 4229.0,\n    \"valid_pixels\": 12155.0,\n    \"percentile_2\": 326.08000000000004,\n    \"percentile_98\": 5026.76\n}\n</code></pre> <ul> <li>merged_statistics(): Return statistics when merging assets</li> </ul> <p>The <code>merged_statistics</code> enable the use of <code>expression</code> to perform assets mixing (e.g <code>\"asset1/asset2\"</code>). The main difference with the <code>statistics</code> method is that we will first use the <code>self.preview</code> method to obtain a merged array and then calculate the statistics.</p> <pre><code>with STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.statistics(assets=?, asset_expression=?, asset_indexes=?, **kwargs)\n    stats = stac.merged_statistics(assets=[\"B01\", \"B02\"], max_size=128)\n\n# stats will be in form or {\"band\": BandStatistics(), ...}\nprint(list(stats))\n&gt;&gt;&gt; [\"B01_b1\", \"B02_b1\"]\n\nassert isinstance(stats[\"B01_b1\"], BandStatistics)\n\nprint(info[\"B01_b1\"].json(exclude_none=True))\n{\n    \"min\": 283.0,\n    \"max\": 7734.0,\n    \"mean\": 1996.959687371452,\n    \"count\": 12155.0,\n    \"sum\": 24273045.0,\n    \"std\": 1218.4455268717047,\n    \"median\": 1866.0,\n    \"majority\": 322.0,\n    \"minority\": 283.0,\n    \"unique\": 4015.0,\n    \"histogram\": [\n        [3257.0, 2410.0, 2804.0, 1877.0, 1050.0, 423.0, 199.0, 93.0, 31.0, 11.0],\n        [283.0, 1028.1, 1773.2, 2518.3, 3263.4, 4008.5, 4753.6, 5498.7, 6243.8, 6988.900000000001, 7734.0]\n    ],\n    \"valid_percent\": 74.19,\n    \"masked_pixels\": 4229.0,\n    \"valid_pixels\": 12155.0,\n    \"percentile_2\": 326.08000000000004,\n    \"percentile_98\": 5026.76\n}\n\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    # stac.statistics(assets=?, asset_expression=?, asset_indexes=?, **kwargs)\n    stats = stac.merged_statistics(expression=[\"B01_b1/B02_b1\"], max_size=128)\n\nprint(list(stats))\n&gt;&gt;&gt; [\"B01_b1/B02_b1\"]\n\nassert isinstance(stats[\"B01_b1/B02_b1\"], BandStatistics)\n</code></pre>"},{"location":"readers/#stac-expression","title":"STAC Expression","text":"<p>When using <code>expression</code>, the user will need to explicitly pass the band number to use within the asset e.g: <code>asset1_b1 + asset2_b2</code>.</p>"},{"location":"readers/#asset-as-band","title":"Asset As Band","text":"<p>in rio-tiler <code>4.1.0</code>, we've added <code>asset_as_band: bool</code> option to the data methods (tile, feature, part, preview, point) to tell the reader to treat each asset as a dataset band. This is specifically useful for <code>expression</code></p> <pre><code># For expression, without `asset_as_band` tag, users have to pass `_b{n}` suffix to indicate the band index\nwith STACReader(STAC_PATH) as stac:\n    img = stac.tile(71, 102, 8, expression=\"green_b1/red_b1\")\n    assert img.band_names == [\"green_b1/red_b1\"]\n\n# With `asset_as_band=True`, expression can be the asset names\nwith STACReader(STAC_PATH) as stac:\n    img = stac.tile(71, 102, 8, expression=\"green/red\", asset_as_band=True)\n    assert img.band_names == [\"green/red\"]\n</code></pre>"},{"location":"readers/#rio_tileriorasterioimagereader","title":"rio_tiler.io.rasterio.ImageReader","text":"<p>The <code>Reader</code> is designed to work with simple raster datasets in their pixel coordinates.</p> <p>The class is derived from the <code>rio_tiler.io.rasterio.Reader</code> class. <pre><code>from rio_tiler.io import ImageReader\n\nImageReader.__mro__\n&gt;&gt;&gt; (rio_tiler.io.rasterio.ImageReader,\n rio_tiler.io.rasterio.Reader,\n rio_tiler.io.base.BaseReader,\n rio_tiler.io.base.SpatialMixin,\n object)\n</code></pre></p>"},{"location":"readers/#attributes_2","title":"Attributes","text":"<ul> <li>input (str): filepath</li> <li>dataset (rasterio dataset, optional): rasterio opened dataset</li> <li>colormap (dict, optional): dataset's colormap</li> <li>options (rio_tiler.reader.Options, optional): Options to forward to rio_tiler.reader functions (e.g nodata, vrt_options, resampling)</li> </ul>"},{"location":"readers/#properties_2","title":"Properties","text":"<ul> <li>bounds: dataset's bounds (in dataset crs)</li> <li>transform: dataset Affine transform (in pixel coordinates)</li> <li>minzoom: dataset minzoom</li> <li>maxzoom: dataset maxzoom</li> </ul> <pre><code>from rio_tiler.io import ImageReader\n\nwith ImageReader(\"image.jpg\") as src:\n    print(src.dataset)\n    print(src.minzoom)\n    print(src.maxzoom)\n    print(src.transform)\n    print(src.bounds)\n    print(src.colormap)\n\n&gt;&gt; &lt;open DatasetReader name='image.jpeg' mode='r'&gt;\n0\n3\nAffine(1.0, 0.0, 0.0,  0.0, 1.0, 0.0)\n(0, 2000, 2000, 0)\n{}\n</code></pre>"},{"location":"readers/#methods_2","title":"Methods","text":"<ul> <li>read(): Read the entire dataset</li> </ul> <pre><code>from rio_tiler.io import ImageReader\nfrom rio_tiler.models import ImageData\n\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.read()\n    assert isinstance(img, ImageData)\n    assert not img.crs\n    assert img.assets == [\"image.jpeg\"]\n    assert img.width == src.dataset.width\n    assert img.height == src.dataset.height\n    assert img.count == src.dataset.count\n\n# With indexes\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.read(indexes=1)  # or src.read(indexes=(1,))\n    assert img.count == 1\n    assert img.band_names == [\"b1\"]\n\n# With expression\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.read(expression=\"b1/b2\")\n    assert img.count == 1\n    assert img.band_names == [\"b1/b2\"]\n</code></pre> <ul> <li>tile(): Read tile from the image</li> </ul> <p>For ImageReader we are using a custom <code>LocalTileMatrixSet</code> constructed from the dataset width and height. The origin is the Top-Left of the image.</p> <pre><code>from rio_tiler.io import ImageReader\nfrom rio_tiler.models import ImageData\n\nwith ImageReader(\"image.jpeg\") as src:\n    # src.tile(tile_x, tile_y, tile_z, **kwargs)\n    img = src.tile(0, 0, src.maxzoom)\n    assert isinstance(img, ImageData)\n    assert not img.crs\n    assert img.bounds == (0, 256, 256, 0)\n\n    img = src.tile(0, 0, src.minzoom)\n    assert isinstance(img, ImageData)\n    assert img.bounds[0] == 0\n    assert img.bounds[3] == 0\n\n# With indexes\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.tile(1, 2, 3, tilesize=256, indexes=1)\n    assert img.count == 1\n\n# With expression\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.tile(1, 2, 3, tilesize=256, expression=\"B1/B2\")\n    assert img.count == 1\n</code></pre> <ul> <li>part(): Read an image for a given bounding box (<code>bbox</code>). The origin is the Top-Left of the image.</li> </ul> <pre><code>from rio_tiler.io import ImageReader\nfrom rio_tiler.models import ImageData\n\nwith ImageReader(\"image.jpeg\") as src:\n    # src.part((left, bottom, right, top), **kwargs)\n    img = src.part((0, 256, 256, 0))  # read the top-left 256x256 square of the image\n    assert isinstance(img, ImageData)\n    assert img.assets == [\"myfile.tif\"]\n    assert img.bounds == (0, 256, 256, 0)\n\n# Limit output size\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.part((0, 256, 256, 0), max_size=50)\n\n# With indexes\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.part((0, 256, 256, 0), indexes=1)\n\n# With expression\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.part((0, 256, 256, 0), expression=\"b1/b2\")\n</code></pre> <ul> <li>feature(): Read an image for a geojson feature. In the pixel coordinate system.</li> </ul> <pre><code>from rio_tiler.io import ImageReader\nfrom rio_tiler.models import ImageData\n\nfeat = {\n    \"coordinates\": [\n        [\n            [-100.0, -100.0],\n            [1000.0, 100.0],\n            [500.0, 1000.0],\n            [-50.0, 500.0],\n            [-100.0, -100.0],\n        ]\n    ],\n    \"type\": \"Polygon\",\n}\n\nwith ImageReader(\"image.jpeg\") as src:\n    # src.part(geojson_feature, **kwargs)\n    img = src.feature(feat)\n    assert isinstance(img, ImageData)\n    assert img.assets == [\"image.jpeg\"]\n    assert img.bounds == (-100.0, 1000.0, 1000.0, -100.0)  # bbox of the input feature\n\n# Limit output size\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.feature(feat, max_size=100)\n\n# Read high resolution\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.feature(feat, max_size=None)\n\n# With indexes\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.feature(feat, indexes=1)\n\n# With expression\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.feature(feat, expression=\"b1/b2\")\n</code></pre> <ul> <li>preview(): Read a preview of a raster</li> </ul> <pre><code>from rio_tiler.io import ImageReader\nfrom rio_tiler.models import ImageData\n\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.preview()\n    assert isinstance(img, ImageData)\n\n# With indexes\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.preview(indexes=1)\n\n# With expression\nwith ImageReader(\"image.jpeg\") as src:\n    img = src.preview(expression=\"b1+2;b1*4\")\n</code></pre> <ul> <li>point(): Read the pixel values of a raster for a given <code>x, y</code> coordinates. The origin is the Top-Left of the image.</li> </ul> <pre><code>from rio_tiler.io import ImageReader\nfrom rio_tiler.models import PointData\n\nwith ImageReader(\"image.jpeg\") as src:\n    # src.point(x, y)\n    pt = src.point(0, 0)  # pixel at the origin\n    assert isinstance(pt, PointData)\n\n# With indexes\nwith ImageReader(\"image.jpeg\") as src:\n    pt = src.point(0,0 , indexes=1)\n    print(pt.data)\n&gt;&gt;&gt; [1]\n\n# With expression\nwith ImageReader(\"image.jpeg\") as src:\n    pt = src.point(0, 0, expression=\"b1+2;b1*4\")\n    print(pt.data)\n&gt;&gt;&gt; [3, 4]\n</code></pre> <ul> <li>info(): Return simple metadata about the dataset</li> </ul> <pre><code>from rio_tiler.io import ImageReader\nfrom rio_tiler.models import Info\n\nwith ImageReader(\"image.jpeg\") as src:\n    info = src.info()\n    assert isinstance(info, Info)\n\nprint(info.model_dump(exclude_none=True))\n&gt;&gt;&gt; {\n    \"bounds\": [0, 4000, 4000, 0],\n    \"minzoom\": 0,\n    \"maxzoom\": 3,\n    \"band_metadata\": [[\"b1\", {}]],\n    \"band_descriptions\": [[\"b1\", \"\"]],\n    \"dtype\": \"int8\",\n    \"colorinterp\": [\"palette\"],\n    \"nodata_type\": \"Nodata\",\n    \"colormap\": {\n        \"0\": [0, 0, 0, 0],\n        \"1\": [0, 61, 0, 255],\n        ...\n    },\n    \"driver\": \"GTiff\",\n    \"count\": 1,\n    \"width\": 4000,\n    \"height\": 4000,\n    \"overviews\": [2, 4, 8],\n}\n</code></pre> <ul> <li>statistics(): Return image statistics (Min/Max/Stdev)</li> </ul> <pre><code>from rio_tiler.io import ImageReader\n\nwith ImageReader(\"image.jpeg\") as src:\n    stats = src.statistics()\n    assert isinstance(stats, dict)\n\n# stats will be in form or {\"band\": BandStatistics(), ...}\nprint(stats)\n&gt;&gt;&gt; {\n    'b1': BandStatistics(...),\n    'b2': BandStatistics(...),\n    'b3': BandStatistics(...)\n}\n\nprint(stats[\"b1\"].model_dump())\n&gt;&gt;&gt; {\n    \"min\": 1,\n    \"max\": 7872,\n    \"mean\": 2107.524612053134,\n    \"count\": 1045504,\n    \"sum\": 2203425412,\n    \"std\": 2271.0065537857326,\n    \"median\": 2800,\n    \"majority\": 1,\n    \"minority\": 7072,\n    \"unique\": 15,\n    \"histogram\": [\n        [...],\n        [...]\n    ],\n    \"valid_percent\": 100,\n    \"masked_pixels\": 0,\n    \"valid_pixels\": 1045504,\n    \"percentile_98\": 6896,\n    \"percentile_2\": 1\n}\n</code></pre>"},{"location":"readers/#rio_tilerioxarrayxarrayreader","title":"rio_tiler.io.xarray.XarrayReader","text":"<p>The <code>Reader</code> is designed to work with xarray.DataReader with full geo-reference metadata (CRS) and variables (X,Y)</p> <p>The class is derived from the <code>rio_tiler.io.base.BaseReader</code> class. <pre><code>from rio_tiler.io.xarray import XarrayReader\n\nXarrayReader.__mro__\n&gt;&gt;&gt; (rio_tiler.io.xarray.XarrayReader,\n rio_tiler.io.base.BaseReader,\n rio_tiler.io.base.SpatialMixin,\n object)\n</code></pre></p>"},{"location":"readers/#attributes_3","title":"Attributes","text":"<ul> <li>input (xarray.DataArray): Xarray DataArray</li> <li>tms (morecantile.TileMatrixSet, optional): morecantile TileMatrixSet used for tile reading (defaults to WebMercator)</li> <li>geographic_crs (rasterio.crs.CRS, optional): CRS to use to calculate the geographic bounds (default to WGS84)</li> </ul>"},{"location":"readers/#properties_3","title":"Properties","text":"<ul> <li>bounds: dataset's bounds (in dataset crs)</li> <li>crs: dataset's crs</li> <li>geographic_bounds: dataset's bounds in WGS84</li> <li>minzoom: dataset minzoom (in TMS)</li> <li>maxzoom: dataset maxzoom (in TMS)</li> </ul> <pre><code>import numpy\nimport xarray\nfrom datetime import datetime\nfrom rio_tiler.io.xarray import XarrayReader\n\narr = numpy.random.randn(1, 33, 35)\ndata = xarray.DataArray(\n    arr,\n    dims=(\"time\", \"y\", \"x\"),\n    coords={\n        \"x\": list(range(-170, 180, 10)),\n        \"y\": list(range(-80, 85, 5)),\n        \"time\": [datetime(2022, 1, 1)],\n    },\n)\ndata.attrs.update({\"valid_min\": arr.min(), \"valid_max\": arr.max()})\ndata.rio.write_crs(\"epsg:4326\", inplace=True)\n\nwith XarrayReader(data) as src:\n    print(src.input)\n    print(src.tms.identifier)\n    print(src.minzoom)\n    print(src.maxzoom)\n    print(src.bounds)\n    print(src.crs)\n    print(src.geographic_bounds)\n\n&gt;&gt; &lt;xarray.DataArray (time: 1, y: 33, x: 35)&gt;\nWebMercatorQuad\n0\n0\n(-175.0, -82.5, 175.0, 82.5)\nEPSG:4326\n(-175.0, -82.5, 175.0, 82.5)\n</code></pre>"},{"location":"readers/#methods_3","title":"Methods","text":"<ul> <li>tile(): Read map tile from a raster</li> </ul> <pre><code>from rio_tiler.constants import WEB_MERCATOR_CRS\nfrom rio_tiler.io import XarrayReader\nfrom rio_tiler.models import ImageData\n\nwith XarrayReader(data) as src:\n    # src.tile(tile_x, tile_y, tile_z, tilesize, reproject_method)\n    img = src.tile(1, 2, 3)\n    assert isinstance(img, ImageData)\n    assert img.crs == WEB_MERCATOR_CRS\n</code></pre> <ul> <li>part(): Read a DataArray for a given bounding box (<code>bbox</code>). By default the bbox is considered to be in WGS84.</li> </ul> <pre><code>from rio_tiler.io import XarrayReader\nfrom rio_tiler.models import ImageData\n\nwith XarrayReader(data) as src:\n    # src.part((minx, miny, maxx, maxy), dst_crs, bounds_crs, reproject_method)\n    img = src.part((10, 10, 20, 20))\n    assert isinstance(img, ImageData)\n    assert img.crs == WGS84_CRS\n    assert img.bounds == (10, 10, 20, 20)\n\n# Pass bbox in WGS84 (default) but return data in the input dataset CRS\nwith XarrayReader(data) as src:\n    img = src.part((10, 10, 20, 20), dst_crs=src.dataset.crs)\n    assert img.crs == src.dataset.crs\n</code></pre> <ul> <li>feature(): Read a DataArray for a geojson feature. By default the feature is considered to be in WGS84.</li> </ul> <pre><code>from rio_tiler.constants import WGS84_CRS\nfrom rio_tiler.io import XarrayReader\nfrom rio_tiler.models import ImageData\n\nfeat = {\n    \"type\": \"Feature\",\n    \"properties\": {},\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n            [\n                [-54.45, 73.05],\n                [-55.05, 72.79],\n                [-55.61, 72.46],\n                [-53.83, 72.36],\n                [-54.45, 73.05],\n            ]\n        ],\n    },\n}\n\nwith XarrayReader(data) as src:\n    # src.part(geojson_feature, **kwargs)\n    img = src.feature(feat)\n    assert isinstance(img, ImageData)\n    assert img.crs == WGS84_CRS\n    assert img.bounds == (-55.61, 72.36, -53.83, 73.05)  # bbox of the input feature\n\n# Pass bbox in WGS84 (default) but return data in the input dataset CRS\nwith XarrayReader(data) as src:\n    img = src.feature(feat, dst_crs=src.dataset.crs)\n    assert img.crs == src.dataset.crs\n</code></pre> <ul> <li>point(): Read the pixel values of a DataArray for a given <code>lon, lat</code> coordinates. By default the coordinates are considered to be in WGS84.</li> </ul> <pre><code>from rio_tiler.io import XarrayReader\nfrom rio_tiler.models import PointData\n\nwith XarrayReader(data) as src:\n    # src.point(lon, lat, coord_crs)\n    pt = src.point(-100, 25)\n    assert isinstance(pt, PointData)\n</code></pre> <ul> <li>info(): Return simple metadata about the DataArray</li> </ul> <pre><code>from rio_tiler.io import XarrayReader\nfrom rio_tiler.models import Info\n\nwith XarrayReader(data) as src:\n    info = src.info()\n    assert isinstance(info, Info)\n\nprint(info.json(exclude_none=True))\n&gt;&gt;&gt; {\n    \"bounds\": [-175.0, -82.5, 175.0, 82.5],\n    \"minzoom\": 0,\n    \"maxzoom\": 0,\n    \"band_metadata\": [[\"b1\", {}]],\n    \"band_descriptions\": [[\"b1\", \"2022-01-01T00:00:00.000000000\"]],\n    \"dtype\": \"float64\",\n    \"nodata_type\": \"None\",\n    \"width\": 35,\n    \"attrs\": {\n        \"valid_min\": -3.148671506292848,\n        \"valid_max\": 4.214148915352746\n    },\n    \"count\": 1,\n    \"height\": 33\n}\n</code></pre> <ul> <li>preview():</li> </ul> <p>Important</p> <p>Not Implemented</p> <ul> <li>statistics():</li> </ul> <p>Important</p> <p>Not Implemented</p> <p>```</p>"},{"location":"release-notes/","title":"6.5.0 (2024-05-03)","text":"<ul> <li>Revert #648 and refactor <code>get_vrt_transform</code> method to better handle over-zooming a dataset</li> </ul>"},{"location":"release-notes/#647-2024-04-17","title":"6.4.7 (2024-04-17)","text":"<ul> <li>Better handle dataset with inverted origin</li> <li>make sure datatype is forwarded to the WarpedVRT</li> </ul>"},{"location":"release-notes/#646-2024-04-09","title":"6.4.6 (2024-04-09)","text":"<ul> <li>Ignore STAC statistics object when they contain invalid type (author @emmanuelmathot, cogeotiff/rio-tiler!695)</li> </ul>"},{"location":"release-notes/#645-2024-04-05","title":"6.4.5 (2024-04-05)","text":"<ul> <li>add python 3.12 official support</li> <li>change code formatter to <code>ruff-format</code></li> </ul>"},{"location":"release-notes/#644-2024-04-02","title":"6.4.4 (2024-04-02)","text":"<ul> <li>better handler <code>NaN</code> nodata values for masking (author @cerolinx, cogeotiff/rio-tiler!691)</li> </ul>"},{"location":"release-notes/#643-2024-03-22","title":"6.4.3 (2024-03-22)","text":"<ul> <li>make sure <code>scale</code> and <code>offset</code> are set in <code>Info</code> even when <code>offset=0.</code> or <code>scale=1.0</code> (cogeotiff/rio-tiler!687)</li> </ul>"},{"location":"release-notes/#642-2024-03-22","title":"6.4.2 (2024-03-22)","text":"<ul> <li>better account for coverage in statistics (cogeotiff/rio-tiler!684)</li> </ul>"},{"location":"release-notes/#641-2024-02-19","title":"6.4.1 (2024-02-19)","text":"<ul> <li>add <code>CountMethod</code> mosaic method (author @mccarthyryanc, cogeotiff/rio-tiler!676)</li> </ul>"},{"location":"release-notes/#640-2024-01-24","title":"6.4.0 (2024-01-24)","text":"<ul> <li> <p>deprecate <code>resampling_method</code> in <code>rio_tiler.io.xarray.XarrayReader</code> method and add <code>reproject_method</code> (to match the <code>rio_tiler.io.Reader</code> options)</p> <pre><code># before\nwith XarrayReader(data) as dst:\n    img = dst.tile(0, 0, 1, resampling_method=\"cubic\")\n\n# now\nwith XarrayReader(data) as dst:\n    img_cubic = dst.tile(0, 0, 1, reproject_method=\"cubic\")\n</code></pre> </li> </ul>"},{"location":"release-notes/#631-2024-01-22","title":"6.3.1 (2024-01-22)","text":"<ul> <li>When overriding nodata, do not mix mask and only use the provided nodata value</li> </ul>"},{"location":"release-notes/#630-2024-01-16","title":"6.3.0 (2024-01-16)","text":"<ul> <li> <p>do not use <code>warpedVRT</code> when overwriting the dataset nodata value</p> </li> <li> <p>add <code>align_bounds_with_dataset</code> option in <code>rio_tiler.reader.part</code> to align input bounds with the dataset resolution</p> <p></p> </li> </ul>"},{"location":"release-notes/#6210-2024-01-08","title":"6.2.10 (2024-01-08)","text":"<ul> <li>remove default Endpoint URL in AWS S3 Client for STAC Reader</li> </ul>"},{"location":"release-notes/#629-2023-12-21","title":"6.2.9 (2023-12-21)","text":"<ul> <li>fix AWS endpoint credential for STAC <code>fetch</code> function, using same defaults as GDAL vsis3 configuration</li> </ul>"},{"location":"release-notes/#628-2023-12-11","title":"6.2.8 (2023-12-11)","text":"<ul> <li>apply <code>discrete</code> colormap when the provided colormap does not have 256 values</li> </ul>"},{"location":"release-notes/#627-2023-11-29","title":"6.2.7 (2023-11-29)","text":"<ul> <li>Adjusting dataset latitude for WarpedVRT parameters calculation when EPSG:4326 dataset latitudes overflows EPSG:3857 min/max latitude (cogeotiff/rio-tiler!660)</li> </ul>"},{"location":"release-notes/#626-2023-11-10","title":"6.2.6 (2023-11-10)","text":"<ul> <li>validate <code>shape</code> in <code>ImageData.get_coverage_array</code> to avoid rasterio error when re-projecting the geometry</li> </ul>"},{"location":"release-notes/#625-2023-11-06","title":"6.2.5 (2023-11-06)","text":"<ul> <li>avoid <code>indexes</code> collision in <code>MultiBaseReader</code></li> </ul>"},{"location":"release-notes/#624-2023-10-19","title":"6.2.4 (2023-10-19)","text":"<ul> <li> <p>fix issue with <code>WarpedVRT</code> when doing re-projection (ref: cogeotiff/rio-tiler!648)</p> </li> <li> <p>move benchmark outside pytest suite</p> </li> <li> <p>add GET/HEAD request tests using tilebench (outside pytest suite) (ref: cogeotiff/rio-tiler!649)</p> </li> </ul>"},{"location":"release-notes/#623post1-2023-11-16","title":"6.2.3.post1 (2023-11-16)","text":"<ul> <li>validate <code>shape</code> in <code>ImageData.get_coverage_array</code> to avoid rasterio error when re-projecting the geometry [Backported from 6.2.6]</li> <li>avoid <code>indexes</code> collision in <code>MultiBaseReader</code> [Backported from 6.2.5]</li> </ul> <p>This release was made while we waited on a fix for cogeotiff/rio-tiler#654</p>"},{"location":"release-notes/#623-2023-10-11","title":"6.2.3 (2023-10-11)","text":"<ul> <li>in <code>STACReader</code> use <code>href</code> if <code>get_absolute_href()</code> returns <code>None</code></li> </ul>"},{"location":"release-notes/#622-2023-10-05","title":"6.2.2 (2023-10-05)","text":"<ul> <li>add list of assets in <code>InvalidAssetName</code> message in <code>STACReader</code></li> </ul>"},{"location":"release-notes/#621-2023-09-28","title":"6.2.1 (2023-09-28)","text":"<ul> <li>allow GeoJSON <code>Feature</code> in <code>ImageData.get_coverage_array</code> method</li> </ul>"},{"location":"release-notes/#620-2023-09-27","title":"6.2.0 (2023-09-27)","text":"<ul> <li> <p>allow area-weighted statistics by adding <code>coverage</code> option in <code>rio_tiler.utils.get_array_statistics</code></p> <pre><code># Data Array\n# 1, 2\n# 3, 4\ndata = numpy.ma.array((1, 2, 3, 4)).reshape((1, 2, 2))\n\n# Coverage Array\n# 0.5, 0\n# 1, 0.25\ncoverage = numpy.array((0.5, 0, 1, 0.25)).reshape((2, 2))\n\nstats = utils.get_array_statistics(data, coverage=coverage)\nassert len(stats) == 1\nassert stats[0][\"min\"] == 1\nassert stats[0][\"max\"] == 4\nassert stats[0][\"mean\"] == 1.125  # (1 * 0.5 + 2 * 0.0 + 3 * 1.0 + 4 * 0.25) / 4\nassert stats[0][\"count\"] == 1.75  # (0.5 + 0 + 1 + 0.25) sum of the coverage array\n\nstats = utils.get_array_statistics(data)\nassert len(stats) == 1\nassert stats[0][\"min\"] == 1\nassert stats[0][\"max\"] == 4\nassert stats[0][\"mean\"] == 2.5\nassert stats[0][\"count\"] == 4\n</code></pre> </li> <li> <p>add <code>rio_tiler.utils.get_coverage_array</code> method to create a <code>coverage %</code> array</p> </li> <li> <p>add <code>cmocean</code> colormaps</p> <p></p> </li> <li> <p>allow uppercase in <code>cmap.get</code> method</p> <pre><code>from rio_tiler.colormap import cmap\n\n# Before\ncm = cmap.get(\"greys\")\n\n# Now\ncm = cmap.get(\"Greys\")\n</code></pre> </li> </ul>"},{"location":"release-notes/#610-2023-09-15","title":"6.1.0 (2023-09-15)","text":"<ul> <li>add <code>width</code>, <code>height</code> and <code>count</code> properties in <code>MosaicMethodBase</code></li> <li>make sure we mosaic ImageData/PointData with same number of bands</li> <li>resize <code>ImageData.array</code> to the first asset's width/height in <code>mosaic_reader</code></li> </ul>"},{"location":"release-notes/#603-2023-09-13","title":"6.0.3 (2023-09-13)","text":"<ul> <li>return a 1x1 image when bbox is smaller than a single pixel (author @JackDunnNZ, cogeotiff/rio-tiler!637)</li> </ul>"},{"location":"release-notes/#602-2023-08-21","title":"6.0.2 (2023-08-21)","text":"<ul> <li>Update <code>data_as_image</code> to return masked values (author @JackDunnNZ, cogeotiff/rio-tiler!635)</li> </ul>"},{"location":"release-notes/#601-2023-07-25","title":"6.0.1 (2023-07-25)","text":"<ul> <li>fix <code>key</code> access for <code>Info</code> and <code>BandStatistics</code> models for <code>extra</code> attributes</li> <li>update deprecation notice to <code>7.0</code></li> </ul>"},{"location":"release-notes/#600-2023-07-25","title":"6.0.0 (2023-07-25)","text":"<ul> <li>update <code>morecantile</code> requirement to <code>&gt;=5.0,&lt;6.0</code></li> <li>delete <code>rio_tiler.models.NodataTypes</code> (replaced with Literal within the <code>Info</code> model)</li> </ul>"},{"location":"release-notes/#503-2023-07-18","title":"5.0.3 (2023-07-18)","text":"<ul> <li>Filter useless <code>NotGeoreferencedWarning</code> warnings in  <code>Reader.feature()</code> and <code>ImageData.from_bytes()</code> methods</li> <li>Ensure that dataset is still open when reading tags (author @JackDunnNZ, cogeotiff/rio-tiler!628)</li> </ul>"},{"location":"release-notes/#502-2023-07-11","title":"5.0.2 (2023-07-11)","text":"<ul> <li>fix <code>ImageData.apply_color_formula()</code> method</li> </ul>"},{"location":"release-notes/#501-2023-06-22","title":"5.0.1 (2023-06-22)","text":"<ul> <li>raise <code>InvalidExpression</code> when passing invalid <code>asset</code> or <code>band</code> in an expression</li> </ul>"},{"location":"release-notes/#500-2023-06-01","title":"5.0.0 (2023-06-01)","text":"<ul> <li> <p>Fix potential issue when getting statistics for non-valid data</p> </li> <li> <p>add <code>rio-tiler.mosaic.methods.PixelSelectionMethod</code> enums with all defaults methods</p> </li> <li> <p>Add <code>rio-tiler.utils._validate_shape_input</code> function to check geojson feature inputs</p> </li> <li> <p>Change cutline handling in the <code>rio-tiler.io.rasterio.Reader.feature</code> method. Feature   cutlines are now rasterized into numpy arrays and applied as masks instead of using   the cutline vrt_option. These masks are tracked in the <code>rio-tiler.models.ImageData.cutline_mask</code>   attribute, which are used in <code>rio-tiler.mosaic.methods.base.MosaicMethodBase</code> to stop   mosaic building as soon as all pixels in a feature are populated</p> </li> <li> <p>Fix missing <code>nodata/alpha/mask</code> forwarding for dataset with internal GCPS</p> </li> <li> <p>in <code>rio_tiler.io.XarrayReader</code>, add <code>auto_expand</code> options to avoid returning 1D array (incompatible with rio-tiler) (author @abarciauskas-bgse, cogeotiff/rio-tiler!608)</p> </li> <li> <p>handle internal and user provided <code>nodata</code> values in <code>rio_tiler.io.XarrayReader</code> to create mask</p> </li> <li> <p>add <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, <code>AWS_SESSION_TOKEN</code>, <code>AWS_PROFILE</code> and <code>AWS_REGION</code> environnement overrides for <code>rio_tiler.io.stac.aws_get_object</code> function</p> </li> </ul> <p>breaking changes</p> <ul> <li> <p>remove support for non-binary mask values (e.g non-binary alpha bands, ref: rasterio/rasterio#1721)</p> </li> <li> <p>switch from PER-DATASET to PER-BAND mask (cogeotiff/rio-tiler!580)</p> <pre><code># before\nwith COGReader(\"cog.tif\") as src:\n    img = src.preview(width=128, height=128, max_size=None)\n    assert img.data.shape == (3, 128, 128)\n    assert img.mask.shape == (128, 128)\n\n# now\nwith COGReader(\"cog.tif\") as src:\n    img = src.preview(width=128, height=128, max_size=None)\n    assert isinstance(img.array, numpy.ma.MaskedArray)\n    assert img.array.data.shape == (3, 128, 128)\n    assert img.array.mask.shape == (3, 128, 128))\n</code></pre> </li> <li> <p>use numpy masked array in ImageData and PointData to store the data</p> <pre><code># before\narr = numpy.zeros((1, 256, 256), dtype=\"uint16\")\nimg = ImageData(arr)\nassert isintance(img.data, numpy.ndarray)  # Attribute\n\n# now\narr = numpy.zeros((1, 256, 256), dtype=\"uint16\")\nimg = ImageData(arr)\nassert isintance(img.array, numpy.ma.MaskedArray)  # Attribute\nassert isintance(img.data, numpy.ndarray)  # property\nassert isintance(img.mask, numpy.ndarray)  # property\n</code></pre> </li> <li> <p>remove <code>ImageData.from_array</code> method (because we now support MaskedArray directly)</p> </li> <li> <p><code>rio_tiler.expression.apply_expression</code> input/output type change to <code>numpy.ma.MaskedArray</code></p> </li> <li> <p>rio-tiler <code>mosaic</code> methods return <code>numpy.ma.MaskedArray</code></p> </li> <li> <p>reader's <code>post_process</code> should be a Callable with <code>numpy.ma.MaskedArray</code> input/output</p> </li> <li> <p>add <code>reproject_method</code> option in <code>rio_tiler.reader</code>'s method to select the <code>resampling</code> method used during reprojection</p> <pre><code># before\nwith Reader(\"cog.tif\") as src:\n    im = src.preview(\n        dst_crs=\"epsg:4326\",\n        resampling_method=\"bilinear\",  # use `bilinear` for both resizing and reprojection\n    )\n\n# now\nwith Reader(\"cog.tif\") as src:\n    im = src.preview(\n        dst_crs=\"epsg:4326\",\n        resampling_method=\"cubic\",  # use `cubic` for resizing\n        reproject_method=\"bilinear\",  # use `bilinear` for reprojection\n    )\n</code></pre> </li> <li> <p>refactored the <code>MosaicMethodBase</code> to use python's dataclass</p> </li> <li> <p>changed variable names in <code>MosaicMethodBase</code> (<code>tile</code> -&gt; <code>mosaic</code>)</p> </li> <li> <p><code>rio_tiler.mosaic.methods.defaults.LastBandHigh</code> renamed <code>LastBandHighMethod</code></p> </li> <li> <p><code>rio_tiler.mosaic.methods.defaults.LastBandLow</code> renamed <code>LastBandLowMethod</code></p> </li> <li> <p>move <code>aws_get_object</code> from <code>rio_tiler.utils</code> to <code>rio_tiler.io.stac</code></p> </li> <li> <p>make <code>boto3</code> an optional dependency (<code>python -m pip install rio-tiler[\"s3\"]</code>)</p> </li> <li> <p>update <code>morecantile</code> dependency to <code>&gt;=4.0</code></p> </li> <li> <p>add <code>metadata</code> in ImageData/PointData from rasterio dataset <code>tags</code></p> </li> <li> <p>forward statistics from the raster STAC extension to the ImageData object</p> <pre><code>with STACReader(STAC_RASTER_PATH) as stac:\n    info = stac._get_asset_info(\"green\")\n    assert info[\"dataset_statistics\"] == [(6883, 62785)]\n    assert info[\"metadata\"]\n    assert \"raster:bands\" in info[\"metadata\"]\n\n    img = stac.preview(assets=(\"green\", \"red\"))\n    assert img.dataset_statistics == [(6883, 62785), (6101, 65035)]\n    assert img.metadata[\"green\"]  # extra_fields from the STAC assets (e.g `\"raster:bands\"`)\n    assert img.metadata[\"red\"]\n</code></pre> </li> <li> <p>add Deprecation warning for <code>ImageData.from_array</code>, <code>ImageData.as_masked</code>, <code>PointData.as_masked</code> methods</p> </li> </ul>"},{"location":"release-notes/#4113-2023-06-22","title":"4.1.13 (2023-06-22)","text":"<ul> <li>raise InvalidExpression when passing invalid asset or band in an expression (Backported from 5.0.1)</li> </ul>"},{"location":"release-notes/#4112-2023-06-16","title":"4.1.12 (2023-06-16)","text":"<ul> <li>fix issue with <code>rio_tiler.utils.get_array_statistics</code> when passing data with no <code>valid</code> value</li> </ul>"},{"location":"release-notes/#4111-2023-05-18","title":"4.1.11 (2023-05-18)","text":"<ul> <li>in <code>rio_tiler.io.XarrayReader</code>, add <code>auto_expand</code> options to avoid returning 1D array (incompatible with rio-tiler) (author @abarciauskas-bgse, cogeotiff/rio-tiler!608)</li> </ul>"},{"location":"release-notes/#4110-2023-03-24","title":"4.1.10 (2023-03-24)","text":"<ul> <li>enable <code>boundless</code> geometry for cutline (author @yellowcap, cogeotiff/rio-tiler!586)</li> </ul>"},{"location":"release-notes/#419-2023-02-28","title":"4.1.9 (2023-02-28)","text":"<ul> <li>Automatically expand 2D numpy array to 3D when creating ImageData</li> </ul>"},{"location":"release-notes/#418-2023-02-15","title":"4.1.8 (2023-02-15)","text":"<ul> <li>Fix dtype issue when working with Mosaics Methods. Mask should always been of type <code>Uint8</code>.</li> <li>Fix <code>ImageData.from_array</code> method when working with Masked array</li> </ul>"},{"location":"release-notes/#417-2023-02-07","title":"4.1.7 (2023-02-07)","text":"<ul> <li>add <code>from_array</code> and <code>from_bytes</code> ImageData creation methods</li> <li>add <code>statistics</code> method to ImageData</li> </ul>"},{"location":"release-notes/#416-2023-01-18","title":"4.1.6 (2023-01-18)","text":"<ul> <li>add <code>apply_colormap</code> method to the ImageData class</li> <li>fix potential datatype overflow when calculating the intersection of mask and alpha band when using Colormap</li> </ul>"},{"location":"release-notes/#415-2022-12-20","title":"4.1.5 (2022-12-20)","text":"<ul> <li>Fix inverted col/row check when doing window read of a non WarpedVRT dataset</li> </ul>"},{"location":"release-notes/#414-2022-12-16","title":"4.1.4 (2022-12-16)","text":"<ul> <li>add <code>rio_tiler.mosaic.mosaic_point_reader</code> function to create Point value from multiple observation     <pre><code>def reader(asset: str, *args, **kwargs) -&gt; PointData:\n    with Reader(asset) as src:\n        return src.point(*args, **kwargs)\n\npt: PointData = mosaic_point_reader([\"cog.tif\", \"cog2.tif\"], reader, 0, 0)\n</code></pre></li> </ul>"},{"location":"release-notes/#413-2022-12-15","title":"4.1.3 (2022-12-15)","text":"<ul> <li>fix invalid definition of <code>PointData.mask</code> when mask is not provided. Makes sure it's a one element array.</li> </ul>"},{"location":"release-notes/#412-2022-12-15","title":"4.1.2 (2022-12-15)","text":"<ul> <li>raise <code>InvalidPointDataError</code> error when trying to create PointData from an empty list in <code>PointData.create_from_list</code></li> </ul>"},{"location":"release-notes/#411-2022-12-12","title":"4.1.1 (2022-12-12)","text":"<ul> <li>fix invalid coordinates slicing for <code>XArrayReader.point()</code> method (author @benjaminleighton, cogeotiff/rio-tiler!559)</li> </ul>"},{"location":"release-notes/#410-2022-11-24","title":"4.1.0 (2022-11-24)","text":"<ul> <li>add <code>asset_as_band</code> option in <code>MultiBaseReader</code> tile, part, preview, feature and point methods</li> </ul> <pre><code>with STACReader(STAC_PATH) as stac:\n    img = stac.tile(71, 102, 8, assets=\"green\")\n    assert img.band_names == [\"green_b1\"]\n\nwith STACReader(STAC_PATH) as stac:\n    img = stac.tile(71, 102, 8, assets=\"green\", asset_as_band=True)\n    assert img.band_names == [\"green\"]\n\n# For expression, without `asset_as_band` tag, users have to pass `_b{n}` suffix to indicate the band index\nwith STACReader(STAC_PATH) as stac:\n    img = stac.tile(71, 102, 8, expression=\"green_b1/red_b1\")\n    assert img.band_names == [\"green_b1/red_b1\"]\n\nwith STACReader(STAC_PATH) as stac:\n    img = stac.tile(71, 102, 8, expression=\"green/red\", asset_as_band=True)\n    assert img.band_names == [\"green/red\"]\n</code></pre>"},{"location":"release-notes/#400-2022-11-21","title":"4.0.0 (2022-11-21)","text":"<ul> <li>remove deprecated code</li> <li><code>asset_expression</code> in MultiBaseReader</li> <li><code>GCPCOGReader</code></li> </ul>"},{"location":"release-notes/#400a2-2022-11-15","title":"4.0.0a2 (2022-11-15)","text":"<ul> <li>use of <code>file:header_size</code> extension in <code>STACReader</code> to set <code>GDAL_INGESTED_BYTES_AT_OPEN</code> environment variable</li> </ul> <p>breaking changes</p> <ul> <li>renamed <code>MultiBaseReader._get_asset_url</code> to <code>MultiBaseReader._get_asset_info</code> and change the output to return a dictionary in form of <code>{\"url\": ..., \"env\": ...}</code></li> </ul>"},{"location":"release-notes/#400a1-2022-11-10","title":"4.0.0a1 (2022-11-10)","text":"<ul> <li>assign ColorInterp.alpha to rendered image when we add the mask band</li> <li>add <code>.clip(bbox: BBox)</code> and <code>.resize(height: int, width: int)</code> methods to ImageData object</li> <li>add python 3.11 support</li> <li>replace <code>rio-color</code> by <code>color-operations</code> module</li> </ul>"},{"location":"release-notes/#400a0-2022-10-20","title":"4.0.0a0 (2022-10-20)","text":"<ul> <li>add python 3.10 support</li> <li>add <code>apply_expression</code> method in <code>rio_tiler.models.ImageData</code> class</li> <li>update <code>rio-tiler.reader.read/part</code> to avoid using WarpedVRT when no reprojection or nodata override is needed</li> <li> <p>add <code>rio_tiler.io.rasterio.ImageReader</code> to work either with Non-geo or Geo images in a Non-geo manner (a.k.a: in the pixel coordinates system)     <pre><code>with ImageReader(\"image.jpg\") as src:\n    im = src.part((0, 100, 100, 0))\n\nwith ImageReader(\"image.jpg\") as src:\n    im = src.tile(0, 0, src.maxzoom)\n    print(im.bounds)\n\n&gt;&gt;&gt; BoundingBox(left=0.0, bottom=256.0, right=256.0, top=0.0)\n</code></pre></p> </li> <li> <p>add <code>rio_tiler.io.xarray.XarrayReader</code> to work with <code>xarray.DataArray</code> <pre><code>import xarray\nfrom rio_tiler.io import XarrayReader\n\nwith xarray.open_dataset(\n    \"https://ncsa.osn.xsede.org/Pangeo/pangeo-forge/noaa-coastwatch-geopolar-sst-feedstock/noaa-coastwatch-geopolar-sst.zarr\",\n    engine=\"zarr\",\n    decode_coords=\"all\"\n) as src:\n    ds = src[\"analysed_sst\"][:1]\n    ds.rio.write_crs(\"epsg:4326\", inplace=True)\n\n    with XarrayReader(ds) as dst:\n        img = dst.tile(1, 1, 2)\n</code></pre>     note: <code>xarray</code> and <code>rioxarray</code> optional dependencies are needed for the reader</p> </li> </ul> <p>breaking changes</p> <ul> <li>remove python 3.7 support</li> <li>update rasterio requirement to <code>&gt;=1.3</code> to allow python 3.10 support</li> <li>rename <code>rio_tiler.io.cogeo</code> to <code>rio_tiler.io.rasterio</code></li> <li> <p>rename <code>COGReader</code> to <code>Reader</code>. We added <code>rio_tiler.io.COGReader</code> alias to <code>rio_tiler.io.Reader</code> backwards compatibility     <pre><code># before\nfrom rio_tiler.io import COGReader\nfrom rio_tiler.io.cogeo import COGReader\n\n# now\nfrom rio_tiler.io import Reader\nfrom rio_tiler.io.rasterio import Reader\n</code></pre></p> </li> <li> <p><code>rio_tiler.readers.read()</code>, <code>rio_tiler.readers.part()</code>, <code>rio_tiler.readers.preview()</code> now return a ImageData object</p> </li> <li>remove <code>minzoom</code> and <code>maxzoom</code> attribute in <code>rio_tiler.io.SpatialMixin</code> base class</li> <li>remove <code>minzoom</code> and <code>maxzoom</code> attribute in <code>rio_tiler.io.Reader</code> (now defined as properties)</li> <li> <p>use <code>b</code> prefix for band names in <code>rio_tiler.models.ImageData</code> class (and in rio-tiler's readers)     <pre><code># before\nwith COGReader(\"cog.tif\") as cog:\n    img = cog.read()\n    print(cog.band_names)\n    &gt;&gt;&gt; [\"1\", \"2\", \"3\"]\n\n    print(cog.info().band_metadata)\n    &gt;&gt;&gt; [(\"1\", {}), (\"2\", {}), (\"3\", {})]\n\n    print(cog.info().band_descriptions)\n    &gt;&gt;&gt; [(\"1\", \"\"), (\"2\", \"\"), (\"3\", \"\")]\n\n    print(list(cog.statistics()))\n    &gt;&gt;&gt; [\"1\", \"2\", \"3\"]\n\n# now\nwith Reader(\"cog.tif\") as cog:\n    img = cog.read()\n    print(img.band_names)\n    &gt;&gt;&gt; [\"b1\", \"b2\", \"b3\"]\n\n    print(cog.info().band_metadata)\n    &gt;&gt;&gt; [(\"b1\", {}), (\"b2\", {}), (\"b3\", {})]\n\n    print(cog.info().band_descriptions)\n    &gt;&gt;&gt; [(\"b1\", \"\"), (\"b2\", \"\"), (\"b3\", \"\")]\n\n    print(list(cog.statistics()))\n    &gt;&gt;&gt; [\"b1\", \"b2\", \"b3\"]\n\nwith STACReader(\"stac.json\") as stac:\n    print(stac.tile(701, 102, 8, assets=(\"green\", \"red\")).band_names)\n    &gt;&gt;&gt; [\"green_b1\", \"red_b1\"]\n</code></pre></p> </li> <li> <p>depreciate <code>asset_expression</code> in MultiBaseReader. Use of expression is now possible</p> </li> <li> <p><code>expression</code> for MultiBaseReader must be in form of <code>{asset}_b{index}</code></p> <pre><code># before\nwith STACReader(\"stac.json\") as stac:\n    stac.tile(701, 102, 8, expression=\"green/red\")\n\n# now\nwith STACReader(\"stac.json\") as stac:\n    stac.tile(701, 102, 8, expression=\"green_b1/red_b1\")\n</code></pre> </li> <li> <p><code>rio_tiler.reader.point()</code> (and all Reader's point methods) now return a rio_tiler.models.PointData object</p> <pre><code># before\nwith rasterio.open(\"cog.tif\") as src::\n    v = rio_tiler.reader.point(10.20, -42.0)\n    print(v)\n    &gt;&gt;&gt; [0, 0, 0]\n\nwith COGReader(\"cog.tif\") as cog:\n    print(cog.point(10.20, -42.0))\n    &gt;&gt;&gt; [0, 0, 0]\n\n# now\nwith rasterio.open(\"cog.tif\") as src::\n    v = rio_tiler.reader.point(src, (10.20, -42))\n    print(v)\n    &gt;&gt;&gt; PointData(\n        data=array([3744], dtype=uint16),\n        mask=array([255], dtype=uint8),\n        band_names=['b1'],\n        coordinates=(10.20, -42),\n        crs=CRS.from_epsg(4326),\n        assets=['cog.tif'],\n        metadata={}\n    )\n\nwith Reader(\"cog.tif\") as cog:\n    print(cog.point(10.20, -42.0))\n    &gt;&gt;&gt; PointData(\n        data=array([3744], dtype=uint16),\n        mask=array([255], dtype=uint8),\n        band_names=['b1'],\n        coordinates=(10.20, -42),\n        crs=CRS.from_epsg(4326),\n        assets=['cog.tif'],\n        metadata={}\n    )\n</code></pre> </li> <li> <p>deleted <code>rio_tiler.reader.preview</code> function and updated <code>rio_tiler.reader.read</code> to allow width/height/max_size options</p> </li> <li>reordered keyword options in all <code>rio_tiler.reader</code> function for consistency</li> <li>removed <code>AlphaBandWarning</code> warning when automatically excluding alpha band from data</li> <li>remove <code>nodata</code>, <code>unscale</code>, <code>resampling_method</code>, <code>vrt_options</code> and <code>post_process</code> options to <code>Reader</code> init method and replaced with <code>options</code> <pre><code># before\nwith COGReader(\"cog.tif\", nodata=1, resampling_method=\"bilinear\") as cog:\n    data = cog.preview()\n\n# now\nwith Reader(COGEO, options={\"nodata\": 1, \"resampling_method\": \"bilinear\"}) as cog:\n    data = cog.preview()\n</code></pre></li> </ul>"},{"location":"release-notes/#316-2022-07-22","title":"3.1.6 (2022-07-22)","text":"<ul> <li>Hide <code>NotGeoreferencedWarning</code> warnings in <code>utils.render</code> and <code>utils.resize_array</code></li> <li>update <code>MultiBaseReader</code> and <code>MultiBandReader</code> <code>points</code> method to prepare for numpy changes.</li> </ul>"},{"location":"release-notes/#315-2022-07-06","title":"3.1.5 (2022-07-06)","text":"<ul> <li>Deprecate <code>rio_tiler.io.GCPCOGReader</code> and allow GPCS dataset to be opened by <code>rio_tiler.io.COGReader</code></li> </ul> <pre><code># before\nwith GCPCOGReader(\"my.tif\") as cog:\n    ...\n\n# now, COGReader will find the gcps and create an internal WarpedVRT using the gpcs and crs\nwith COGReader(\"my.tif\") as cog:\n    ...\n</code></pre> <ul> <li>add <code>ImageData.rescale</code> to rescale the array in place</li> <li>add <code>ImageData.apply_color_formula</code> to apply color formula in place</li> </ul>"},{"location":"release-notes/#314-2022-04-14","title":"3.1.4 (2022-04-14)","text":"<ul> <li>Fix cutline creation for MultiPolygon (author @Fernigithub, cogeotiff/rio-tiler!493)</li> </ul>"},{"location":"release-notes/#313-2022-04-08","title":"3.1.3 (2022-04-08)","text":"<ul> <li>Switch to <code>pyproject.toml</code> and <code>flit</code> for packaging (cogeotiff/rio-tiler!490)</li> <li>Catch discrete colormap with negative values (cogeotiff/rio-tiler!492)</li> </ul>"},{"location":"release-notes/#312-2022-03-25","title":"3.1.2 (2022-03-25)","text":"<ul> <li>avoid calculating statistics for non-finite values (cogeotiff/rio-tiler!489)</li> </ul>"},{"location":"release-notes/#311-2022-03-17","title":"3.1.1 (2022-03-17)","text":"<ul> <li>forward <code>band names</code> to ImageData output in <code>mosaic_reader</code> (cogeotiff/rio-tiler!486)</li> </ul>"},{"location":"release-notes/#310-2022-02-21","title":"3.1.0 (2022-02-21)","text":"<ul> <li>add support for setting the S3 endpoint url scheme via the <code>AWS_HTTPS</code> environment variables in <code>aws_get_object</code> function using boto3 (cogeotiff/rio-tiler!476)</li> <li>Add semicolon <code>;</code> support for multi-blocks expression (cogeotiff/rio-tiler!479)</li> <li>add <code>rio_tiler.expression.get_expression_blocks</code> method to split expression (cogeotiff/rio-tiler!479)</li> <li>add <code>merged_statistics</code> method for <code>MultiBaseReader</code> to get statistics using between assets expression (cogeotiff/rio-tiler!478)</li> </ul> <p>future deprecation</p> <ul> <li>using a comma <code>,</code> in an expression to define multiple blocks will be replaced by semicolon <code>;</code></li> </ul> <pre><code># before\nexpression = \"b1+b2,b2\"\n\n# new\nexpression = \"b1+b2;b2\"\n</code></pre> <p>breaking changes</p> <ul> <li>update morecantile requirement to <code>&gt;=3.1,&lt;4.0</code>. WebMercatorQuad TMS is now aligned with GDAL and Mercantile TMS definition.</li> </ul>"},{"location":"release-notes/#303-2022-01-18","title":"3.0.3 (2022-01-18)","text":"<ul> <li>make sure we raise an HTTP exception when using an invalid STAC url (cogeotiff/rio-tiler!475)</li> </ul>"},{"location":"release-notes/#302-2022-01-03","title":"3.0.2 (2022-01-03)","text":"<ul> <li>switch from <code>functools.lru_cache</code> to <code>cachetools.LRUCache</code> to allow unashable options in <code>rio_tiler.io.stac.fetch</code> function (cogeotiff/rio-tiler!471)</li> </ul>"},{"location":"release-notes/#301-2021-12-03","title":"3.0.1 (2021-12-03)","text":"<ul> <li>avoid useless call to <code>transform_bounds</code> if input/output CRS are equals (cogeotiff/rio-tiler!466)</li> <li>make sure <code>geographic_bounds</code> don't return inf or nan values (cogeotiff/rio-tiler!467)</li> </ul>"},{"location":"release-notes/#300-2021-11-29","title":"3.0.0 (2021-11-29)","text":"<ul> <li>no change since <code>3.0.0a6</code></li> </ul>"},{"location":"release-notes/#300a6-2021-11-22","title":"3.0.0a6 (2021-11-22)","text":"<ul> <li>add <code>rio_tiler.utils.resize_array</code> to resize array to a given width/height (cogeotiff/rio-tiler!463)</li> <li>use <code>resize_array</code> in <code>ImageData.create_from_list</code> to avoid trying merging array of different sizes (cogeotiff/rio-tiler!463)</li> </ul> <p>breaking changes</p> <ul> <li>update <code>MultiBaseReader</code> and <code>MultiBandReader</code> to be their own abstract classes instead of being subclass of <code>BaseReader</code>.</li> <li>put <code>reader</code> attribute outside of the <code>__init__</code> method for <code>MultiBaseReader</code> and <code>MultiBandReader</code>.</li> </ul>"},{"location":"release-notes/#300a5-2021-11-18","title":"3.0.0a5 (2021-11-18)","text":"<ul> <li>allow the definition of <code>geographic_crs</code> used in the <code>geographic_bounds</code> property (cogeotiff/rio-tiler!458)</li> <li>use <code>contextlib.ExitStack</code> to better manager opening/closing rasterio dataset (cogeotiff/rio-tiler!459)</li> <li>moves <code>BBox, ColorTuple, Indexes, NoData, NumType</code> type definitions in <code>rio_tiler.types</code> (cogeotiff/rio-tiler!460)</li> <li>better types definition for ColorMap objects (cogeotiff/rio-tiler!460)</li> <li>fix some types issues (cogeotiff/rio-tiler!460)</li> </ul>"},{"location":"release-notes/#300a4-2021-11-10","title":"3.0.0a4 (2021-11-10)","text":"<ul> <li>refactor <code>SpatialMixin.tile_exists</code> to compare the bounds in the dataset's coordinate system to avoid coordinates overflow (a TMS CRS bounds can be smaller than the dataset CRS bounds) (cogeotiff/rio-tiler!455)</li> </ul>"},{"location":"release-notes/#300a3-2021-11-03","title":"3.0.0a3 (2021-11-03)","text":"<ul> <li>Reader's <code>info</code> and <code>statistics</code> methods to default to available <code>bands</code> or <code>assets</code> if not provided (cogeotiff/rio-tiler!451)</li> </ul>"},{"location":"release-notes/#300a2-2021-10-21","title":"3.0.0a2 (2021-10-21)","text":"<ul> <li>Allow <code>rio_tiler.utils.get_array_statistics</code> to return <code>0</code> for unfound category, instead of raising an error (cogeotiff/rio-tiler!443)</li> </ul>"},{"location":"release-notes/#300a1-2021-10-20","title":"3.0.0a1 (2021-10-20)","text":"<p>breaking changes</p> <ul> <li> <p>add <code>input</code> in BaseReader class definition to avoid type mismatch (cogeotiff/rio-tiler!450)</p> <p>Note: <code>input</code> replaces <code>filepath</code> attribute in STACReader and COGReader.</p> </li> </ul> <p>removed</p> <ul> <li> <ul> <li><code>rio_tiler.models.ImageStatistics</code> model</li> </ul> </li> </ul>"},{"location":"release-notes/#300a0-2021-10-19","title":"3.0.0a0 (2021-10-19)","text":"<ul> <li>add <code>crs</code> property in <code>rio_tiler.io.base.SpatialMixin</code> (cogeotiff/rio-tiler!429)</li> <li>add <code>geographic_bounds</code> in <code>rio_tiler.io.base.SpatialMixin</code> to return bounds in WGS84 (cogeotiff/rio-tiler!429)</li> </ul> <pre><code>from rio_tiler.io import COGReader\n\nwith COGReader(\"https://rio-tiler-dev.s3.amazonaws.com/data/fixtures/cog.tif\") as cog:\n    print(cog.bounds)\n    &gt;&gt; (373185.0, 8019284.949381611, 639014.9492102272, 8286015.0)\n\n    print(cog.crs)\n    &gt;&gt; \"EPSG:32621\"\n\n    print(cog.geographic_bounds)\n    &gt;&gt; (-61.28762442711404, 72.22979795551834, -52.301598718454485, 74.66298001264106)\n</code></pre> <ul> <li>Allow errors to be ignored when trying to find <code>zooms</code> for dataset in <code>rio_tiler.io.COGReader</code>. If we're not able to find the zooms in selected TMS, COGReader will defaults to the min/max zooms of the TMS (cogeotiff/rio-tiler!429)</li> </ul> <pre><code>from pyproj import CRS\nfrom morecantile import TileMatrixSet\n\nfrom rio_tiler.io import COGReader\n\n# For a non-earth dataset there is no available transformation from its own CRS and the default WebMercator TMS CRS.\nwith COGReader(\"https://rio-tiler-dev.s3.amazonaws.com/data/fixtures/cog_nonearth.tif\") as cog:\n    &gt;&gt; UserWarning: Cannot determine min/max zoom based on dataset information, will default to TMS min/max zoom.\n\n    print(cog.minzoom)\n    &gt;&gt; 0\n\n    print(cog.maxzoom)\n    &gt;&gt; 24\n\n# if we use a `compatible TMS` then we don't get warnings\neuropa_crs = CRS.from_authority(\"ESRI\", 104915)\neuropa_tms = TileMatrixSet.custom(\n    crs=europa_crs,\n    extent=europa_crs.area_of_use.bounds,\n    matrix_scale=[2, 1],\n)\nwith COGReader(\n    \"https://rio-tiler-dev.s3.amazonaws.com/data/fixtures/cog_nonearth.tif\",\n    tms=europa_tms,\n) as cog:\n    print(cog.minzoom)\n    &gt;&gt; 4\n\n    print(cog.maxzoom)\n    &gt;&gt; 6\n</code></pre> <ul> <li>compare dataset bounds and tile bounds in TMS crs in <code>rio_tiler.io.base.SpatialMixin.tile_exists</code> method to allow dataset and TMS not compatible with WGS84 crs (cogeotiff/rio-tiler!429)</li> <li>use <code>httpx</code> package instead of requests (author @rodrigoalmeida94, cogeotiff/rio-tiler!431)</li> <li>allow half pixel <code>tile_buffer</code> around the tile (e.g 0.5 -&gt; 257x257, 1.5 -&gt; 259x259) (author @bstadlbauer, cogeotiff/rio-tiler!405)</li> <li>add support for intervals colormap (cogeotiff/rio-tiler!439))</li> </ul> <pre><code>from rio_tiler.colormap import apply_cmap, apply_intervals_cmap\n\ndata = numpy.random.randint(0, 255, size=(1, 256, 256))\ncmap = [\n    # ([min, max], [r, g, b, a])\n    ([0, 1], [0, 0, 0, 0]),\n    ([1, 10], [255, 255, 255, 255]),\n    ([10, 100], [255, 0, 0, 255]),\n    ([100, 256], [255, 255, 0, 255]),\n]\n\ndata, mask = apply_intervals_cmap(data, cmap)\n# or\ndata, mask = apply_cmap(data, cmap)\n</code></pre> <p>breaking changes</p> <ul> <li>update morecantile requirement to version &gt;=3.0 (cogeotiff/rio-tiler!418)</li> <li>remove python 3.6 support (cogeotiff/rio-tiler!418)</li> <li>remove <code>max_size</code> defaults for <code>COGReader.part</code> and <code>COGReader.feature</code>, which will now default to full resolution reading.</li> </ul> <pre><code># before\nwith COGReader(\"my.tif\") as cog:\n    img = cog.part(*cog.dataset.bounds, dst_crs=cog.dataset.crs, bounds_crs=cog.dataset.crs)\n    # by default image should be max 1024x1024\n    assert max(img.width, 1024) # by default image should be max 1024x1024\n    assert max(img.height, 1024)\n\n# now (there is no more max_size default)\nwith COGReader(\"my.tif\") as cog:\n    img = cog.part(*cog.dataset.bounds, dst_crs=cog.dataset.crs, bounds_crs=cog.dataset.crs)\n    assert img.width == cog.dataset.width\n    assert img.height == cog.dataset.height\n</code></pre> <ul> <li> <p>add <code>.statistics</code> method in base classes (cogeotiff/rio-tiler!427)</p> </li> <li> <p>remove <code>rio_tiler.io.base.SpatialMixin.spatial_info</code> and <code>rio_tiler.io.base.SpatialMixin.center</code> properties (cogeotiff/rio-tiler!429)</p> </li> <li> <p>Reader's <code>.bounds</code> property should now be in dataset's CRS, not in <code>WGS84</code> (cogeotiff/rio-tiler!429)</p> </li> </ul> <pre><code># before\nwith COGReader(\"my.tif\") as cog:\n    print(cog.bounds)\n    &gt;&gt;&gt; (-61.287001876638215, 15.537756794450583, -61.27877967704677, 15.542486503997608)\n\n# now\nwith COGReader(\"my.tif\") as cog:\n    print(cog.bounds)\n    &gt;&gt;&gt; (683715.3266400001, 1718548.5702, 684593.2680000002, 1719064.90736)\n\n    print(cog.crs)\n    &gt;&gt;&gt; EPSG:32620\n\n    print(cog.geographic_bounds)\n    &gt;&gt;&gt; (-61.287001876638215, 15.537756794450583, -61.27877967704677, 15.542486503997608)\n</code></pre> <ul> <li>Use <code>RIO_TILER_MAX_THREADS</code> environment variable instead of <code>MAX_THREADS</code> (author @rodrigoalmeida94, cogeotiff/rio-tiler!432)</li> <li>remove <code>band_expression</code> in <code>rio_tiler.io.base.MultiBandReader</code> (cogeotiff/rio-tiler!433)</li> <li>change <code>asset_expression</code> input type from <code>str</code> to <code>Dict[str, str]</code> in <code>rio_tiler.io.base.MultiBaseReader</code> (cogeotiff/rio-tiler!434)</li> </ul> <pre><code># before\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        asset_expression=\"b1*2\",  # expression was applied to each asset\n    )\n\n# now\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        asset_expression={\"data1\": \"b1*2\", \"data2\": \"b2*100\"},  # we can now pass per asset expression\n    )\n</code></pre> <ul> <li>add <code>asset_indexes</code> in <code>rio_tiler.io.base.MultiBaseReader</code>, which replaces <code>indexes</code>. (cogeotiff/rio-tiler!434)</li> </ul> <pre><code># before\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        indexes=(1,),  # indexes was applied to each asset\n    )\n\n# now\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        asset_indexes={\"data1\": 1, \"data2\": 2},  # we can now pass per asset indexes\n    )\n</code></pre> <p>removed</p> <ul> <li><code>rio_tiler.io.BaseReader.metadata</code> and <code>rio_tiler.io.BaseReader.stats</code> base class methods (cogeotiff/rio-tiler!425)</li> <li><code>rio_tiler.reader.stats</code> function (cogeotiff/rio-tiler!440)</li> <li><code>rio_tiler.reader.metadata</code> function (cogeotiff/rio-tiler!440)</li> <li><code>rio_tiler.utils._stats</code> function (cogeotiff/rio-tiler!440)</li> </ul>"},{"location":"release-notes/#213-2021-09-14","title":"2.1.3 (2021-09-14)","text":"<ul> <li>Make sure output data is of type <code>Uint8</code> when applying a colormap (cogeotiff/rio-tiler!423)</li> <li>Do not auto-rescale data if there is a colormap (cogeotiff/rio-tiler!423)</li> </ul>"},{"location":"release-notes/#212-2021-08-10","title":"2.1.2 (2021-08-10)","text":"<ul> <li>update type information for mosaics functions (cogeotiff/rio-tiler!409)</li> </ul>"},{"location":"release-notes/#211-2021-07-29","title":"2.1.1 (2021-07-29)","text":"<ul> <li>add support for setting the S3 endpoint url via the <code>AWS_S3_ENDPOINT</code> environment variables in <code>aws_get_object</code> function using boto3 (cogeotiff/rio-tiler!394)</li> <li>make <code>ImageStatistics.valid_percent</code> a value between 0 and 100 (instead of 0 and 1) (author @param-thakker, cogeotiff/rio-tiler!400)</li> <li> <p>add <code>fetch_options</code> to <code>STACReader</code> to allow custom configuration to the fetch client (cogeotiff/rio-tiler!404)</p> <pre><code>with STACReader(\"s3://...\", fetch_options={\"request_pays\": True}):\n    pass\n</code></pre> </li> <li> <p>Fix alpha band values when storing <code>Uint16</code> data in PNG. (cogeotiff/rio-tiler!407)</p> </li> </ul>"},{"location":"release-notes/#210-2021-05-17","title":"2.1.0 (2021-05-17)","text":"<ul> <li>add auto-rescaling in <code>ImageData.render</code> method to avoid error when datatype is not supported by the output driver (cogeotiff/rio-tiler!391)</li> </ul> <pre><code># before - exit with error\nwith open(\"img.png\", \"wb\") as f:\n    f.write(ImageData(numpy.zeros((3, 256, 256), dtype=\"float32\")).render())\n&gt;&gt;&gt; (ERROR) CPLE_NotSupportedError: \"PNG driver doesn't support data type Float32. Only eight bit (Byte) and sixteen bit (UInt16) bands supported\".\n\n# now - print a warning\nwith open(\"img.png\", \"wb\") as f:\n    f.write(ImageData(numpy.zeros((3, 256, 256), dtype=\"float32\")).render())\n&gt;&gt;&gt; (WARNING) InvalidDatatypeWarning: \"Invalid type: `float32` for the `PNG` driver. Data will be rescaled using min/max type bounds\".\n</code></pre> <p>breaking changes</p> <ul> <li>change type of <code>in_range</code> option in <code>ImageData.render</code> to <code>Sequence[Tuple[NumType, NumType]]</code> (cogeotiff/rio-tiler!391)</li> </ul> <pre><code>img = ImageData(numpy.zeros((3, 256, 256), dtype=\"uint16\"))\n\n# before - Tuple[NumType, NumType]\nbuff = img.render(in_range=(0, 1000, 0, 1000, 0, 1000))\n\n# now - Sequence[Tuple[NumType, NumType]]\nbuff = img.render(in_range=((0, 1000), (0, 1000), (0, 1000)))\n</code></pre>"},{"location":"release-notes/#208-2021-04-26","title":"2.0.8 (2021-04-26)","text":"<ul> <li>add warning when dataset doesn't have overviews (cogeotiff/rio-tiler!386)</li> <li>add <code>width</code>, <code>height</code>, <code>count</code> and <code>overviews</code> infos in <code>COGReader.info()</code> (cogeotiff/rio-tiler!387)</li> <li>add <code>driver</code> in <code>COGReader.info()</code> output (cogeotiff/rio-tiler!388)</li> <li>add <code>valid_percent</code> in <code>stats</code> output (cogeotiff/rio-tiler!389)</li> </ul>"},{"location":"release-notes/#207-2021-04-01","title":"2.0.7 (2021-04-01)","text":"<ul> <li>use importlib.resources <code>.files</code> method to resolve the package directory (cogeotiff/rio-tiler!379)</li> </ul>"},{"location":"release-notes/#206-2021-03-25","title":"2.0.6 (2021-03-25)","text":"<ul> <li>add <code>read()</code> method in COGReader (cogeotiff/rio-tiler!366)</li> <li>add <code>tile_buffer</code> option to <code>COGReader.tile()</code> method to add pixels around a tile request (cogeotiff/rio-tiler#365)</li> <li>use <code>importlib.resources.path</code> to find rio-tiler <code>cmap_data</code> directory (cogeotiff/rio-tiler!370)</li> <li>re-use type definitions (cogeotiff/rio-tiler#337)</li> </ul>"},{"location":"release-notes/#205-2021-03-17","title":"2.0.5 (2021-03-17)","text":"<ul> <li>make sure <code>py.typed</code> is included in the package (cogeotiff/rio-tiler!363)</li> <li>add <code>jpg</code> alias in <code>img_profiles</code> (cogeotiff/rio-tiler!364)</li> </ul> <pre><code>from rio_tiler.profiles import img_profiles\n\njpeg = img_profiles.get(\"jpeg\")\njpg = img_profiles.get(\"jpg\")\nassert jpeg == jpg\n</code></pre>"},{"location":"release-notes/#204-2021-03-09","title":"2.0.4 (2021-03-09)","text":"<ul> <li>Added pystac.MediaType.COG in supported types by STAC reader</li> <li>fix bad type definition in <code>rio_tiler.colormap.ColorMaps</code> data (cogeotiff/rio-tiler#359)</li> <li>add <code>rio_tiler.colormap.parse_color</code> function to parse HEX color (cogeotiff/rio-tiler#361)</li> </ul>"},{"location":"release-notes/#203-2021-02-19","title":"2.0.3 (2021-02-19)","text":"<ul> <li>Reduce the number of <code>.read()</code> calls for dataset without nodata value (cogeotiff/rio-tiler!355)</li> <li>replace deprecated <code>numpy.float</code> by <code>numpy.float64</code></li> </ul>"},{"location":"release-notes/#202-2021-02-17","title":"2.0.2 (2021-02-17)","text":"<ul> <li>fix bad mask datatype returned by mosaic methods (cogeotiff/rio-tiler!353)</li> <li>align WarpedVRT with internal blocks when needed. This is to reduce the number of GET requests need for VSI files (cogeotiff/rio-tiler!345)</li> </ul>"},{"location":"release-notes/#201-2021-02-04","title":"2.0.1 (2021-02-04)","text":"<ul> <li>fix arguments names conflicts between mosaic_reader/tasks and STACReader options (cogeotiff/rio-tiler!343)</li> <li>update rio-tiler pypi description.</li> </ul>"},{"location":"release-notes/#200-2021-01-27","title":"2.0.0 (2021-01-27)","text":"<ul> <li>add MultiPolygon support in <code>rio_tiler.utils.create_cutline</code> (cogeotiff/rio-tiler#323)</li> <li>support discrete colormap by default in <code>apply_cmap</code> (cogeotiff/rio-tiler#321)</li> <li>delete deprecated <code>rio_tiler.mercator</code> submodule</li> <li>added default factory in <code>rio_tiler.colormap.ColorMaps</code>.</li> <li>fix missing <code>metadata</code> forwarding in <code>ImageData.post_process</code> method.</li> <li>refactor <code>rio_tiler.io.GCPCOGReader</code> for better inheritance from COGReader.</li> </ul> <p>breaking change</p> <ul> <li>renamed input parameter <code>tile</code> to <code>data</code> in <code>rio_tiler.utils.render</code>.</li> <li>renamed input parameter <code>arr</code> to <code>data</code> in <code>rio_tiler.utils.mapzen_elevation_rgb</code></li> <li>made <code>rio_tiler.io.stac.to_pystac_item</code> private (renamed to <code>_to_pystac_item</code>)</li> <li>renamed <code>rio_tiler.colormap.DEFAULTS_CMAPS</code> to <code>rio_tiler.colormap.DEFAULT_CMAPS_FILES</code></li> <li>made <code>rio_tiler.reader._read</code> public (renamed to rio_tiler.reader.read) (ref: cogeotiff/rio-tiler#332)</li> </ul>"},{"location":"release-notes/#200rc4-2020-12-18","title":"2.0.0rc4 (2020-12-18)","text":"<ul> <li>add <code>NPZ</code> output format (cogeotiff/rio-tiler#308)</li> <li>add pystac for STAC item reader (author @emmanuelmathot, cogeotiff/rio-tiler#212)</li> <li>delete deprecated function: <code>rio_tiler.reader.tile</code>, <code>rio_tiler.utils.tile_exits</code> and <code>rio_tiler.utils.geotiff_options</code></li> <li>deprecated <code>rio_tiler.mercator</code> submodule (cogeotiff/rio-tiler#315)</li> <li>update morecantile version to 2.1, which has better <code>tms.zoom_for_res</code> definition.</li> </ul>"},{"location":"release-notes/#200rc3-2020-11-24","title":"2.0.0rc3 (2020-11-24)","text":"<ul> <li>add <code>feature</code> method to reader classes (cogeotiff/rio-tiler#306)</li> </ul>"},{"location":"release-notes/#200rc2-2020-11-17","title":"2.0.0rc2 (2020-11-17)","text":"<ul> <li>add <code>data</code> validation in <code>rio_tiler.models.ImageData</code> model. Data MUST be a 3 dimensions array in form of (count, height, width).</li> <li><code>mask</code> is now optional for <code>rio_tiler.models.ImageData</code> model, but will be initialized to a default full valid (<code>255</code>) array.</li> </ul> <pre><code>import numpy\nfrom rio_tiler.models import ImageData\n\ndata = numpy.random.rand(3, 10, 10)\n\nimg = ImageData(data)\nassert img.mask.all()\n</code></pre> <ul> <li>add <code>metadata</code> property to <code>rio_tiler.models.ImageData</code> model</li> </ul> <pre><code>img.metadata\n&gt;&gt;&gt; {}\n</code></pre> <p>breaking change</p> <ul> <li><code>rio_tiler.mosaic.reader.mosaic_reader</code> now raises <code>EmptyMosaicError</code> instead of returning an empty <code>ImageData</code></li> </ul>"},{"location":"release-notes/#200rc1post1-2020-11-12","title":"2.0.0rc1.post1 (2020-11-12)","text":"<ul> <li>Remove <code>Uint8</code> data casting before applying <code>color_formula</code> in ImageData.render (cogeotiff/rio-tiler#302)</li> </ul>"},{"location":"release-notes/#200rc1-2020-11-09","title":"2.0.0rc1 (2020-11-09)","text":"<ul> <li>added <code>ImageData</code> output class for all <code>rio_tiler.io</code> classes returning numpy array-like types (<code>tile, mask = method()</code>)</li> </ul> <p><pre><code>from rio_tiler.io import COGReader\nfrom rio_tiler.models import ImageData\n\nwith COGReader(\"/Users/vincentsarago/S-2_20200422_COG.tif\") as cog:\n    r = cog.preview()\n    assert isinstance(r, ImageData)\n\n    data, mask = r\n    assert data.shape == (3, 892, 1024)\n</code></pre> Note: the class keeps the compatibility with previous notation: <code>tile, mask = ImageData</code></p> <ul> <li> <p>add pydantic models for IO outputs (Metadata, Info, ...)</p> </li> <li> <p>change output form for <code>band_metadata</code>, <code>band_descriptions</code> and do not add band description when not found. <pre><code># Before\nwith COGReader(\"/Users/vincentsarago/S-2_20200422_COG.tif\") as cog:\n    i = cog.info()\n    print(i[\"band_metadata\"])\n    print(i[\"band_descriptions\"])\n\n[(1, {}), (2, {}), (2, {})]\n[(1, 'band1'), (2, 'band2'), (2, 'band3')]\n\n# Now\nwith COGReader(\"/Users/vincentsarago/S-2_20200422_COG.tif\") as cog:\n    i = cog.info()\n    print(i.band_metadata)\n    print(i.band_descriptions)\n\n[('1', {}), ('2', {}), ('3', {})]\n[('1', ''), ('2', ''), ('3', '')]\n</code></pre></p> </li> <li> <p>change output form for <code>stats</code> <pre><code># Before\nwith COGReader(\"/Users/vincentsarago/S-2_20200422_COG.tif\") as cog:\n    print(cog.stats())\n{\n    1: {...},\n    2: {...},\n    3: {...}\n}\n\n# Now\nwith COGReader(\"/Users/vincentsarago/S-2_20200422_COG.tif\") as cog:\n    print(cog.stats())\n{\n    \"1\": {...},\n    \"2\": {...},\n    \"3\": {...}\n}\n</code></pre></p> </li> <li> <p>updated <code>rio_tiler.utils._stats</code> function to replace <code>pc</code> by <code>percentiles</code></p> </li> </ul> <pre><code>with COGReader(\"/Users/vincentsarago/S-2_20200422_COG.tif\") as cog:\n    print(cog.stats()[\"1\"].json())\n{\"percentiles\": [19.0, 168.0], \"min\": 0.0, \"max\": 255.0, ...}\n</code></pre> <ul> <li>make <code>rio_tiler.colormap.ColorMap</code> object immutable. Registering a new colormap will new returns a now instance of ColorMap(cogeotiff/rio-tiler#289).</li> <li>changed the <code>rio_tiler.colormap.ColorMap.register()</code> method to take a dictionary as input (instead of name + dict).</li> </ul> <pre><code>from rio_tiler.colormap import cmap # default cmap\n\n# previous\ncmap.register(\"acmap\", {0: [0, 0, 0, 0], ...})\n\n# Now\ncmap = cmap.register({\"acmap\": {0: [0, 0, 0, 0], ...}})\n</code></pre> <ul> <li> <p>added the possibility to automatically register colormaps stored as <code>.npy</code> file in a directory, if <code>COLORMAP_DIRECTORY</code> environment variable is set with the name of the directory.</p> </li> <li> <p>Update to morecantile 2.0.0</p> </li> </ul>"},{"location":"release-notes/#200b19-2020-10-26","title":"2.0.0b19 (2020-10-26)","text":"<ul> <li>surface <code>allowed_exceptions</code> options in <code>rio_tiler.mosaic.reader.mosaic_reader</code> (cogeotiff/rio-tiler#293)</li> <li>add SpatialInfoMixin base class to reduce code duplication (co-author with @geospatial-jeff, cogeotiff/rio-tiler!295)</li> <li>add <code>AsyncBaseReader</code> to support async readers (author @geospatial-jeff, cogeotiff/rio-tiler!265)</li> </ul>"},{"location":"release-notes/#200b18-2020-10-22","title":"2.0.0b18 (2020-10-22)","text":"<ul> <li>surface dataset.nodata in COGReader.nodata property (cogeotiff/rio-tiler!292)</li> <li>fix non-threaded tasks scheduler/filter (cogeotiff/rio-tiler!291)</li> </ul>"},{"location":"release-notes/#200b17-2020-10-13","title":"2.0.0b17 (2020-10-13)","text":"<ul> <li>switch to morecantile for TMS definition (ref: cogeotiff/rio-tiler#283)</li> <li>add tms options in Readers (breaking change if you create custom Reader from BaseReader)</li> <li>add tile_bounds vs bounds check in tile methods for MultiBands and MultiBase classes</li> <li>add tile_exists method in BaseReader (take tms in account)</li> <li>adapt zooms calculation in COGReader</li> <li>add <code>LastBandHigh</code> and <code>LastBandLow</code> pixel selection (ref: cogeotiff/rio-tiler!270)</li> </ul> <p>Deprecated function</p> <ul> <li>rio_tiler.reader.tile</li> <li>rio_tiler.utils.geotiff_options</li> <li>rio_tiler.utils.tile_exists</li> <li>rio_tiler.io.multi_*</li> </ul>"},{"location":"release-notes/#200b16-2020-10-07","title":"2.0.0b16 (2020-10-07)","text":"<ul> <li>remove <code>pkg_resources</code> (pypa/setuptools#510)</li> <li>refactor default colormap lookup to use pathlib instead of pkg_resources.</li> </ul> <p>Note: We changed the versioning scheme to <code>{major}.{minor}.{path}{pre}{prenum}</code></p>"},{"location":"release-notes/#20b15-2020-10-05","title":"2.0b15 (2020-10-05)","text":"<ul> <li>Fix missing Exception catching when running task outside threads (ref: developmentseed/titiler#130).</li> <li>add rio-tiler logger (cogeotiff/rio-tiler#277).</li> </ul>"},{"location":"release-notes/#20b14post2-2020-10-02","title":"2.0b14.post2 (2020-10-02)","text":"<ul> <li>Fix bug in <code>MultiBandReader</code> (ref: cogeotiff/rio-tiler#275) and add tests.</li> </ul>"},{"location":"release-notes/#20b14post1-2020-10-02","title":"2.0b14.post1 (2020-10-02)","text":"<ul> <li>add <code>MultiBandReader</code> and <code>GCPCOGReader</code> in <code>rio_tiler.io</code> init.</li> </ul>"},{"location":"release-notes/#20b14-2020-10-02","title":"2.0b14 (2020-10-02)","text":"<ul> <li>Added back the Conctext Manager methods in <code>rio_tiler.io.base.BaseReader</code> but not as <code>@abc.abstractmethod</code> (ref: github.com/cogeotiff/rio-tiler/pull/273#discussion_r498937943)</li> <li>Move <code>rio_tiler_pds.reader.MultiBandReader</code> and <code>rio_tiler_pds.reader.GCPCOGReader</code> to rio-tiler (cogeotiff/rio-tiler!273)</li> </ul>"},{"location":"release-notes/#20b13-2020-10-01","title":"2.0b13 (2020-10-01)","text":"<ul> <li>remove ContextManager requirement for <code>rio_tiler.io.base.BaseReader</code> and <code>rio_tiler.io.base.MultiBaseReader</code> base classes.</li> <li>move ContextManager properties definition to <code>__attrs_post_init__</code> method in <code>rio_tiler.io.STACReader</code> and <code>rio_tiler.io.COGReader</code> (ref: cogeotiff/rio-tiler-pds#21)</li> </ul>"},{"location":"release-notes/#20b12-2020-09-28","title":"2.0b12 (2020-09-28)","text":"<ul> <li>Make sure Alpha band isn't considered as an internal mask by <code>utils.has_mask_band</code></li> </ul>"},{"location":"release-notes/#20b11-2020-09-24","title":"2.0b11 (2020-09-24)","text":"<ul> <li>reduce verbosity in <code>rio_tiler.tasks.filter_tasks</code> exception logging (#266).</li> </ul>"},{"location":"release-notes/#20b10-2020-09-15","title":"2.0b10 (2020-09-15)","text":"<ul> <li>add <code>post_process</code> callback to <code>rio_tiler.render._read</code> and <code>rio_tiler.render.point</code> to apply specific operation ouput arrays.</li> </ul>"},{"location":"release-notes/#20b9-2020-09-09","title":"2.0b9 (2020-09-09)","text":"<ul> <li>restore Mkdocs search bar (#255)</li> <li>Allow class (not just instance) to be passed to pixel_selection (#250)</li> <li>Add Binder link/badge to README (#254)</li> <li>Add mkdocs-jupyter to show notebooks in website (#253)</li> <li>Remove deprecated functions (#247)</li> <li>Export modules from top-level package (#246)</li> <li>Allow overwriting colormap with force=True (#249)</li> <li>Pin black version (#251)</li> <li>Add contributing.md (#242)</li> <li>Add mkdocs config (#240)</li> <li>Add <code>NPY</code> support in <code>rio_tiler.utils.render</code> to save tile in numpy binary format (#256)</li> <li>Remove bare <code>Exception</code> and add more detailed errors (#248)</li> </ul>"},{"location":"release-notes/#20b8-2020-08-24","title":"2.0b8 (2020-08-24)","text":"<ul> <li>raise specific <code>PointOutsideBounds</code> in rio_tiler.reader.point (#236)</li> </ul>"},{"location":"release-notes/#20b7-2020-08-21","title":"2.0b7 (2020-08-21)","text":"<ul> <li>allow setting default kwargs in COGReader init (#227)</li> <li>allow <code>vrt_options</code> in COGReader.point</li> <li>add <code>rio_tiler.io.base.MultiBaseReader</code> class (#225)</li> <li>refactor <code>rio_tiler.io.stac.STACReader</code> to use MultiBaseReader (#225)</li> <li>add <code>rio_tiler.task</code> submodule to share tools for handling rio-tiler's future tasks.</li> <li>fix regex parsing for rio-tiler expression</li> <li>add warnings when assets/indexes is passed with expression option (#233)</li> </ul> <p>Breaking Changes: - replace dataclass wiht attr to support more flexible class definition (see #225)</p>"},{"location":"release-notes/#20b6-2020-08-04","title":"2.0b6 (2020-08-04)","text":"<ul> <li>add <code>utils.create_cutline</code> helper (#218)</li> <li>remove any mutable default argument</li> </ul> <p>depreciation - <code>warp_vrt_option</code> is replaced by <code>vrt_options</code> in rio_tiler.reader.part (#221)</p>"},{"location":"release-notes/#20b5-2020-07-31","title":"2.0b5 (2020-07-31)","text":"<ul> <li>add more verbosity to mosaic error (#214)</li> </ul> <p>Breaking Changes: - <code>rio_tiler.mosaic.reader.mosaic_reader</code> return <code>((tile, mask), assets_used)</code> - <code>COGReader.info</code> is now a method instead of a property to align with other reader (#211)</p>"},{"location":"release-notes/#20b4-2020-07-30","title":"2.0b4 (2020-07-30)","text":"<ul> <li>add rio_tiler.io.base.BaseReader abstract class for COGReader and STACReader to inherit from</li> <li>STACReader raises <code>InvalidAssetName</code> for invalid asset name or <code>MissingAssets</code> when no assets is passed (#208)</li> <li>update rio_tiler.mosaic.reader.mosaic_reader to not use threadPool if threads &lt;= 1 (#207)</li> </ul> <p>Breaking Changes: - Reader.spatial_info is a property (#203) - assets is a keyword argument in STACReader stats/info/metadata</p>"},{"location":"release-notes/#20b3-2020-07-27","title":"2.0b3 (2020-07-27)","text":"<ul> <li>add <code>rio_tiler.mosaic</code> submodule (ref: cogeotiff/rio-tiler-mosaic#16)</li> </ul>"},{"location":"release-notes/#20b2-2020-07-23","title":"2.0b2 (2020-07-23)","text":"<ul> <li>add boto3 in the dependency (#201)</li> </ul>"},{"location":"release-notes/#20b1-2020-07-22","title":"2.0b1 (2020-07-22)","text":"<ul> <li>switch to ContextManager for COG and STAC (rio_cogeo.io.COGReader, rio_cogeo.io.STACReader).</li> <li>COGReader.part and STACReader.part return data in BBOX CRS by default.</li> <li>STACReader now accept URL (https, s3).</li> <li>add more method for STAC (prewiew/point/part/info/stats).</li> <li>add expression for COG/STAC preview/point/part.</li> <li>add <code>masked</code> option in <code>rio_tiler.reader.point</code> to control weither or not it should return None or a value.</li> <li>remove mission specific tilers (#195).</li> <li>remove <code>rio_tiler.reader.multi_*</code> functions (replaced by rio_tiler.io.cogeo.multi_*).</li> <li>remove <code>rio_tiler.utils.expression</code> (replaced by expression options in tilers).</li> </ul>"},{"location":"release-notes/#20a11-2020-05-29","title":"2.0a11 (2020-05-29)","text":"<ul> <li>refactor <code>rio_tiler.utils.tile_exists</code> to allow raster bounds latitude == -90,90</li> </ul>"},{"location":"release-notes/#20a10-2020-05-29","title":"2.0a10 (2020-05-29)","text":"<ul> <li>Change default resampling to nearest for <code>_read</code> (#187)</li> <li>add <code>rio_tiler.reader.stats</code> (return only array statistics)</li> <li>remove default <code>dst_crs</code> in <code>rio_tiler.reader.part</code> to to fallback to dataset CRS.</li> </ul>"},{"location":"release-notes/#20a9-2020-05-27","title":"2.0a9 (2020-05-27)","text":"<ul> <li>Refactor colormap and add method to register custom colormap</li> </ul>"},{"location":"release-notes/#20a8-2020-05-25","title":"2.0a8 (2020-05-25)","text":"<ul> <li>add <code>preview</code> method to <code>rio_tiler.io.cogeo</code></li> </ul>"},{"location":"release-notes/#20a7-2020-05-17","title":"2.0a7 (2020-05-17)","text":"<ul> <li>allow reading high resolution part of a raster (by making height, width args optional)</li> <li>add <code>max_size</code> option in <code>rio_tiler.reader.part</code> to set a maximum output size when height and width are not set</li> <li>add point and area function in rio_tiler.io.cogeo</li> <li>fix width-height height-widht bug in <code>rio_tiler.reader.part</code></li> </ul> <p>depreciation - deprecated <code>out_window</code> option in favor of <code>window</code> in rio_tiler.reader._read</p>"},{"location":"release-notes/#20a6-2020-05-06","title":"2.0a6 (2020-05-06)","text":"<ul> <li>fix unwanted breacking change with <code>img_profiles.get</code> not allowing default values</li> </ul>"},{"location":"release-notes/#20a5-2020-05-06","title":"2.0a5 (2020-05-06)","text":"<ul> <li>make <code>rio_tiler.io.landsat8.tile</code> return Uint16 data and not float32 (#173)</li> <li><code>rio_tiler.profiles.img_profiles</code> item access return <code>copy</code> of the items (#177)</li> <li>better colormap docs (#176, author @kylebarron)</li> </ul>"},{"location":"release-notes/#20a4-2020-04-08","title":"2.0a4 (2020-04-08)","text":"<ul> <li>add <code>rio_tiler.io.cogeo.info</code> to retrieve simple file metadata (no image statistics)</li> <li>add band metadata tag info in <code>rio_tiler.render.metadata</code> output</li> <li>add <code>rio_tiler.io.stac</code> STAC compliant rio_tiler.colormap.apply_discrete_cmap</li> </ul>"},{"location":"release-notes/#20a3-2020-03-25","title":"2.0a3 (2020-03-25)","text":"<ul> <li>only use <code>transform_bounds</code> when needed in rio_tiler.reader.part</li> </ul> <p>Breaking Changes: - switch back to gdal/rasterio calculate_default_transform (#164). Thanks to Terracotta core developper @dionhaefner. - refactor <code>rio_tiler.utils.get_vrt_transform</code> to get width and height input.</p>"},{"location":"release-notes/#20a2-2020-03-20","title":"2.0a2 (2020-03-20)","text":"<ul> <li>Fall back to gdal/rasterio calculate_default_transform for dateline separation crossing dataset (ref #164)</li> </ul>"},{"location":"release-notes/#20a1-2020-03-19","title":"2.0a1 (2020-03-19)","text":"<ul> <li>added <code>reader.preview</code>, <code>reader.point</code> methods</li> <li>added multi_* functions to rio_tiler.reader to support multiple assets addresses</li> <li>added <code>rio_tiler.utils.has_mask_band</code> function</li> <li>added <code>rio_tiler.utils.get_overview_level</code> to calculate the overview level needed for partial reading.</li> <li>added type hints</li> <li>added scale, offsets, colormap, datatype and colorinterp in reader.metadata output (#158)</li> <li>new <code>rio_tiler.colormap</code> submodule</li> <li>added <code>unscale</code> options to rio_tiler.reader._read function apply internal scale/offset (#157)</li> </ul> <p>Breaking Changes: - removed python 2 support - new package architecture (.io submodule) - introduced new rio_tiler.reader functions (part, preview, metadata...) - renamed rio_tiler.main to rio_tiler.io.cogeo - bucket and prefixes are defined in rio_tiler.io.dataset.<code>{dataset}_parse</code> function from   AWS supported Public Dataset - renamed <code>minimum_tile_cover</code> to <code>minimum_overlap</code> - renamed <code>tile_edge_padding</code> to <code>padding</code> - padding is set to 0 by default. - use terracotta calculate_default_transform (see github.com/cogeotiff/rio-tiler/issues/56#issuecomment-442484999) - colormaps are now have an alpha value - <code>rio_tiler.utils.get_colormap</code> replaced by <code>rio_tiler.colormap.get_colormap</code> - new <code>rio_tiler.colormap.get_colormap</code> supports only GDAL like colormap - replaced <code>rio_tiler.utils.array_to_image</code> by <code>rio_tiler.utils.render</code> - replaced <code>rio_tiler.utils.apply_cmap</code> by <code>rio_tiler.colormap.apply_cmap</code> - replaced <code>rio_tiler.utils._apply_discrete_colormap</code> by <code>rio_tiler.colormap.apply_discrete_cmap</code> - removed <code>histogram_bins</code> and <code>histogram_range</code> in options in metadata reader.   Should now be passed in <code>hist_options</code> (e.g: hist_options={bins=10, range=(0, 10)}) - remove alpha band value from output data array in tile/preview/metadata #127</p>"},{"location":"release-notes/#140-2020-02-19","title":"1.4.0 (2020-02-19)","text":"<ul> <li>Add Sentinel2-L2A support (#137)</li> <li>Update Sentinel-2 sceneid schema (S2A_tile_20170323_07SNC_0 -&gt; S2A_L1C_20170323_07SNC_0)</li> </ul>"},{"location":"release-notes/#131-2019-11-06","title":"1.3.1 (2019-11-06)","text":"<ul> <li>Add <code>warp_vrt_option</code> option for <code>utils.raster_get_stats</code> and <code>utils.tile_read</code> to allow more custom VRT Warping. (ref: github.com/OSGeo/gdal/issues/1989#issue-518526399)</li> <li>Add <code>rio_tiler.utils.non_alpha_indexes</code> to find non-alpha band indexes (ref #127)</li> </ul>"},{"location":"release-notes/#130-2019-10-07","title":"1.3.0 (2019-10-07)","text":"<ul> <li>Allow <code>DatasetReader</code>, <code>DatasetWriter</code>, <code>WarpedVRT</code> input for <code>utils.raster_get_stats</code> and <code>utils.tile_read</code></li> <li>add <code>minimum_tile_cover</code> option to filter dataset not covering a certain amount of the tile.</li> <li>add Sentinel-1 submodule</li> </ul> <p>Breaking Changes: - need rasterio&gt;=1.1</p>"},{"location":"release-notes/#1211-2019-09-18","title":"1.2.11 (2019-09-18)","text":"<ul> <li>reduce memory footprint of expression tiler</li> <li>fix wrong calculation for overview size in <code>raster_get_stats</code> (#116)</li> <li>Add Landsat 8 QA Band (#117).</li> </ul>"},{"location":"release-notes/#1210-2019-07-18","title":"1.2.10 (2019-07-18)","text":"<ul> <li>add more colormap options (from matplotlib) and switch from txt files to numpy binaries (#115)</li> </ul>"},{"location":"release-notes/#129-2019-07-11","title":"1.2.9 (2019-07-11)","text":"<ul> <li>fix issue #113, adds depreciation warning for <code>bounds_crs</code> in favor of <code>dst_crs</code> in <code>rio_tiler.utils.get_vrt_transform</code></li> </ul>"},{"location":"release-notes/#128-2019-07-08","title":"1.2.8 (2019-07-08)","text":"<ul> <li>Add kwargs options in landsat8.tile, sentinel2.tile and cbers.tile functions to allow <code>resampling_method</code> and <code>tile_edge_padding</code> options forwarding to utils._tile_read.</li> <li>Add Input (bounds_crs) and Output (dst_crs) option to <code>utils._tile_read</code> function (#108)</li> </ul>"},{"location":"release-notes/#127-2019-05-14","title":"1.2.7 (2019-05-14)","text":"<ul> <li>Revert changes introduced in #106 (see #105)</li> <li>Refactor tests</li> </ul>"},{"location":"release-notes/#126-2019-05-10-deleted","title":"1.2.6 (2019-05-10) - DELETED","text":"<ul> <li>Use same resampling method for mask and for data (#105)</li> </ul>"},{"location":"release-notes/#125-2019-05-08","title":"1.2.5 (2019-05-08)","text":"<ul> <li>add tile_edge_padding option to be passed to rio_tiler.utils._tile_read to reduce sharp edges that occur due to resampling (#104)</li> </ul>"},{"location":"release-notes/#124-2019-04-16","title":"1.2.4 (2019-04-16)","text":"<ul> <li>add histogram_range options to be passed to rio_tiler.{module}.metadata function (#102)</li> </ul>"},{"location":"release-notes/#123-2019-04-04","title":"1.2.3 (2019-04-04)","text":"<ul> <li>add histogram_bins options to be passed to rio_tiler.{module}.metadata function (#98)</li> </ul> <p>Bug fixes: - return index number with band descriptions (#99)</p>"},{"location":"release-notes/#122-2019-04-03","title":"1.2.2 (2019-04-03)","text":"<ul> <li>add mercator min/max zoom info in metadata output from rio_tiler.utils.raster_get_stats (#96)</li> <li>add band description (band name) in metadata output from rio_tiler.utils.raster_get_stats (#96)</li> </ul>"},{"location":"release-notes/#121-2019-03-26","title":"1.2.1 (2019-03-26)","text":"<ul> <li>Replace rio-pansharpen dependency with a fork of the brovey function directly into <code>rio_tiler.utils</code> (rio-pansharpen is unmaintened and not compatible with rasterio&gt;=1) (#94).</li> </ul>"},{"location":"release-notes/#120-2019-03-26","title":"1.2.0 (2019-03-26)","text":"<ul> <li><code>rio_tiler.utils.array_to_image</code>'s color_map arg can be a dictionary of discrete values (#91)</li> </ul> <p>Breaking Changes: - <code>expr</code> argument is now a required option in <code>rio_tiler.utils.expression</code>. (#88)</p>"},{"location":"release-notes/#114-2019-03-11","title":"1.1.4 (2019-03-11)","text":"<ul> <li>Add 'rplumbo' colormap (#90 by @DanSchoppe)</li> </ul>"},{"location":"release-notes/#113-2019-03-06","title":"1.1.3 (2019-03-06)","text":"<p>Bug fixes: - Fix casting to integer for MAX_THREADS environment variable.</p>"},{"location":"release-notes/#111-2019-02-21","title":"1.1.1 (2019-02-21)","text":"<ul> <li>Minor typo correction and harmonization of the use of src/src_dst/src_path in <code>rio_tiler.utils</code></li> </ul> <p>Bug fixes: - Fix nodata handling in <code>utils.raster_get_stats</code></p>"},{"location":"release-notes/#110-2019-02-15","title":"1.1.0 (2019-02-15)","text":"<ul> <li>Allow options forwarding to <code>tile_read</code> from <code>main.tile</code> function (#86)</li> <li>Add <code>resampling_method</code> options in <code>rio_tiler.utils.tile_read</code> to allow user set resampling. Default is now bilinear (#85)</li> </ul> <p>Bug fixes: - Fix nodata option forwarding to tile_read when source is a path (#83)</p> <p>Refactoring: - Refactor <code>rio_tiler.utils.tile_read</code> to reduce code complexity (#84)</p> <p>Breaking Changes: - <code>indexes</code> options is now set to None in <code>rio_tiler.utils.tile_read</code>. Default will now be the dataset indexes.</p>"},{"location":"release-notes/#101-2019-02-14","title":"1.0.1 (2019-02-14)","text":"<ul> <li>Fix mask datatype bug in <code>rio_tiler.utils.array_to_image</code>(#79)</li> <li>Fix nodata handling and better test for the nodata/mask main module (#81)</li> </ul>"},{"location":"release-notes/#100-2019-02-11","title":"1.0.0 (2019-02-11)","text":"<ul> <li>add missing Landsat panchromatic band (08) min/max fetch in <code>rio_tiler.landsat8.metadata</code> (#58)</li> <li>add pre-commit for commit validation (#64)</li> <li>code formatting using Black (the uncompromising Python code formatter) (#64)</li> <li>update documentation (Sentinel-2 cost) (#68)</li> <li>add <code>utils.raster_get_stats</code> and <code>utils._get_stats</code> to replace <code>min_max*</code> function and to return more statistics (#66)</li> <li>add overview level selection to statistical functions to reduce the data download (#59)</li> <li>add pure GDAL <code>array_to_image</code> function to replace PIL tools (#29)</li> <li>add GDAL format output from <code>utils.get_colormap</code> to be used in <code>array_to_image</code> (#29)</li> <li>add GDAL compatible Image creation profile (#29)</li> <li>add max threads number settings via \"MAX_THREADS\" environment variable (#71)</li> </ul> <p>Breaking Changes: - update <code>metadata</code> structure returned by <code>landsat8.metadata</code>, <code>sentinel2.metadata</code>, <code>cbers.metadata</code> - force sentinel, landsat and cbers band names to be string and add validation (#65) - moved landsat utility functions from <code>rio_tiler.utils</code> to <code>rio_tiler.landsat8</code>   - rio_tiler.utils.landsat_get_mtl -&gt; rio_tiler.landsat8._landsat_get_mtl   - rio_tiler.utils.landsat_parse_scene_id -&gt; rio_tiler.landsat8._landsat_parse_scene_id   - rio_tiler.utils.landsat_get_stats -&gt; rio_tiler.landsat8._landsat_stats - moved cbers utility functions from <code>rio_tiler.utils</code> to <code>rio_tiler.cbers</code>   - rio_tiler.utils.cbers_parse_scene_id -&gt; rio_tiler.cbers._cbers_parse_scene_id - moved sentinel-2 utility functions from <code>rio_tiler.utils</code> to <code>rio_tiler.sentinel2</code>   - rio_tiler.utils.sentinel_parse_scene_id -&gt; rio_tiler.sentinel2._sentinel_parse_scene_id - removed deprecated PIL support as well as base64 encoding function in rio_tiler.utils   - rio_tiler.utils.img_to_buffer   - rio_tiler.utils.array_to_img   - rio_tiler.utils.b64_encode_img - removed deprecated min_max* functions (landsat_min_max_worker and band_min_max_worker)</p>"},{"location":"release-notes/#10rc2-2018-08-22","title":"1.0rc2 (2018-08-22)","text":"<ul> <li>add test case for pix4d nodata+alpha band data</li> </ul>"},{"location":"release-notes/#10rc1-2018-07-16","title":"1.0rc1 (2018-07-16)","text":"<ul> <li>rasterio 1.0.0</li> </ul>"},{"location":"release-notes/#10b3-2018-07-02","title":"1.0b3 (2018-07-02)","text":"<ul> <li>add schwarzwald color palette</li> </ul>"},{"location":"release-notes/#10b2-2018-06-26","title":"1.0b2 (2018-06-26)","text":"<ul> <li>fix nodata (#48)</li> </ul>"},{"location":"release-notes/#10b1-2018-06-23","title":"1.0b1 (2018-06-23)","text":"<ul> <li>adapt to rasterio 1.0b4</li> <li>fix mask (internal/external) fetching \ud83d\ude4f</li> <li>fix boundless read with new rasterio 1.0b2</li> <li>fix custom nodata handling</li> <li>fix performances issue</li> </ul> <p>Breaking Changes: - removed alpha band options to select a custom alpha band number</p>"},{"location":"release-notes/#10a8-2018-06-20","title":"1.0a8 (2018-06-20)","text":"<ul> <li>Fix rasterio version to 1.0b1 (#46 and #44)</li> </ul>"},{"location":"release-notes/#10a7-2018-05-14","title":"1.0a7 (2018-05-14)","text":"<ul> <li>Support for additional CBERS instruments (fredliporace)</li> </ul>"},{"location":"release-notes/#10a6-2018-03-29","title":"1.0a6 (2018-03-29)","text":"<ul> <li>Fixes sentinel-2 band 8A regex bug in <code>rio_tiler.utils.expression</code></li> </ul>"},{"location":"release-notes/#10a5-2018-03-26","title":"1.0a5 (2018-03-26)","text":"<ul> <li>adds DatasetReader input option for utils.tile_read (do not close the dataset on each read)</li> </ul> <p>Breaking Changes: - <code>utils.tile_band_worker</code> renamed to <code>utils.tile_read</code> - <code>main.tile</code> rgb option renamed indexes - <code>sentinel2.tile</code>, <code>landsat8.tile</code>,  <code>cbers.tile</code> rgb option renamed bands - <code>main.tile</code> default nodata mask is handled by rasterio</p>"},{"location":"release-notes/#10a4-2018-03-07","title":"1.0a4 (2018-03-07)","text":"<ul> <li>adds utils.b64_encode_img function to encode an image object into a base64 string</li> <li>add tiles profiles (jpeg, png, webp) based on github.com/mapnik/mapnik/wiki/Image-IO#default-output-details</li> </ul> <p>Breaking Changes: - Refactor <code>rio_tiler.utils.array_to_img</code> to return PIL image object</p>"},{"location":"release-notes/#10a3-2018-02-05","title":"1.0a3 (2018-02-05)","text":"<ul> <li>only using <code>read_masks</code> for mask creation when it's needed.</li> </ul>"},{"location":"release-notes/#10a2-2018-02-05","title":"1.0a2 (2018-02-05)","text":"<ul> <li>add \"expression\" utility function</li> <li>better nodata/mask/alpha band definition and support</li> </ul> <p>Breaking Changes: - tile functions now return an associated mask (Landsat, Sentinel, CBERS, main) - remove nodata support in utils.image_to_array function - add mask support in utils.image_to_array function - utils.tile_band_worker will always return a (Band, Width, Height) array (e.g 1x256x256 or 3x256x256)</p>"},{"location":"release-notes/#10a1-2018-01-04","title":"1.0a1 (2018-01-04)","text":"<ul> <li>remove aws.py sub-module (replaced by main.py)</li> <li>no default bands value for main.py tiles.</li> </ul>"},{"location":"release-notes/#10a0-2018-01-03","title":"1.0a.0 (2018-01-03)","text":"<ul> <li>add colormap option in <code>utils.array_to_img</code></li> <li>add TIR (brightness temps) support</li> <li>add CBERS support</li> <li>add global file support</li> <li>add elevation encoding for mapzen</li> <li>removing internal caching</li> <li>update to rasterio 1.0a12</li> </ul> <p>Breaking Changes: - remove data value rescaling in <code>landsat8.tile</code> and <code>sentinel2.tile</code> - fix wrong lat/grid_square value in <code>utils.sentinel_parse_scene_id</code> - rename <code>utils.sentinel_min_max_worker</code> to <code>utils.band_min_max_worker</code></p>"},{"location":"release-notes/#003-2017-11-14","title":"0.0.3 (2017-11-14)","text":"<ul> <li>Fix Sentinel-2 bad AWS url</li> </ul>"},{"location":"release-notes/#002-2017-10-17","title":"0.0.2 (2017-10-17)","text":"<ul> <li>Fix python \u2154 compatibilities in rio_tiler.utils.landsat_get_mtl</li> </ul>"},{"location":"release-notes/#001-2017-10-05","title":"0.0.1 (2017-10-05)","text":"<ul> <li>Initial release. Requires Rasterio &gt;= 1.0a10.</li> </ul>"},{"location":"supported_format/","title":"Supported file formats","text":"<p><code>rio-tiler</code> can work with all raster formats supported by GDAL. That's being said, <code>rio-tiler</code> works better with data format that supports partial reading, like Cloud Optimized GeoTIFF.</p> <p>On interesting feature of Cloud Optimized GeoTIFF is the internal overviews which enable fast preview of the data. For example, when using the <code>Reader.preview</code> method, rio-tiler will only fetch the internal overviews instead of the whole data, to be able to construct the output array. Doing this reduce the amount of data transfer and thus increase the process speed.</p>"},{"location":"supported_format/#vrt","title":"VRT","text":"<p>GDAL's Virtual format is also supported by rio-tiler.</p> <p>Warnings</p> <p>Map Tile reading from VRT might not be efficient if overviews are not present, because GDAL will try to open a lot of files.</p> <p></p>"},{"location":"supported_format/#xarray","title":"Xarray","text":"<p>New in version 4.0</p> <p>When <code>xarray</code> and <code>rioxarray</code> are installed in your environment, you can use <code>rio_tiler.io.XarrayReader</code> to read <code>xarray.DataArray</code> using the usual rio-tiler's Readers methods (<code>part()</code>, <code>tile()</code>, <code>feature()</code>).</p> <p>Warnings</p> <ul> <li>Datarray must be fully geo-referenced with a CRS and X,Y variables (longitude, latitude)</li> <li>Performance is largely dependant on the chunking of the array</li> </ul>"},{"location":"advanced/custom_readers/","title":"Base classes and custom readers","text":"<p><code>rio-tiler</code> provides multiple abstract base classes from which it derives its main readers: <code>Reader</code> and <code>STACReader</code>. You can also use these classes to build custom readers.</p>"},{"location":"advanced/custom_readers/#abstract-base-classes","title":"Abstract Base Classes","text":""},{"location":"advanced/custom_readers/#basereader","title":"BaseReader","text":"<p>Main <code>rio_tiler.io</code> Abstract Base Class.</p>"},{"location":"advanced/custom_readers/#minimal-arguments","title":"Minimal Arguments","text":"<ul> <li>input: Input</li> <li> <p>tms: The TileMatrixSet define which default projection and map grid the reader uses. Defaults to WebMercatorQuad.</p> </li> <li> <p>bounds: Dataset's bounding box. Not in the <code>__init__</code> method.</p> </li> <li>crs: dataset's crs. Not in the <code>__init__</code> method.</li> <li>geographic_crs: CRS to use as geographic coordinate system. Defaults to WGS84. Not in the <code>__init__</code> method.</li> </ul> <p>Important</p> <p>BaseClass Arguments outside the <code>__init__</code> method and without default value HAVE TO be set in the <code>__attrs_post_init__</code> step.</p>"},{"location":"advanced/custom_readers/#methods","title":"Methods","text":"<ul> <li>tile_exists: Check if a given tile (for the input TMS) intersect the dataset bounds.</li> </ul>"},{"location":"advanced/custom_readers/#properties","title":"Properties","text":"<ul> <li>geographic_bounds: dataset's bounds in WGS84 crs (calculated from <code>self.bounds</code> and <code>self.crs</code>).</li> </ul>"},{"location":"advanced/custom_readers/#abstract-methods","title":"Abstract Methods","text":"<p>Abstract methods, are method that HAVE TO be implemented in the child class.</p> <ul> <li>info: returns dataset info (<code>rio_tiler.models.Info</code>)</li> <li>statistics: returns dataset band statistics (<code>Dict[str, rio_tiler.models.BandStatistics]</code>)</li> <li>tile: reads data for a specific XYZ slippy map indexes (<code>rio_tiler.models.ImageData</code>)</li> <li>part: reads specific part of a dataset (<code>rio_tiler.models.ImageData</code>)</li> <li>preview: creates an overview of a dataset (<code>rio_tiler.models.ImageData</code>)</li> <li>point: reads pixel value for a specific point (<code>List</code>)</li> <li>feature: reads data for a geojson feature (<code>rio_tiler.models.ImageData</code>)</li> </ul> <p>Example: <code>Reader</code></p>"},{"location":"advanced/custom_readers/#multibasereader","title":"MultiBaseReader","text":"<p>The goal of the <code>MultiBaseReader</code> is to enable joining results from multiple files (e.g STAC).</p> <p>The <code>MultiBaseReader</code> has the same attributes/properties/methods as the <code>BaseReader</code>.</p> <p>Example: <code>STACReader</code></p> <pre><code>import os\nimport pathlib\nfrom typing import Dict, Type\n\nimport attr\nfrom morecantile import TileMatrixSet\nfrom rio_tiler.io.base import MultiBaseReader\nfrom rio_tiler.io import Reader, BaseReader\nfrom rio_tiler.constants import WEB_MERCATOR_TMS\nfrom rio_tiler.models import Info\n\n@attr.s\nclass AssetFileReader(MultiBaseReader):\n\n    input: str = attr.ib()\n    prefix: str = attr.ib() # we add a custom attribute\n\n    # because we add another attribute (prefix) we need to\n    # re-specify the other attribute for the class\n    reader: Type[BaseReader] = attr.ib(default=Reader)\n    reader_options: Dict = attr.ib(factory=dict)\n    tms: TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)\n\n    # we place min/max zoom in __init__\n    minzoom: int = attr.ib(default=None)\n    maxzoom: int = attr.ib(default=None)\n\n    def __attrs_post_init__(self):\n        \"\"\"Parse Sceneid and get grid bounds.\"\"\"\n        self.assets = sorted(\n            [p.stem.split(\"_\")[1] for p in pathlib.Path(self.input).glob(f\"*{self.prefix}*.tif\")]\n        )\n        with self.reader(self._get_asset_url(self.assets[0])) as cog:\n            self.bounds = cog.bounds\n            self.crs = cog.crs\n\n            if self.minzoom is None:\n                self.minzoom = cog.minzoom\n\n            if self.maxzoom is None:\n                self.maxzoom = cog.maxzoom\n\n    def _get_asset_url(self, band: str) -&gt; str:\n        \"\"\"Validate band's name and return band's url.\"\"\"\n        return os.path.join(self.input, f\"{self.prefix}{band}.tif\")\n\n# we have a directoty with \"scene_b1.tif\", \"scene_b2.tif\"\nwith AssetFileReader(input=\"my_dir/\", prefix=\"scene_\") as cr:\n    print(cr.assets)\n    &gt;&gt;&gt; ['band1', 'band2']\n\n    info = cr.info(assets=(\"band1\", \"band2\"))\n    # MultiBaseReader returns a Dict\n    assert isinstance(info, dict)\n    print(list(info))\n    &gt;&gt;&gt; ['band1', 'band2']\n\n    assert isinstance(info[\"band1\"], Info)\n    print(info[\"band1\"].model_dump_json(exclude_none=True))\n    &gt;&gt;&gt; {\n        'bounds': [-11.979244865430259, 24.296321392464325, -10.874546803397614, 25.304623891542263],\n        'minzoom': 7,\n        'maxzoom': 9,\n        'band_metadata': [('b1', {})],\n        'band_descriptions': [('b1', '')],\n        'dtype': 'uint16',\n        'nodata_type': 'Nodata',\n        'colorinterp': ['gray']\n    }\n    img = cr.tile(238, 218, 9, assets=(\"band1\", \"band2\"))\n\n    print(img.assets)\n    &gt;&gt;&gt; ['my_dir/scene_band1.tif', 'my_dir/scene_band2.tif']\n\n    # Each assets have 1 bands, so when combining each img we get a (2, 256, 256) array.\n    print(img.data.shape)\n    &gt;&gt;&gt; (2, 256, 256)\n</code></pre>"},{"location":"advanced/custom_readers/#multibandsreader","title":"MultiBandsReader","text":"<p>Almost as the previous <code>MultiBaseReader</code>, the <code>MultiBandsReader</code> children will merge results extracted from different file but taking each file as individual bands.</p> <p>The <code>MultiBaseReader</code> has the same attributes/properties/methods as the <code>BaseReader</code>.</p> <p>Example</p> <pre><code>import os\nimport pathlib\nfrom typing import Dict, Type\n\nimport attr\nfrom morecantile import TileMatrixSet\nfrom rio_tiler.io.base import MultiBandReader\nfrom rio_tiler.io import COGReader, BaseReader\nfrom rio_tiler.constants import WEB_MERCATOR_TMS\n\n@attr.s\nclass BandFileReader(MultiBandReader):\n\n    input: str = attr.ib()\n    prefix: str = attr.ib() # we add a custom attribute\n\n    # because we add another attribute (prefix) we need to\n    # re-specify the other attribute for the class\n    reader: Type[BaseReader] = attr.ib(default=COGReader)\n    reader_options: Dict = attr.ib(factory=dict)\n    tms: TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)\n\n    # we place min/max zoom in __init__\n    minzoom: int = attr.ib(default=None)\n    maxzoom: int = attr.ib(default=None)\n\n    def __attrs_post_init__(self):\n        \"\"\"Parse Sceneid and get grid bounds.\"\"\"\n        self.bands = sorted(\n            [p.stem.split(\"_\")[1] for p in pathlib.Path(self.input).glob(f\"*{self.prefix}*.tif\")]\n        )\n        with self.reader(self._get_band_url(self.bands[0])) as cog:\n            self.bounds = cog.bounds\n            self.crs = cog.crs\n\n            if self.minzoom is None:\n                self.minzoom = cog.minzoom\n\n            if self.maxzoom is None:\n                self.maxzoom = cog.maxzoom\n\n    def _get_band_url(self, band: str) -&gt; str:\n        \"\"\"Validate band's name and return band's url.\"\"\"\n        return os.path.join(self.input, f\"{self.prefix}{band}.tif\")\n\n\n# we have a directoty with \"scene_b1.tif\", \"scene_b2.tif\"\nwith BandFileReader(input=\"my_dir/\", prefix=\"scene_\") as cr:\n    print(cr.bands)\n    &gt;&gt;&gt; ['band1', 'band2']\n\n    print(cr.info(bands=(\"band1\", \"band2\")).model_dump_json(exclude_none=True))\n    &gt;&gt;&gt; {\n        'bounds': [-11.979244865430259, 24.296321392464325, -10.874546803397614, 25.304623891542263],\n        'minzoom': 7,\n        'maxzoom': 9,\n        'band_metadata': [('band1', {}), ('band2', {})],\n        'band_descriptions': [('band1', ''), ('band2', '')],\n        'dtype': 'uint16',\n        'nodata_type': 'Nodata',\n        'colorinterp': ['gray', 'gray']\n    }\n\n    img = cr.tile(238, 218, 9, bands=(\"band1\", \"band2\"))\n\n    print(img.assets)\n    &gt;&gt;&gt; ['my_dir/scene_band1.tif', 'my_dir/scene_band2.tif']\n\n    print(img.data.shape)\n    &gt;&gt;&gt; (2, 256, 256)\n</code></pre> <p>Note: <code>rio-tiler-pds</code> readers are built using the <code>MultiBandReader</code> base class.</p>"},{"location":"advanced/custom_readers/#custom-reader-subclass","title":"Custom Reader subclass","text":"<p>The example  was created as a response to developmentseed/titiler?235. In short, the user needed a way to keep metadata information from an asset within a STAC item.</p> <p>Sadly when we are using the STAC Reader we only keep the metadata about the item but not the assets metadata (because we built the STAC Reader with the idea that user might first want to merge assets together).</p> <p>But rio-tiler has been designed to be easily customizable.</p> <pre><code>import attr\nfrom rasterio.io import DatasetReader\nfrom rio_tiler.io.stac import fetch, _to_pystac_item\nfrom rio_tiler.io import Reader\nimport pystac\n\n@attr.s\nclass CustomSTACReader(Reader):\n    \"\"\"Custom Reader support.\"\"\"\n\n    # This will keep the STAC item info within the instance\n    item: pystac.Item = attr.ib(default=None, init=False)\n\n    def __attrs_post_init__(self):\n        \"\"\"Define _kwargs, open dataset and get info.\"\"\"\n        # get STAC item URL and asset name\n        asset = self.input.split(\":\")[-1]\n        stac_url = self.input.replace(f\":{asset}\", \"\")\n\n        # Fetch the STAC item\n        self.item = pystac.Item.from_dict(fetch(stac_url), stac_url)\n\n        # Get asset url from the STAC Item\n        self.input = self.item.assets[asset].get_absolute_href()\n        super().__attrs_post_init__()\n\nwith CustomSTACReader(\"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/S5_11055_6057_20070622.json:pan\") as cog:\n    print(type(cog.dataset))\n    print(cog.input)\n    print(cog.nodata)\n    print(cog.bounds)\n\n&gt;&gt;&gt; rasterio.io.DatasetReader\n&gt;&gt;&gt; \"https://canada-spot-ortho.s3.amazonaws.com/canada_spot_orthoimages/canada_spot5_orthoimages/S5_2007/S5_11055_6057_20070622/s5_11055_6057_20070622_p10_1_lcc00_cog.tif\"\n&gt;&gt;&gt; 0\n&gt;&gt;&gt; (-869900.0, 1370200.0, -786360.0, 1453180.0)\n</code></pre> <p>In this <code>CustomSTACReader</code>, we are using a custom path <code>schema</code> in form of <code>{item-url}:{asset-name}</code>. When creating an instance of <code>CustomSTACReader</code>, we will do the following:</p> <ol> <li>Parse the input path to get the STAC url and asset name</li> <li>Fetch and parse the STAC item</li> <li>Construct a new <code>input</code> using the asset full url.</li> <li>Fall back to the regular <code>Reader</code> initialization (using <code>super().__attrs_post_init__()</code>)</li> </ol>"},{"location":"advanced/custom_readers/#simple-reader","title":"Simple Reader","text":"<pre><code>from typing import Any, Dict\n\nimport attr\nimport rasterio\nfrom rasterio.io import DatasetReader\nfrom rio_tiler.io import BaseReader\nfrom rio_tiler.models import BandStatistics, Info, ImageData\nfrom morecantile import TileMatrixSet\n\nfrom rio_tiler.constants import BBox, WEB_MERCATOR_TMS\n\n@attr.s\nclass SimpleReader(BaseReader):\n\n    input: DatasetReader = attr.ib()\n\n    # We force tms to be outside the class __init__\n    tms: TileMatrixSet = attr.ib(init=False, default=WEB_MERCATOR_TMS)\n\n    # We overwrite the abstract base class attribute definition and set default\n    minzoom: int = attr.ib(init=False, default=WEB_MERCATOR_TMS.minzoom)\n    maxzoom: int = attr.ib(init=False, default=WEB_MERCATOR_TMS.maxzoom)\n\n    def __attrs_post_init__(self):\n        # Set bounds and crs variable\n        self.bounds = self.input.bounds\n        self.crs = self.input.crs\n\n    # implement all mandatory methods\n    def info(self) -&gt; Info:\n        raise NotImplemented\n\n    def statistics(self, **kwargs: Any) -&gt; Dict[str, BandStatistics]:\n        raise NotImplemented\n\n    def part(self, bbox: BBox, **kwargs: Any) -&gt; ImageData:\n        raise NotImplemented\n\n    def preview(self, **kwargs: Any) -&gt; ImageData:\n        raise NotImplemented\n\n    def point(self, lon: float, lat: float, **kwargs: Any) -&gt; List:\n        raise NotImplemented\n\n    def feature(self, shape: Dict, **kwargs: Any) -&gt; ImageData:\n        raise NotImplemented\n\n    def tile(self, tile_x: int, tile_y: int, tile_z: int, **kwargs: Any) -&gt; ImageData:\n        if not self.tile_exists(tile_x, tile_y, tile_z):\n            raise TileOutsideBounds(\n                f\"Tile {tile_z}/{tile_x}/{tile_y} is outside bounds\"\n            )\n\n        tile_bounds = self.tms.xy_bounds(Tile(x=tile_x, y=tile_y, z=tile_z))\n\n        data, mask = reader.part(\n            self.input,\n            tile_bounds,\n            width=256,\n            height=256,\n            bounds_crs=tms.rasterio_crs,\n            dst_crs=tms.rasterio_crs,\n            **kwargs,\n        )\n        return ImageData(\n            data, mask, bounds=tile_bounds, crs=tms.rasterio_crs\n        )\n\nwith rasterio.open(\"file.tif\") as src:\n    with SimpleReader(src) as cog:\n        img = cog.tile(1, 1, 1)\n</code></pre>"},{"location":"advanced/dynamic_tiler/","title":"Create a Dynamic Tiler","text":"<p><code>rio-tiler</code> aims to be a lightweight plugin for <code>rasterio</code> to read slippy map tiles from a raster sources.</p> <p>Given that <code>rio-tiler</code> allows for simple, efficient reading of tiles, you can then leverage <code>rio-tiler</code> to create a dynamic tile server to display raster tiles on a web map.</p> <p>There are couple tile servers built on top of rio-tiler:</p> <ul> <li><code>titiler</code></li> <li><code>rio-viz</code></li> </ul>"},{"location":"advanced/dynamic_tiler/#example-application","title":"Example Application","text":"<p>To build a simple dynamic tiling application, we can use FastAPI. Note that <code>titiler</code> uses <code>FastAPI</code> internally, so you might consider using <code>titiler</code> instead of making your own API.</p>"},{"location":"advanced/dynamic_tiler/#requirements","title":"Requirements","text":"<ul> <li><code>rio-tiler ~= 4.0</code></li> <li><code>fastapi</code></li> <li><code>uvicorn</code></li> </ul> <p>Install with</p> <pre><code>pip install fastapi uvicorn rio-tiler\n</code></pre>"},{"location":"advanced/dynamic_tiler/#apppy","title":"<code>app.py</code>","text":"<pre><code>\"\"\"rio-tiler tile server.\"\"\"\n\nimport os\n\nfrom fastapi import FastAPI, Query\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nfrom rio_tiler.profiles import img_profiles\nfrom rio_tiler.io import Reader\n\n\napp = FastAPI(\n    title=\"rio-tiler\",\n    description=\"A lightweight Cloud Optimized GeoTIFF tile server\",\n)\n\n\n@app.get(\n    r\"/{z}/{x}/{y}.png\",\n    responses={\n        200: {\n            \"content\": {\"image/png\": {}}, \"description\": \"Return an image.\",\n        }\n    },\n    response_class=Response,\n    description=\"Read COG and return a tile\",\n)\ndef tile(\n    z: int,\n    x: int,\n    y: int,\n    url: str = Query(..., description=\"Cloud Optimized GeoTIFF URL.\"),\n):\n    \"\"\"Handle tile requests.\"\"\"\n    with Reader(url) as cog:\n        img = cog.tile(x, y, z)\n    content = img.render(img_format=\"PNG\", **img_profiles.get(\"png\"))\n    return Response(content, media_type=\"image/png\")\n\n\n@app.get(\"/tilejson.json\", responses={200: {\"description\": \"Return a tilejson\"}})\ndef tilejson(\n    request: Request,\n    url: str = Query(..., description=\"Cloud Optimized GeoTIFF URL.\"),\n):\n    \"\"\"Return TileJSON document for a COG.\"\"\"\n    tile_url = str(request.url_for(\"tile\", z=\"{z}\", x=\"{x}\", y=\"{y}\"))\n    tile_url = f\"{tile_url}?url={url}\"\n\n    with Reader(url) as cog:\n        return {\n            \"bounds\": cog.geographic_bounds,\n            \"minzoom\": cog.minzoom,\n            \"maxzoom\": cog.maxzoom,\n            \"name\": os.path.basename(url),\n            \"tiles\": [tile_url],\n        }\n</code></pre>"},{"location":"advanced/dynamic_tiler/#launch-example","title":"Launch Example","text":"<p>Use <code>uvicorn</code> to launch the application. Note that <code>app:app</code> tells <code>uvicorn</code> to call the <code>app</code> function within <code>app.py</code>, so you must be in the same directory as <code>app.py</code>.</p> <pre><code>uvicorn app:app --reload\n</code></pre>"},{"location":"advanced/feature/","title":"Read Polygon-shaped regions","text":"<p>Starting with <code>rio-tiler</code> v2, a <code>.feature()</code> method exists on <code>rio-tiler</code>'s readers (e.g <code>Reader</code>) which enables data reading for GeoJSON defined (polygon or multipolygon) shapes.</p> <pre><code>from rio_tiler.io import Reader\nfrom rio_tiler.models import ImageData\n\nwith Reader(\"my-tif.tif\") as cog:\n    # Read data for a given geojson polygon\n    img: ImageData = cog.feature(geojson_feature, max_size=1024)  # we limit the max_size to 1024\n</code></pre> <p>Under the hood, the <code>.feature</code> method uses rasterio's <code>rasterize</code> function and the <code>.part()</code> method. The below process is roughly what <code>.feature</code> does for you.</p> <pre><code>from rasterio.features import rasterize, bounds as featureBounds\n\nfrom rio_tiler.io import Reader\n\n# Use Reader to open and read the dataset\nwith Reader(\"my_tif.tif\") as cog:\n\n    # Get BBOX of the polygon\n    bbox = featureBounds(feat)\n\n    # Read part of the data overlapping with the geometry bbox\n    # assuming that the geometry coordinates are in web mercator\n    img = cog.part(bbox, bounds_crs=f\"EPSG:3857\", max_size=1024)\n\n    # Rasterize geometry using the same geotransform parameters\n    cutline = rasterize(\n        [feat],\n        out_shape=(img.height, img.width),\n        transform=img.transform,\n        ...\n    )\n\n    # Apply geometry mask to imagery\n    img.array.mask = numpy.where(~cutline, img.array.mask, True)\n</code></pre> <p>Another interesting way to cut features is to use the GDALWarpVRT's <code>cutline</code> option with the .part(), .preview(), or .tile() methods:</p> <pre><code>from rio_tiler.utils import create_cutline\n\nbbox = featureBounds(feat)\n\n# Use Reader to open and read the dataset\nwith Reader(\"my_tif.tif\") as cog:\n    # Create WTT Cutline\n    cutline = create_cutline(cog.dataset, feat, geometry_crs=\"epsg:4326\")\n\n    # Get a part of the geotiff but use the cutline to mask the data\n    bbox = featureBounds(feat)\n    img = cog.part(bbox, vrt_options={'cutline': cutline})\n\n    # Get a preview of the whole geotiff but use the cutline to mask the data\n    img = cog.preview(vrt_options={'cutline': cutline})\n\n    # Read a mercator tile and use the cutline to mask the data\n    img = cog.tile(1, 1, 1, vrt_options={'cutline': cutline})\n</code></pre>"},{"location":"advanced/statistics/","title":"Statistics","text":""},{"location":"advanced/statistics/#form-readers","title":"Form <code>Readers</code>","text":"<p><code>rio-tiler</code>'s Readers provide simple <code>.statistics</code> method to retrieve dataset global statistics</p> <pre><code>with Reader(\"my.tif\") as src:\n    stats = src.statistics()\n\n# Statistics result is in form of Dict[str, rio_tiler.models.BandStatistics]\nprint(stats.keys())\n&gt;&gt;&gt; [\"b1\", \"b2\", \"b3\"]\n\n# rio_tiler.models.BandStatistics is a pydantic model\nprint(stats[\"1\"].model_dump().keys())\n[\n    \"min\",\n    \"max\",\n    \"mean\",\n    \"count\",\n    \"sum\",\n    \"std\",\n    \"median\",\n    \"majority\",\n    \"minority\",\n    \"unique\",\n    \"histogram\",\n    \"valid_percent\",\n    \"masked_pixels\",\n    \"valid_pixels\",\n    # Percentile entries depend on user inputs\n    \"percentile_2\",\n    \"percentile_98\",\n]\n</code></pre>"},{"location":"advanced/statistics/#imagedata","title":"ImageData","text":"<p>You can get statistics from <code>ImageData</code> objects which are returned by all rio-tiler reader methods (e.g. <code>.tile()</code>, <code>.preview()</code>, <code>.part()</code>, ...)</p> <pre><code>with Reader(\"cog.tif\") as src:\n    image = src.preview()\n    stats = image.statistics()\n</code></pre>"},{"location":"advanced/statistics/#area-weighted-statistics","title":"Area Weighted Statistics","text":"<p>When getting statistics from a <code>feature</code>, you may want to calculate values from the pixels which intersect with the geometry but also take the pixel intersection percentage into account. Starting with rio-tiler <code>6.2.0</code>, we've added a <code>coverage</code> option to the <code>statistics</code> utility which enable the user to pass an array representing the coverage percentage such as:</p> <pre><code>import numpy as np\nfrom rio_tiler.utils import get_array_statistics\n\n# Data Array\n# 1, 2\n# 3, 4\ndata = np.ma.array((1, 2, 3, 4)).reshape((1, 2, 2))\n\n# Coverage Array\n# 0.5, 0\n# 1, 0.25\ncoverage = np.array((0.5, 0, 1, 0.25)).reshape((2, 2))\n\nstats = get_array_statistics(data, coverage=coverage)\nassert len(stats) == 1\nassert stats[0][\"min\"] == 1\nassert stats[0][\"max\"] == 4\nassert (\n    round(stats[0][\"mean\"], 4) == 2.5714\n)  # sum of weighted array / sum of weights | 4.5 / 1.75 = 2.57\nassert stats[0][\"count\"] == 1.75\n</code></pre>"},{"location":"advanced/statistics/#adjusting-geometry-align_bounds_with_datasettrue","title":"Adjusting geometry <code>align_bounds_with_dataset=True</code>","text":"<p>In rio-tiler <code>6.3,0</code> a new option has been introduced to reduce artifacts and produce more precise zonal statistics. This option is available in the low-level <code>reader.part()</code> method used in rio-tiler reader's <code>.feature()</code> and <code>.part()</code> methods.</p> <pre><code>with Reader(\"cog.tif\") as src:\n    data = src.feature(\n        shape,\n        shape_crs=WGS84_CRS,\n        align_bounds_with_dataset=True,\n    )\n\n    coverage_array = data.get_coverage_array(\n        shape,\n        shape_crs=WGS84_CRS,\n    )\n\n    stats = data.statistics(coverage=coverage_array)\n</code></pre> <p>When passing <code>align_bounds_with_dataset=True</code> to the <code>reader.part()</code> method (forwarded from <code>.feature</code> or <code>.part</code> reader methods), rio-tiler will adjust the input geometry bounds to match the input dataset resolution/transform and avoid unnecessary resampling.</p> <p></p>"},{"location":"advanced/statistics/#zonal-statistics-method","title":"Zonal Statistics method","text":"<p>You can easily extend the rio-tiler's reader to add a <code>.zonal_statistics()</code> method as:</p> <pre><code>import attr\nfrom typing import Any, Union, Optional, List, Dict\n\nfrom rio_tiler import io\nfrom rio_tiler.models import BandStatistics\nfrom rio_tiler.constants import WGS84_CRS\n\nfrom geojson_pydantic.features import Feature, FeatureCollection\nfrom geojson_pydantic.geometries import Polygon\n\nclass Reader(io.Reader):\n    \"\"\"Custom Reader with zonal_statistics method.\"\"\"\n\n    def zonal_statistics(\n        self,\n        geojson: Union[FeatureCollection, Feature],\n        categorical: bool = False,\n        categories: Optional[List[float]] = None,\n        percentiles: Optional[List[int]] = None,\n        hist_options: Optional[Dict] = None,\n        max_size: int = None,\n        **kwargs: Any,\n    ) -&gt; Union[FeatureCollection, Feature]:\n        \"\"\"Return statistics from GeoJSON features.\n\n        Args:\n            geojson (Feature or FeatureCollection): a GeoJSON Feature or FeatureCollection.\n            categorical (bool): treat input data as categorical data. Defaults to False.\n            categories (list of numbers, optional): list of categories to return value for.\n            percentiles (list of numbers, optional): list of percentile values to calculate. Defaults to `[2, 98]`.\n            hist_options (dict, optional): Options to forward to numpy.histogram function.\n            max_size (int, optional): Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to None.\n            kwargs (optional): Options to forward to `self.preview`.\n\n        Returns:\n            Feature or FeatureCollection\n\n        \"\"\"\n        kwargs = {**self.options, **kwargs}\n\n        hist_options = hist_options or {}\n\n        fc = geojson\n        # We transform the input Feature to a FeatureCollection\n        if isinstance(fc, Feature):\n            fc = FeatureCollection(type=\"FeatureCollection\", features=[geojson])\n\n        for feature in fc:\n            geom = feature.model_dump(exclude_none=True)\n\n            # Get data overlapping with the feature (using Reader.feature method)\n            data = self.feature(\n                geom,\n                shape_crs=WGS84_CRS,\n                align_bounds_with_dataset=True,\n                max_size=max_size,\n                **kwargs,\n            )\n            coverage_array = data.get_coverage_array(\n                geom,\n                shape_crs=WGS84_CRS,\n            )\n\n            stats = data.statistics(\n                categorical=categorical,\n                categories=categories,\n                percentiles=percentiles,\n                hist_options=hist_options,\n                coverage=coverage_array,\n            )\n\n            # Update input feature properties and add the statistics\n            feature.properties = feature.properties or {}\n            feature.properties.update({\"statistics\": stats})\n\n        return fc.features[0] if isinstance(geojson, Feature) else fc\n</code></pre>"},{"location":"advanced/tms/","title":"TileMatrixSet","text":"<p>Starting with rio-tiler 2.0, we replaced <code>mercantile</code> with <code>morecantile</code>, enabling support for other TileMatrixSets than the default WebMercator grid.</p> <pre><code>import morecantile\nfrom rio_tiler.io import Reader\nfrom rasterio.crs import CRS\nfrom pyproj import CRS as projCRS\n\n# By default we use WebMercator TMS\nwith Reader(\"my.tif\") as cog:\n    img = cog.tile(1, 1, 1)\n    assert img.crs == CRS.from_epsg(3857)  # default image output is the TMS crs (WebMercator)\n\n# Print default grids\nfor name in morecantile.tms.list():\n    print(name, \"-\", morecantile.tms.get(name).rasterio_crs)\n\n&gt;&gt;&gt; CanadianNAD83_LCC - EPSG:3978\n    EuropeanETRS89_LAEAQuad - EPSG:3035\n    LINZAntarticaMapTilegrid - EPSG:5482\n    NZTM2000Quad - EPSG:2193\n    UPSAntarcticWGS84Quad - EPSG:5042\n    UPSArcticWGS84Quad - EPSG:5041\n    UTM31WGS84Quad - EPSG:32631\n    WGS1984Quad - EPSG:4326\n    WebMercatorQuad - EPSG:3857\n    WorldCRS84Quad - OGC:CRS84\n    WorldMercatorWGS84Quad - EPSG:3395\n\n\n# Use EPSG:4326 (WGS84) grid\nwgs84_grid = morecantile.tms.get(\"WorldCRS84Quad\")\nwith Reader(\"my.tif\", tms=wgs84_grid) as cog:\n    img = cog.tile(1, 1, 1)\n    assert img.crs == CRS.from_epsg(4326)\n\n# Create Custom grid\nextent = [-948.75, -543592.47, 5817.41, -3333128.95]  # From https:///epsg.io/3031\nepsg3031TMS = morecantile.TileMatrixSet.custom(\n    extent, projCRS.from_epsg(3031), identifier=\"MyCustomTmsEPSG3031\"\n)\nwith Reader(\"my.tif\", tms=epsg3031TMS) as cog:\n    img = cog.tile(1, 1, 1)\n    assert img.crs == CRS.from_epsg(3031)\n</code></pre>"},{"location":"api/rio_tiler/colormap/","title":"Module rio_tiler.colormap","text":"<p>rio-tiler colormap functions and classes.</p>"},{"location":"api/rio_tiler/colormap/#variables","title":"Variables","text":"<pre><code>DEFAULT_CMAPS_FILES\n</code></pre> <pre><code>EMPTY_COLORMAP\n</code></pre> <pre><code>USER_CMAPS_DIR\n</code></pre> <pre><code>cmap\n</code></pre>"},{"location":"api/rio_tiler/colormap/#functions","title":"Functions","text":""},{"location":"api/rio_tiler/colormap/#apply_cmap","title":"apply_cmap","text":"<pre><code>def apply_cmap(\n    data: numpy.ndarray,\n    colormap: Union[Dict[int, Tuple[int, int, int, int]], Sequence[Tuple[Tuple[Union[float, int], Union[float, int]], Tuple[int, int, int, int]]]]\n) -&gt; Tuple[numpy.ndarray, numpy.ndarray]\n</code></pre> <p>Apply colormap on data.</p> <p>Parameters:</p> Name Type Description Default data numpy.ndarray 1D image array to translate to RGB. None colormap dict or sequence GDAL RGBA Color Table dictionary or sequence (for intervals). None <p>Returns:</p> Type Description tuple Data (numpy.ndarray) and Mask (numpy.ndarray) values. <p>Raises:</p> Type Description InvalidFormat If data is not a 1 band dataset (1, col, row)."},{"location":"api/rio_tiler/colormap/#apply_discrete_cmap","title":"apply_discrete_cmap","text":"<pre><code>def apply_discrete_cmap(\n    data: numpy.ndarray,\n    colormap: Dict[int, Tuple[int, int, int, int]]\n) -&gt; Tuple[numpy.ndarray, numpy.ndarray]\n</code></pre> <p>Apply discrete colormap.</p> <p>Parameters:</p> Name Type Description Default data numpy.ndarray 1D image array to translate to RGB. None color_map dict Discrete ColorMap dictionary. None <p>Returns:</p> Type Description tuple Data (numpy.ndarray) and Alpha band (numpy.ndarray)."},{"location":"api/rio_tiler/colormap/#apply_intervals_cmap","title":"apply_intervals_cmap","text":"<pre><code>def apply_intervals_cmap(\n    data: numpy.ndarray,\n    colormap: Sequence[Tuple[Tuple[Union[float, int], Union[float, int]], Tuple[int, int, int, int]]]\n) -&gt; Tuple[numpy.ndarray, numpy.ndarray]\n</code></pre> <p>Apply intervals colormap.</p> <p>Parameters:</p> Name Type Description Default data numpy.ndarray 1D image array to translate to RGB. None color_map Sequence Sequence of intervals and color in form of [([min, max], [r, g, b, a]), ...]. None <p>Returns:</p> Type Description tuple Data (numpy.ndarray) and Alpha band (numpy.ndarray)."},{"location":"api/rio_tiler/colormap/#make_lut","title":"make_lut","text":"<pre><code>def make_lut(\n    colormap: Dict[int, Tuple[int, int, int, int]]\n) -&gt; numpy.ndarray\n</code></pre> <p>Create a lookup table numpy.ndarray from a GDAL RGBA Color Table dictionary.</p> <p>Parameters:</p> Name Type Description Default colormap dict GDAL RGBA Color Table dictionary. None <p>Returns:</p> Type Description numpy.ndarray colormap lookup table."},{"location":"api/rio_tiler/colormap/#parse_color","title":"parse_color","text":"<pre><code>def parse_color(\n    rgba: Union[Sequence[int], str]\n) -&gt; Tuple[int, int, int, int]\n</code></pre> <p>Parse RGB/RGBA color and return valid rio-tiler compatible RGBA colormap entry.</p> <p>Parameters:</p> Name Type Description Default rgba str or list of int HEX encoded or list RGB or RGBA colors. None <p>Returns:</p> Type Description tuple RGBA values."},{"location":"api/rio_tiler/colormap/#classes","title":"Classes","text":""},{"location":"api/rio_tiler/colormap/#colormaps","title":"ColorMaps","text":"<pre><code>class ColorMaps(\n    data: Dict[str, Union[str, Dict[int, Tuple[int, int, int, int]], Sequence[Tuple[Tuple[Union[float, int], Union[float, int]], Tuple[int, int, int, int]]]]] = NOTHING\n)\n</code></pre> <p>Default Colormaps holder.</p>"},{"location":"api/rio_tiler/colormap/#attributes","title":"Attributes","text":"Name Type Description Default data dict colormaps. Defaults to <code>rio_tiler.colormap.DEFAULTS_CMAPS</code>. <code>rio_tiler.colormap.DEFAULTS_CMAPS</code>"},{"location":"api/rio_tiler/colormap/#methods","title":"Methods","text":""},{"location":"api/rio_tiler/colormap/#get","title":"get","text":"<pre><code>def get(\n    self,\n    name: str\n) -&gt; Union[Dict[int, Tuple[int, int, int, int]], Sequence[Tuple[Tuple[Union[float, int], Union[float, int]], Tuple[int, int, int, int]]]]\n</code></pre> <p>Fetch a colormap.</p> <p>Parameters:</p> Name Type Description Default name str colormap name. None"},{"location":"api/rio_tiler/colormap/#list","title":"list","text":"<pre><code>def list(\n    self\n) -&gt; List[str]\n</code></pre> <p>List registered Colormaps.</p> <p>Returns     list: list of colormap names.</p>"},{"location":"api/rio_tiler/colormap/#register","title":"register","text":"<pre><code>def register(\n    self,\n    custom_cmap: Dict[str, Union[str, Dict[int, Tuple[int, int, int, int]], Sequence[Tuple[Tuple[Union[float, int], Union[float, int]], Tuple[int, int, int, int]]]]],\n    overwrite: bool = False\n) -&gt; 'ColorMaps'\n</code></pre> <p>Register a custom colormap.</p> <p>Parameters:</p> Name Type Description Default custom_cmap dict custom colormap(s) to register. None overwrite bool Overwrite existing colormap with same key. Defaults to False. False"},{"location":"api/rio_tiler/constants/","title":"Module rio_tiler.constants","text":"<p>rio-tiler constant values.</p>"},{"location":"api/rio_tiler/constants/#variables","title":"Variables","text":"<pre><code>MAX_THREADS\n</code></pre> <pre><code>WEB_MERCATOR_CRS\n</code></pre> <pre><code>WEB_MERCATOR_TMS\n</code></pre> <pre><code>WGS84_CRS\n</code></pre>"},{"location":"api/rio_tiler/errors/","title":"Module rio_tiler.errors","text":"<p>Errors and warnings.</p>"},{"location":"api/rio_tiler/errors/#classes","title":"Classes","text":""},{"location":"api/rio_tiler/errors/#alphabandwarning","title":"AlphaBandWarning","text":"<pre><code>class AlphaBandWarning(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Automatically removed Alpha band from output array.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>builtins.UserWarning</li> <li>builtins.Warning</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#assetasbanderror","title":"AssetAsBandError","text":"<pre><code>class AssetAsBandError(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Can't use asset_as_band with multiple bands.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_1","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_1","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_1","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_1","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#colormapalreadyregistered","title":"ColorMapAlreadyRegistered","text":"<pre><code>class ColorMapAlreadyRegistered(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>ColorMap is already registered.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_2","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_2","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_2","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_2","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#emptymosaicerror","title":"EmptyMosaicError","text":"<pre><code>class EmptyMosaicError(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Mosaic method returned empty array.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_3","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_3","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_3","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_3","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#expressionmixingwarning","title":"ExpressionMixingWarning","text":"<pre><code>class ExpressionMixingWarning(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Expression and assets/indexes mixing.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_4","title":"Ancestors (in MRO)","text":"<ul> <li>builtins.UserWarning</li> <li>builtins.Warning</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_4","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_4","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_4","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#invalidassetname","title":"InvalidAssetName","text":"<pre><code>class InvalidAssetName(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Invalid Asset name.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_5","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_5","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_5","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_5","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#invalidbandname","title":"InvalidBandName","text":"<pre><code>class InvalidBandName(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Invalid band name.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_6","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_6","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_6","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_6","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#invalidbuffersize","title":"InvalidBufferSize","text":"<pre><code>class InvalidBufferSize(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p><code>buffer</code> must be a multiple of <code>0.5</code> (e.g: 0.5, 1, 1.5, ...).</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_7","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_7","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_7","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_7","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#invalidcolorformat","title":"InvalidColorFormat","text":"<pre><code>class InvalidColorFormat(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Invalid color format.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_8","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_8","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_8","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_8","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#invalidcolormapname","title":"InvalidColorMapName","text":"<pre><code>class InvalidColorMapName(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Invalid colormap name.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_9","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_9","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_9","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_9","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#invaliddatatypewarning","title":"InvalidDatatypeWarning","text":"<pre><code>class InvalidDatatypeWarning(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Invalid Output Datatype.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_10","title":"Ancestors (in MRO)","text":"<ul> <li>builtins.UserWarning</li> <li>builtins.Warning</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_10","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_10","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_10","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#invalidexpression","title":"InvalidExpression","text":"<pre><code>class InvalidExpression(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Invalid Expression.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_11","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_11","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_11","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_11","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#invalidformat","title":"InvalidFormat","text":"<pre><code>class InvalidFormat(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Invalid image format.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_12","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_12","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_12","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_12","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#invalidmosaicmethod","title":"InvalidMosaicMethod","text":"<pre><code>class InvalidMosaicMethod(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Invalid Pixel Selection method for mosaic.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_13","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_13","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_13","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_13","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#invalidpointdataerror","title":"InvalidPointDataError","text":"<pre><code>class InvalidPointDataError(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Invalid PointData.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_14","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_14","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_14","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_14","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#missingassets","title":"MissingAssets","text":"<pre><code>class MissingAssets(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Missing Assets.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_15","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_15","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_15","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_15","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#missingbands","title":"MissingBands","text":"<pre><code>class MissingBands(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Missing bands.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_16","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_16","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_16","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_16","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#nooverviewwarning","title":"NoOverviewWarning","text":"<pre><code>class NoOverviewWarning(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Dataset has no overviews.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_17","title":"Ancestors (in MRO)","text":"<ul> <li>builtins.UserWarning</li> <li>builtins.Warning</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_17","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_17","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_17","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#pointoutsidebounds","title":"PointOutsideBounds","text":"<pre><code>class PointOutsideBounds(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Point is outside image bounds.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_18","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_18","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_18","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_18","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#riotilererror","title":"RioTilerError","text":"<pre><code>class RioTilerError(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Base exception class.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_19","title":"Ancestors (in MRO)","text":"<ul> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#descendants","title":"Descendants","text":"<ul> <li>rio_tiler.errors.InvalidFormat</li> <li>rio_tiler.errors.TileOutsideBounds</li> <li>rio_tiler.errors.InvalidBufferSize</li> <li>rio_tiler.errors.PointOutsideBounds</li> <li>rio_tiler.errors.InvalidBandName</li> <li>rio_tiler.errors.InvalidColorMapName</li> <li>rio_tiler.errors.InvalidAssetName</li> <li>rio_tiler.errors.InvalidExpression</li> <li>rio_tiler.errors.MissingAssets</li> <li>rio_tiler.errors.MissingBands</li> <li>rio_tiler.errors.InvalidMosaicMethod</li> <li>rio_tiler.errors.ColorMapAlreadyRegistered</li> <li>rio_tiler.errors.EmptyMosaicError</li> <li>rio_tiler.errors.InvalidColorFormat</li> <li>rio_tiler.errors.AssetAsBandError</li> <li>rio_tiler.errors.InvalidPointDataError</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_19","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_19","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_19","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/errors/#tileoutsidebounds","title":"TileOutsideBounds","text":"<pre><code>class TileOutsideBounds(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Z-X-Y Tile is outside image bounds.</p>"},{"location":"api/rio_tiler/errors/#ancestors-in-mro_20","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.errors.RioTilerError</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api/rio_tiler/errors/#class-variables_20","title":"Class variables","text":"<pre><code>args\n</code></pre>"},{"location":"api/rio_tiler/errors/#methods_20","title":"Methods","text":""},{"location":"api/rio_tiler/errors/#with_traceback_20","title":"with_traceback","text":"<pre><code>def with_traceback(\n    ...\n)\n</code></pre> <p>Exception.with_traceback(tb) --</p> <p>set self.traceback to tb and return self.</p>"},{"location":"api/rio_tiler/expression/","title":"Module rio_tiler.expression","text":"<p>rio-tiler.expression: Parse and Apply expression.</p>"},{"location":"api/rio_tiler/expression/#functions","title":"Functions","text":""},{"location":"api/rio_tiler/expression/#apply_expression","title":"apply_expression","text":"<pre><code>def apply_expression(\n    blocks: Sequence[str],\n    bands: Sequence[str],\n    data: numpy.ndarray\n) -&gt; numpy.ma.core.MaskedArray\n</code></pre> <p>Apply rio-tiler expression.</p> <p>Parameters:</p> Name Type Description Default blocks sequence expression for a specific layer. None bands sequence bands names. None data numpy.array array of bands. None <p>Returns:</p> Type Description numpy.array output data."},{"location":"api/rio_tiler/expression/#get_expression_blocks","title":"get_expression_blocks","text":"<pre><code>def get_expression_blocks(\n    expression: str\n) -&gt; List[str]\n</code></pre> <p>Split expression in blocks.</p> <p>Parameters:</p> Name Type Description Default expression str band math/combination expression. None <p>Returns:</p> Type Description list expression blocks (str)."},{"location":"api/rio_tiler/expression/#parse_expression","title":"parse_expression","text":"<pre><code>def parse_expression(\n    expression: str,\n    cast: bool = True\n) -&gt; Tuple\n</code></pre> <p>Parse rio-tiler band math expression.</p> <p>Parameters:</p> Name Type Description Default expression str band math/combination expression. None cast bool cast band names to integers (convert to index values). Defaults to True. True <p>Returns:</p> Type Description tuple band names/indexes."},{"location":"api/rio_tiler/models/","title":"Module rio_tiler.models","text":"<p>rio-tiler models.</p>"},{"location":"api/rio_tiler/models/#variables","title":"Variables","text":"<pre><code>WGS84_CRS\n</code></pre> <pre><code>dtype_ranges\n</code></pre>"},{"location":"api/rio_tiler/models/#functions","title":"Functions","text":""},{"location":"api/rio_tiler/models/#masked_and_3d","title":"masked_and_3d","text":"<pre><code>def masked_and_3d(\n    array: numpy.ndarray\n) -&gt; numpy.ma.core.MaskedArray\n</code></pre> <p>Makes sure we have a 3D array and mask</p>"},{"location":"api/rio_tiler/models/#rescale_image","title":"rescale_image","text":"<pre><code>def rescale_image(\n    array: numpy.ma.core.MaskedArray,\n    in_range: Sequence[Tuple[Union[float, int], Union[float, int]]],\n    out_range: Sequence[Tuple[Union[float, int], Union[float, int]]] = ((0, 255),),\n    out_dtype: Union[str, numpy.number] = 'uint8'\n) -&gt; numpy.ma.core.MaskedArray\n</code></pre> <p>Rescale image data in-place.</p>"},{"location":"api/rio_tiler/models/#to_coordsbbox","title":"to_coordsbbox","text":"<pre><code>def to_coordsbbox(\n    bbox\n) -&gt; Union[rasterio.coords.BoundingBox, NoneType]\n</code></pre> <p>Convert bbox to CoordsBbox nameTuple.</p>"},{"location":"api/rio_tiler/models/#to_masked","title":"to_masked","text":"<pre><code>def to_masked(\n    array: numpy.ndarray\n) -&gt; numpy.ma.core.MaskedArray\n</code></pre> <p>Makes sure we have a MaskedArray.</p>"},{"location":"api/rio_tiler/models/#classes","title":"Classes","text":""},{"location":"api/rio_tiler/models/#bandstatistics","title":"BandStatistics","text":"<pre><code>class BandStatistics(\n    /,\n    **data: 'Any'\n)\n</code></pre> <p>Band statistics</p>"},{"location":"api/rio_tiler/models/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.models.RioTilerBaseModel</li> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/rio_tiler/models/#class-variables","title":"Class variables","text":"<pre><code>model_computed_fields\n</code></pre> <pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/rio_tiler/models/#static-methods","title":"Static methods","text":""},{"location":"api/rio_tiler/models/#construct","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#from_orm","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#model_construct","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/rio_tiler/models/#model_json_schema","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of<code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/rio_tiler/models/#model_parametrized_name","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class<code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>,the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/rio_tiler/models/#model_rebuild","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required.If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/rio_tiler/models/#model_validate","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to enforce types strictly. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/rio_tiler/models/#model_validate_json","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/json/#json-parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/rio_tiler/models/#model_validate_strings","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/rio_tiler/models/#parse_file","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#parse_obj","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#parse_raw","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#schema","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/rio_tiler/models/#schema_json","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/rio_tiler/models/#update_forward_refs","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/rio_tiler/models/#validate","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#instance-variables","title":"Instance variables","text":"<pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p>"},{"location":"api/rio_tiler/models/#methods","title":"Methods","text":""},{"location":"api/rio_tiler/models/#copy","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep-copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/rio_tiler/models/#dict","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/rio_tiler/models/#json","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/rio_tiler/models/#model_copy","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validatedbefore creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/rio_tiler/models/#model_dump","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal[('json', 'python')] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    context: 'dict[str, Any] | None' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: \"bool | Literal[('none', 'warn', 'error')]\" = True,\n    serialize_as_any: 'bool' = False\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run.If mode is 'json', the output will only contain JSON serializable types.If mode is 'python', the output may contain non-JSON-serializable Python objects. None include None A set of fields to include in the output. None exclude None A set of fields to exclude from the output. None context None Additional context to pass to the serializer. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that are set to their default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None If True, dumped values should be valid as input for non-idempotent types such as Json[T]. None warnings None How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\"error\" raises a [<code>PydanticSerializationError</code>][pydantic_core.PydanticSerializationError]. None serialize_as_any None Whether to serialize fields with duck-typing serialization behavior. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/rio_tiler/models/#model_dump_json","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    context: 'dict[str, Any] | None' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: \"bool | Literal[('none', 'warn', 'error')]\" = True,\n    serialize_as_any: 'bool' = False\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. None exclude None Field(s) to exclude from the JSON output. None context None Additional context to pass to the serializer. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that are set to their default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None If True, dumped values should be valid as input for non-idempotent types such as Json[T]. None warnings None How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\"error\" raises a [<code>PydanticSerializationError</code>][pydantic_core.PydanticSerializationError]. None serialize_as_any None Whether to serialize fields with duck-typing serialization behavior. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/rio_tiler/models/#model_post_init","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/rio_tiler/models/#bounds","title":"Bounds","text":"<pre><code>class Bounds(\n    /,\n    **data: 'Any'\n)\n</code></pre> <p>Dataset Bounding box</p>"},{"location":"api/rio_tiler/models/#ancestors-in-mro_1","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.models.RioTilerBaseModel</li> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/rio_tiler/models/#descendants","title":"Descendants","text":"<ul> <li>rio_tiler.models.SpatialInfo</li> </ul>"},{"location":"api/rio_tiler/models/#class-variables_1","title":"Class variables","text":"<pre><code>model_computed_fields\n</code></pre> <pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/rio_tiler/models/#static-methods_1","title":"Static methods","text":""},{"location":"api/rio_tiler/models/#construct_1","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#from_orm_1","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#model_construct_1","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/rio_tiler/models/#model_json_schema_1","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of<code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/rio_tiler/models/#model_parametrized_name_1","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class<code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>,the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/rio_tiler/models/#model_rebuild_1","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required.If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/rio_tiler/models/#model_validate_1","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to enforce types strictly. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/rio_tiler/models/#model_validate_json_1","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/json/#json-parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/rio_tiler/models/#model_validate_strings_1","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/rio_tiler/models/#parse_file_1","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#parse_obj_1","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#parse_raw_1","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#schema_1","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/rio_tiler/models/#schema_json_1","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/rio_tiler/models/#update_forward_refs_1","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/rio_tiler/models/#validate_1","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#instance-variables_1","title":"Instance variables","text":"<pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p>"},{"location":"api/rio_tiler/models/#methods_1","title":"Methods","text":""},{"location":"api/rio_tiler/models/#copy_1","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep-copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/rio_tiler/models/#dict_1","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/rio_tiler/models/#json_1","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/rio_tiler/models/#model_copy_1","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validatedbefore creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/rio_tiler/models/#model_dump_1","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal[('json', 'python')] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    context: 'dict[str, Any] | None' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: \"bool | Literal[('none', 'warn', 'error')]\" = True,\n    serialize_as_any: 'bool' = False\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run.If mode is 'json', the output will only contain JSON serializable types.If mode is 'python', the output may contain non-JSON-serializable Python objects. None include None A set of fields to include in the output. None exclude None A set of fields to exclude from the output. None context None Additional context to pass to the serializer. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that are set to their default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None If True, dumped values should be valid as input for non-idempotent types such as Json[T]. None warnings None How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\"error\" raises a [<code>PydanticSerializationError</code>][pydantic_core.PydanticSerializationError]. None serialize_as_any None Whether to serialize fields with duck-typing serialization behavior. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/rio_tiler/models/#model_dump_json_1","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    context: 'dict[str, Any] | None' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: \"bool | Literal[('none', 'warn', 'error')]\" = True,\n    serialize_as_any: 'bool' = False\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. None exclude None Field(s) to exclude from the JSON output. None context None Additional context to pass to the serializer. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that are set to their default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None If True, dumped values should be valid as input for non-idempotent types such as Json[T]. None warnings None How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\"error\" raises a [<code>PydanticSerializationError</code>][pydantic_core.PydanticSerializationError]. None serialize_as_any None Whether to serialize fields with duck-typing serialization behavior. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/rio_tiler/models/#model_post_init_1","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/rio_tiler/models/#imagedata","title":"ImageData","text":"<pre><code>class ImageData(\n    array: numpy.ndarray,\n    cutline_mask: Union[numpy.ndarray, NoneType] = None,\n    *,\n    assets: Union[List, NoneType] = None,\n    bounds=None,\n    crs: Union[rasterio.crs.CRS, NoneType] = None,\n    metadata: Union[Dict, NoneType] = NOTHING,\n    band_names: List[str] = NOTHING,\n    dataset_statistics: Union[Sequence[Tuple[float, float]], NoneType] = None\n)\n</code></pre> <p>Image Data class.</p>"},{"location":"api/rio_tiler/models/#attributes","title":"Attributes","text":"Name Type Description Default array numpy.ma.MaskedArray image values. None assets list list of assets used to construct the data values. None bounds BoundingBox bounding box of the data. None crs rasterio.crs.CRS Coordinates Reference System of the bounds. None metadata dict Additional metadata. Defaults to <code>{}</code>. <code>{}</code> band_names list name of each band. Defaults to <code>[\"1\", \"2\", \"3\"]</code> for 3 bands image. <code>[\"1\", \"2\", \"3\"]</code> for 3 bands image dataset_statistics list dataset statistics <code>[(min, max), (min, max)]</code> None"},{"location":"api/rio_tiler/models/#static-methods_2","title":"Static methods","text":""},{"location":"api/rio_tiler/models/#create_from_list","title":"create_from_list","text":"<pre><code>def create_from_list(\n    data: Sequence[ForwardRef('ImageData')]\n) -&gt; 'ImageData'\n</code></pre> <p>Create ImageData from a sequence of ImageData objects.</p> <p>Parameters:</p> Name Type Description Default data sequence sequence of ImageData. None"},{"location":"api/rio_tiler/models/#from_array","title":"from_array","text":"<pre><code>def from_array(\n    arr: numpy.ndarray\n) -&gt; 'ImageData'\n</code></pre> <p>Create ImageData from a numpy array.</p> <p>Parameters:</p> Name Type Description Default arr numpy.ndarray Numpy array or Numpy masked array. None"},{"location":"api/rio_tiler/models/#from_bytes","title":"from_bytes","text":"<pre><code>def from_bytes(\n    data: bytes\n) -&gt; 'ImageData'\n</code></pre> <p>Create ImageData from bytes.</p> <p>Parameters:</p> Name Type Description Default data bytes raster dataset as bytes. None"},{"location":"api/rio_tiler/models/#instance-variables_2","title":"Instance variables","text":"<pre><code>count\n</code></pre> <p>Number of band.</p> <pre><code>data\n</code></pre> <p>Return data part of the masked array.</p> <pre><code>height\n</code></pre> <p>Height of the data array.</p> <pre><code>mask\n</code></pre> <p>Return Mask in form of rasterio dataset mask.</p> <pre><code>transform\n</code></pre> <p>Returns the affine transform.</p> <pre><code>width\n</code></pre> <p>Width of the data array.</p>"},{"location":"api/rio_tiler/models/#methods_2","title":"Methods","text":""},{"location":"api/rio_tiler/models/#apply_color_formula","title":"apply_color_formula","text":"<pre><code>def apply_color_formula(\n    self,\n    color_formula: Union[str, NoneType]\n)\n</code></pre> <p>Apply color-operations formula in place.</p>"},{"location":"api/rio_tiler/models/#apply_colormap","title":"apply_colormap","text":"<pre><code>def apply_colormap(\n    self,\n    colormap: Union[Dict[int, Tuple[int, int, int, int]], Sequence[Tuple[Tuple[Union[float, int], Union[float, int]], Tuple[int, int, int, int]]]]\n) -&gt; 'ImageData'\n</code></pre> <p>Apply colormap to the image data.</p>"},{"location":"api/rio_tiler/models/#apply_expression","title":"apply_expression","text":"<pre><code>def apply_expression(\n    self,\n    expression: str\n) -&gt; 'ImageData'\n</code></pre> <p>Apply expression to the image data.</p>"},{"location":"api/rio_tiler/models/#as_masked","title":"as_masked","text":"<pre><code>def as_masked(\n    self\n) -&gt; numpy.ma.core.MaskedArray\n</code></pre> <p>return a numpy masked array.</p>"},{"location":"api/rio_tiler/models/#clip","title":"clip","text":"<pre><code>def clip(\n    self,\n    bbox: Tuple[float, float, float, float]\n) -&gt; 'ImageData'\n</code></pre> <p>Clip data and mask to a bbox.</p>"},{"location":"api/rio_tiler/models/#data_as_image","title":"data_as_image","text":"<pre><code>def data_as_image(\n    self\n) -&gt; numpy.ndarray\n</code></pre> <p>Return the data array reshaped into an image processing/visualization software friendly order.</p> <p>(bands, rows, columns) -&gt; (rows, columns, bands).</p>"},{"location":"api/rio_tiler/models/#get_coverage_array","title":"get_coverage_array","text":"<pre><code>def get_coverage_array(\n    self,\n    shape: Dict,\n    shape_crs: rasterio.crs.CRS = CRS.from_epsg(4326),\n    cover_scale: int = 10\n) -&gt; numpy.ndarray[typing.Any, numpy.dtype[numpy.floating]]\n</code></pre> <p>Post-process image data.</p> <p>Parameters:</p> Name Type Description Default in_range tuple input min/max bounds value to rescale from. None out_dtype str output datatype after rescaling. Defaults to <code>uint8</code>. <code>uint8</code> color_formula str color-ops formula (see: vincentsarago/color-ops). None cover_scale int Scale used when generating coverage estimates of eachraster cell by vector feature. Coverage is generated byrasterizing the feature at a finer resolution than the raster then using a summation to aggregateto the raster resolution and dividing by the square of cover_scaleto get coverage value for each cell. Increasing cover_scalewill increase the accuracy of coverage values; three ordersmagnitude finer resolution (cover_scale=1000) is usually enough toget coverage estimates with &lt;1% error in individual edge cells coverageestimates, though much smaller values (e.g., cover_scale=10) are oftensufficient (&lt;10% error) and require less memory. None <p>Returns:</p> Type Description numpy.array percent coverage."},{"location":"api/rio_tiler/models/#post_process","title":"post_process","text":"<pre><code>def post_process(\n    self,\n    in_range: Union[Sequence[Tuple[Union[float, int], Union[float, int]]], NoneType] = None,\n    out_dtype: Union[str, numpy.number] = 'uint8',\n    color_formula: Union[str, NoneType] = None,\n    **kwargs: Any\n) -&gt; 'ImageData'\n</code></pre> <p>Post-process image data.</p> <p>Parameters:</p> Name Type Description Default in_range tuple input min/max bounds value to rescale from. None out_dtype str output datatype after rescaling. Defaults to <code>uint8</code>. <code>uint8</code> color_formula str color-ops formula (see: vincentsarago/color-ops). None kwargs optional keyword arguments to forward to <code>rio_tiler.utils.linear_rescale</code>. None <p>Returns:</p> Type Description ImageData new ImageData object with the updated data."},{"location":"api/rio_tiler/models/#render","title":"render","text":"<pre><code>def render(\n    self,\n    add_mask: bool = True,\n    img_format: str = 'PNG',\n    colormap: Union[Dict[int, Tuple[int, int, int, int]], Sequence[Tuple[Tuple[Union[float, int], Union[float, int]], Tuple[int, int, int, int]]], NoneType] = None,\n    **kwargs\n) -&gt; bytes\n</code></pre> <p>Render data to image blob.</p> <p>Parameters:</p> Name Type Description Default add_mask bool add mask to output image. Defaults to <code>True</code>. <code>True</code> img_format str output image format. Defaults to <code>PNG</code>. <code>PNG</code> colormap dict or sequence RGBA Color Table dictionary or sequence. None kwargs optional keyword arguments to forward to <code>rio_tiler.utils.render</code>. None <p>Returns:</p> Type Description bytes image."},{"location":"api/rio_tiler/models/#rescale","title":"rescale","text":"<pre><code>def rescale(\n    self,\n    in_range: Sequence[Tuple[Union[float, int], Union[float, int]]],\n    out_range: Sequence[Tuple[Union[float, int], Union[float, int]]] = ((0, 255),),\n    out_dtype: Union[str, numpy.number] = 'uint8'\n)\n</code></pre> <p>Rescale data in place.</p>"},{"location":"api/rio_tiler/models/#resize","title":"resize","text":"<pre><code>def resize(\n    self,\n    height: int,\n    width: int,\n    resampling_method: Literal['nearest', 'bilinear', 'cubic', 'cubic_spline', 'lanczos', 'average', 'mode', 'gauss', 'rms'] = 'nearest'\n) -&gt; 'ImageData'\n</code></pre> <p>Resize data and mask.</p>"},{"location":"api/rio_tiler/models/#statistics","title":"statistics","text":"<pre><code>def statistics(\n    self,\n    categorical: bool = False,\n    categories: Union[List[float], NoneType] = None,\n    percentiles: Union[List[int], NoneType] = None,\n    hist_options: Union[Dict, NoneType] = None,\n    coverage: Union[numpy.ndarray, NoneType] = None\n) -&gt; Dict[str, rio_tiler.models.BandStatistics]\n</code></pre> <p>Return statistics from ImageData.</p>"},{"location":"api/rio_tiler/models/#info","title":"Info","text":"<pre><code>class Info(\n    /,\n    **data: 'Any'\n)\n</code></pre> <p>Dataset Info.</p>"},{"location":"api/rio_tiler/models/#ancestors-in-mro_2","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.models.SpatialInfo</li> <li>rio_tiler.models.Bounds</li> <li>rio_tiler.models.RioTilerBaseModel</li> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/rio_tiler/models/#class-variables_2","title":"Class variables","text":"<pre><code>model_computed_fields\n</code></pre> <pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/rio_tiler/models/#static-methods_3","title":"Static methods","text":""},{"location":"api/rio_tiler/models/#construct_2","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#from_orm_2","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#model_construct_2","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/rio_tiler/models/#model_json_schema_2","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of<code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/rio_tiler/models/#model_parametrized_name_2","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class<code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>,the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/rio_tiler/models/#model_rebuild_2","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required.If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/rio_tiler/models/#model_validate_2","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to enforce types strictly. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/rio_tiler/models/#model_validate_json_2","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/json/#json-parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/rio_tiler/models/#model_validate_strings_2","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/rio_tiler/models/#parse_file_2","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#parse_obj_2","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#parse_raw_2","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#schema_2","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/rio_tiler/models/#schema_json_2","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/rio_tiler/models/#update_forward_refs_2","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/rio_tiler/models/#validate_2","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#instance-variables_3","title":"Instance variables","text":"<pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p>"},{"location":"api/rio_tiler/models/#methods_3","title":"Methods","text":""},{"location":"api/rio_tiler/models/#copy_2","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep-copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/rio_tiler/models/#dict_2","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/rio_tiler/models/#json_2","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/rio_tiler/models/#model_copy_2","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validatedbefore creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/rio_tiler/models/#model_dump_2","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal[('json', 'python')] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    context: 'dict[str, Any] | None' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: \"bool | Literal[('none', 'warn', 'error')]\" = True,\n    serialize_as_any: 'bool' = False\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run.If mode is 'json', the output will only contain JSON serializable types.If mode is 'python', the output may contain non-JSON-serializable Python objects. None include None A set of fields to include in the output. None exclude None A set of fields to exclude from the output. None context None Additional context to pass to the serializer. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that are set to their default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None If True, dumped values should be valid as input for non-idempotent types such as Json[T]. None warnings None How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\"error\" raises a [<code>PydanticSerializationError</code>][pydantic_core.PydanticSerializationError]. None serialize_as_any None Whether to serialize fields with duck-typing serialization behavior. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/rio_tiler/models/#model_dump_json_2","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    context: 'dict[str, Any] | None' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: \"bool | Literal[('none', 'warn', 'error')]\" = True,\n    serialize_as_any: 'bool' = False\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. None exclude None Field(s) to exclude from the JSON output. None context None Additional context to pass to the serializer. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that are set to their default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None If True, dumped values should be valid as input for non-idempotent types such as Json[T]. None warnings None How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\"error\" raises a [<code>PydanticSerializationError</code>][pydantic_core.PydanticSerializationError]. None serialize_as_any None Whether to serialize fields with duck-typing serialization behavior. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/rio_tiler/models/#model_post_init_2","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/rio_tiler/models/#pointdata","title":"PointData","text":"<pre><code>class PointData(\n    array: numpy.ndarray,\n    *,\n    band_names: List[str] = NOTHING,\n    coordinates: Union[Tuple[float, float], NoneType] = None,\n    crs: Union[rasterio.crs.CRS, NoneType] = None,\n    assets: Union[List, NoneType] = None,\n    metadata: Union[Dict, NoneType] = NOTHING\n)\n</code></pre> <p>Point Data class.</p>"},{"location":"api/rio_tiler/models/#attributes_1","title":"Attributes","text":"Name Type Description Default array numpy.ma.MaskedArray pixel values. None band_names list name of each band. Defaults to <code>[\"1\", \"2\", \"3\"]</code> for 3 bands image. <code>[\"1\", \"2\", \"3\"]</code> for 3 bands image coordinates tuple Point's coordinates. None crs rasterio.crs.CRS Coordinates Reference System of the bounds. None assets list list of assets used to construct the data values. None metadata dict Additional metadata. Defaults to <code>{}</code>. <code>{}</code>"},{"location":"api/rio_tiler/models/#static-methods_4","title":"Static methods","text":""},{"location":"api/rio_tiler/models/#create_from_list_1","title":"create_from_list","text":"<pre><code>def create_from_list(\n    data: Sequence[ForwardRef('PointData')]\n)\n</code></pre> <p>Create PointData from a sequence of PointsData objects.</p> <p>Parameters:</p> Name Type Description Default data sequence sequence of PointData. None"},{"location":"api/rio_tiler/models/#instance-variables_4","title":"Instance variables","text":"<pre><code>count\n</code></pre> <p>Number of band.</p> <pre><code>data\n</code></pre> <p>Return data part of the masked array.</p> <pre><code>mask\n</code></pre> <p>Return Mask in form of rasterio dataset mask.</p>"},{"location":"api/rio_tiler/models/#methods_4","title":"Methods","text":""},{"location":"api/rio_tiler/models/#apply_expression_1","title":"apply_expression","text":"<pre><code>def apply_expression(\n    self,\n    expression: str\n) -&gt; 'PointData'\n</code></pre> <p>Apply expression to the image data.</p>"},{"location":"api/rio_tiler/models/#as_masked_1","title":"as_masked","text":"<pre><code>def as_masked(\n    self\n) -&gt; numpy.ma.core.MaskedArray\n</code></pre> <p>return a numpy masked array.</p>"},{"location":"api/rio_tiler/models/#riotilerbasemodel","title":"RioTilerBaseModel","text":"<pre><code>class RioTilerBaseModel(\n    /,\n    **data: 'Any'\n)\n</code></pre> <p>Provides dictionary access for pydantic models, for backwards compatability.</p>"},{"location":"api/rio_tiler/models/#ancestors-in-mro_3","title":"Ancestors (in MRO)","text":"<ul> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/rio_tiler/models/#descendants_1","title":"Descendants","text":"<ul> <li>rio_tiler.models.Bounds</li> <li>rio_tiler.models.BandStatistics</li> </ul>"},{"location":"api/rio_tiler/models/#class-variables_3","title":"Class variables","text":"<pre><code>model_computed_fields\n</code></pre> <pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/rio_tiler/models/#static-methods_5","title":"Static methods","text":""},{"location":"api/rio_tiler/models/#construct_3","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#from_orm_3","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#model_construct_3","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/rio_tiler/models/#model_json_schema_3","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of<code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/rio_tiler/models/#model_parametrized_name_3","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class<code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>,the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/rio_tiler/models/#model_rebuild_3","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required.If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/rio_tiler/models/#model_validate_3","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to enforce types strictly. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/rio_tiler/models/#model_validate_json_3","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/json/#json-parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/rio_tiler/models/#model_validate_strings_3","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/rio_tiler/models/#parse_file_3","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#parse_obj_3","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#parse_raw_3","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#schema_3","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/rio_tiler/models/#schema_json_3","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/rio_tiler/models/#update_forward_refs_3","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/rio_tiler/models/#validate_3","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#instance-variables_5","title":"Instance variables","text":"<pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p>"},{"location":"api/rio_tiler/models/#methods_5","title":"Methods","text":""},{"location":"api/rio_tiler/models/#copy_3","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep-copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/rio_tiler/models/#dict_3","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/rio_tiler/models/#json_3","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/rio_tiler/models/#model_copy_3","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validatedbefore creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/rio_tiler/models/#model_dump_3","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal[('json', 'python')] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    context: 'dict[str, Any] | None' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: \"bool | Literal[('none', 'warn', 'error')]\" = True,\n    serialize_as_any: 'bool' = False\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run.If mode is 'json', the output will only contain JSON serializable types.If mode is 'python', the output may contain non-JSON-serializable Python objects. None include None A set of fields to include in the output. None exclude None A set of fields to exclude from the output. None context None Additional context to pass to the serializer. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that are set to their default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None If True, dumped values should be valid as input for non-idempotent types such as Json[T]. None warnings None How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\"error\" raises a [<code>PydanticSerializationError</code>][pydantic_core.PydanticSerializationError]. None serialize_as_any None Whether to serialize fields with duck-typing serialization behavior. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/rio_tiler/models/#model_dump_json_3","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    context: 'dict[str, Any] | None' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: \"bool | Literal[('none', 'warn', 'error')]\" = True,\n    serialize_as_any: 'bool' = False\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. None exclude None Field(s) to exclude from the JSON output. None context None Additional context to pass to the serializer. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that are set to their default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None If True, dumped values should be valid as input for non-idempotent types such as Json[T]. None warnings None How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\"error\" raises a [<code>PydanticSerializationError</code>][pydantic_core.PydanticSerializationError]. None serialize_as_any None Whether to serialize fields with duck-typing serialization behavior. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/rio_tiler/models/#model_post_init_3","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/rio_tiler/models/#spatialinfo","title":"SpatialInfo","text":"<pre><code>class SpatialInfo(\n    /,\n    **data: 'Any'\n)\n</code></pre> <p>Dataset SpatialInfo</p>"},{"location":"api/rio_tiler/models/#ancestors-in-mro_4","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.models.Bounds</li> <li>rio_tiler.models.RioTilerBaseModel</li> <li>pydantic.main.BaseModel</li> </ul>"},{"location":"api/rio_tiler/models/#descendants_2","title":"Descendants","text":"<ul> <li>rio_tiler.models.Info</li> </ul>"},{"location":"api/rio_tiler/models/#class-variables_4","title":"Class variables","text":"<pre><code>model_computed_fields\n</code></pre> <pre><code>model_config\n</code></pre> <pre><code>model_fields\n</code></pre>"},{"location":"api/rio_tiler/models/#static-methods_6","title":"Static methods","text":""},{"location":"api/rio_tiler/models/#construct_4","title":"construct","text":"<pre><code>def construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#from_orm_4","title":"from_orm","text":"<pre><code>def from_orm(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#model_construct_4","title":"model_construct","text":"<pre><code>def model_construct(\n    _fields_set: 'set[str] | None' = None,\n    **values: 'Any'\n) -&gt; 'Model'\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>Parameters:</p> Name Type Description Default _fields_set None The set of field names accepted for the Model instance. None values None Trusted or pre-validated data dictionary. None <p>Returns:</p> Type Description None A new instance of the <code>Model</code> class with validated data."},{"location":"api/rio_tiler/models/#model_json_schema_4","title":"model_json_schema","text":"<pre><code>def model_json_schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    schema_generator: 'type[GenerateJsonSchema]' = &lt;class 'pydantic.json_schema.GenerateJsonSchema'&gt;,\n    mode: 'JsonSchemaMode' = 'validation'\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>Parameters:</p> Name Type Description Default by_alias None Whether to use attribute aliases or not. None ref_template None The reference template. None schema_generator None To override the logic used to generate the JSON schema, as a subclass of<code>GenerateJsonSchema</code> with your desired modifications None mode None The mode in which to generate the schema. None <p>Returns:</p> Type Description None The JSON schema for the given model class."},{"location":"api/rio_tiler/models/#model_parametrized_name_4","title":"model_parametrized_name","text":"<pre><code>def model_parametrized_name(\n    params: 'tuple[type[Any], ...]'\n) -&gt; 'str'\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>Parameters:</p> Name Type Description Default params None Tuple of types of the class. Given a generic class<code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>,the value <code>(str, int)</code> would be passed to <code>params</code>. None <p>Returns:</p> Type Description None String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables. <p>Raises:</p> Type Description TypeError Raised when trying to generate concrete names for non-generic models."},{"location":"api/rio_tiler/models/#model_rebuild_4","title":"model_rebuild","text":"<pre><code>def model_rebuild(\n    *,\n    force: 'bool' = False,\n    raise_errors: 'bool' = True,\n    _parent_namespace_depth: 'int' = 2,\n    _types_namespace: 'dict[str, Any] | None' = None\n) -&gt; 'bool | None'\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>Parameters:</p> Name Type Description Default force None Whether to force the rebuilding of the model schema, defaults to <code>False</code>. None raise_errors None Whether to raise errors, defaults to <code>True</code>. None _parent_namespace_depth None The depth level of the parent namespace, defaults to 2. None _types_namespace None The types namespace, defaults to <code>None</code>. None <p>Returns:</p> Type Description None Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required.If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>."},{"location":"api/rio_tiler/models/#model_validate_4","title":"model_validate","text":"<pre><code>def model_validate(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    from_attributes: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate a pydantic model instance.</p> <p>Parameters:</p> Name Type Description Default obj None The object to validate. None strict None Whether to enforce types strictly. None from_attributes None Whether to extract data from object attributes. None context None Additional context to pass to the validator. None <p>Returns:</p> Type Description None The validated model instance. <p>Raises:</p> Type Description ValidationError If the object could not be validated."},{"location":"api/rio_tiler/models/#model_validate_json_4","title":"model_validate_json","text":"<pre><code>def model_validate_json(\n    json_data: 'str | bytes | bytearray',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/json/#json-parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default json_data None The JSON data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model. <p>Raises:</p> Type Description ValueError If <code>json_data</code> is not a JSON string."},{"location":"api/rio_tiler/models/#model_validate_strings_4","title":"model_validate_strings","text":"<pre><code>def model_validate_strings(\n    obj: 'Any',\n    *,\n    strict: 'bool | None' = None,\n    context: 'dict[str, Any] | None' = None\n) -&gt; 'Model'\n</code></pre> <p>Validate the given object contains string data against the Pydantic model.</p> <p>Parameters:</p> Name Type Description Default obj None The object contains string data to validate. None strict None Whether to enforce types strictly. None context None Extra variables to pass to the validator. None <p>Returns:</p> Type Description None The validated Pydantic model."},{"location":"api/rio_tiler/models/#parse_file_4","title":"parse_file","text":"<pre><code>def parse_file(\n    path: 'str | Path',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#parse_obj_4","title":"parse_obj","text":"<pre><code>def parse_obj(\n    obj: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#parse_raw_4","title":"parse_raw","text":"<pre><code>def parse_raw(\n    b: 'str | bytes',\n    *,\n    content_type: 'str | None' = None,\n    encoding: 'str' = 'utf8',\n    proto: 'DeprecatedParseProtocol | None' = None,\n    allow_pickle: 'bool' = False\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#schema_4","title":"schema","text":"<pre><code>def schema(\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}'\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/rio_tiler/models/#schema_json_4","title":"schema_json","text":"<pre><code>def schema_json(\n    *,\n    by_alias: 'bool' = True,\n    ref_template: 'str' = '#/$defs/{model}',\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/rio_tiler/models/#update_forward_refs_4","title":"update_forward_refs","text":"<pre><code>def update_forward_refs(\n    **localns: 'Any'\n) -&gt; 'None'\n</code></pre>"},{"location":"api/rio_tiler/models/#validate_4","title":"validate","text":"<pre><code>def validate(\n    value: 'Any'\n) -&gt; 'Model'\n</code></pre>"},{"location":"api/rio_tiler/models/#instance-variables_6","title":"Instance variables","text":"<pre><code>model_extra\n</code></pre> <p>Get extra fields set during validation.</p> <pre><code>model_fields_set\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p>"},{"location":"api/rio_tiler/models/#methods_6","title":"Methods","text":""},{"location":"api/rio_tiler/models/#copy_4","title":"copy","text":"<pre><code>def copy(\n    self: 'Model',\n    *,\n    include: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None,\n    update: 'typing.Dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Returns a copy of the model.</p> <p>Deprecated</p> <p>This method is now deprecated; use <code>model_copy</code> instead.</p> <p>If you need <code>include</code> or <code>exclude</code>, use:</p> <pre><code>data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n</code></pre> <p>Parameters:</p> Name Type Description Default include None Optional set or mapping specifying which fields to include in the copied model. None exclude None Optional set or mapping specifying which fields to exclude in the copied model. None update None Optional dictionary of field-value pairs to override field values in the copied model. None deep None If True, the values of fields that are Pydantic models will be deep-copied. None <p>Returns:</p> Type Description None A copy of the model with included, excluded and updated fields as specified."},{"location":"api/rio_tiler/models/#dict_4","title":"dict","text":"<pre><code>def dict(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False\n) -&gt; 'typing.Dict[str, Any]'\n</code></pre>"},{"location":"api/rio_tiler/models/#json_4","title":"json","text":"<pre><code>def json(\n    self,\n    *,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    encoder: 'typing.Callable[[Any], Any] | None' = PydanticUndefined,\n    models_as_dict: 'bool' = PydanticUndefined,\n    **dumps_kwargs: 'Any'\n) -&gt; 'str'\n</code></pre>"},{"location":"api/rio_tiler/models/#model_copy_4","title":"model_copy","text":"<pre><code>def model_copy(\n    self: 'Model',\n    *,\n    update: 'dict[str, Any] | None' = None,\n    deep: 'bool' = False\n) -&gt; 'Model'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/serialization/#model_copy</p> <p>Returns a copy of the model.</p> <p>Parameters:</p> Name Type Description Default update None Values to change/add in the new model. Note: the data is not validatedbefore creating the new model. You should trust this data. None deep None Set to <code>True</code> to make a deep copy of the model. None <p>Returns:</p> Type Description None New model instance."},{"location":"api/rio_tiler/models/#model_dump_4","title":"model_dump","text":"<pre><code>def model_dump(\n    self,\n    *,\n    mode: \"Literal[('json', 'python')] | str\" = 'python',\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    context: 'dict[str, Any] | None' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: \"bool | Literal[('none', 'warn', 'error')]\" = True,\n    serialize_as_any: 'bool' = False\n) -&gt; 'dict[str, Any]'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/serialization/#modelmodel_dump</p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Parameters:</p> Name Type Description Default mode None The mode in which <code>to_python</code> should run.If mode is 'json', the output will only contain JSON serializable types.If mode is 'python', the output may contain non-JSON-serializable Python objects. None include None A set of fields to include in the output. None exclude None A set of fields to exclude from the output. None context None Additional context to pass to the serializer. None by_alias None Whether to use the field's alias in the dictionary key if defined. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that are set to their default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None If True, dumped values should be valid as input for non-idempotent types such as Json[T]. None warnings None How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\"error\" raises a [<code>PydanticSerializationError</code>][pydantic_core.PydanticSerializationError]. None serialize_as_any None Whether to serialize fields with duck-typing serialization behavior. None <p>Returns:</p> Type Description None A dictionary representation of the model."},{"location":"api/rio_tiler/models/#model_dump_json_4","title":"model_dump_json","text":"<pre><code>def model_dump_json(\n    self,\n    *,\n    indent: 'int | None' = None,\n    include: 'IncEx' = None,\n    exclude: 'IncEx' = None,\n    context: 'dict[str, Any] | None' = None,\n    by_alias: 'bool' = False,\n    exclude_unset: 'bool' = False,\n    exclude_defaults: 'bool' = False,\n    exclude_none: 'bool' = False,\n    round_trip: 'bool' = False,\n    warnings: \"bool | Literal[('none', 'warn', 'error')]\" = True,\n    serialize_as_any: 'bool' = False\n) -&gt; 'str'\n</code></pre> <p>Usage docs: docs.pydantic.dev/2.7/concepts/serialization/#modelmodel_dump_json</p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>Parameters:</p> Name Type Description Default indent None Indentation to use in the JSON output. If None is passed, the output will be compact. None include None Field(s) to include in the JSON output. None exclude None Field(s) to exclude from the JSON output. None context None Additional context to pass to the serializer. None by_alias None Whether to serialize using field aliases. None exclude_unset None Whether to exclude fields that have not been explicitly set. None exclude_defaults None Whether to exclude fields that are set to their default value. None exclude_none None Whether to exclude fields that have a value of <code>None</code>. None round_trip None If True, dumped values should be valid as input for non-idempotent types such as Json[T]. None warnings None How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\"error\" raises a [<code>PydanticSerializationError</code>][pydantic_core.PydanticSerializationError]. None serialize_as_any None Whether to serialize fields with duck-typing serialization behavior. None <p>Returns:</p> Type Description None A JSON string representation of the model."},{"location":"api/rio_tiler/models/#model_post_init_4","title":"model_post_init","text":"<pre><code>def model_post_init(\n    self,\n    _BaseModel__context: 'Any'\n) -&gt; 'None'\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>.</p> <p>This is useful if you want to do some validation that requires the entire model to be initialized.</p>"},{"location":"api/rio_tiler/profiles/","title":"Module rio_tiler.profiles","text":"<p>Image file profiles.</p>"},{"location":"api/rio_tiler/profiles/#variables","title":"Variables","text":"<pre><code>img_profiles\n</code></pre>"},{"location":"api/rio_tiler/profiles/#classes","title":"Classes","text":""},{"location":"api/rio_tiler/profiles/#imagesprofiles","title":"ImagesProfiles","text":"<pre><code>class ImagesProfiles(\n\n)\n</code></pre> <p>GDAL Image creation options.</p> <p>ref: github.com/mapnik/mapnik/wiki/Image-IO#default-output-details.</p>"},{"location":"api/rio_tiler/profiles/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>collections.UserDict</li> <li>collections.abc.MutableMapping</li> <li>collections.abc.Mapping</li> <li>collections.abc.Collection</li> <li>collections.abc.Sized</li> <li>collections.abc.Iterable</li> <li>collections.abc.Container</li> </ul>"},{"location":"api/rio_tiler/profiles/#static-methods","title":"Static methods","text":""},{"location":"api/rio_tiler/profiles/#fromkeys","title":"fromkeys","text":"<pre><code>def fromkeys(\n    iterable,\n    value=None\n)\n</code></pre>"},{"location":"api/rio_tiler/profiles/#methods","title":"Methods","text":""},{"location":"api/rio_tiler/profiles/#clear","title":"clear","text":"<pre><code>def clear(\n    self\n)\n</code></pre> <p>D.clear() -&gt; None.  Remove all items from D.</p>"},{"location":"api/rio_tiler/profiles/#copy","title":"copy","text":"<pre><code>def copy(\n    self\n)\n</code></pre>"},{"location":"api/rio_tiler/profiles/#get","title":"get","text":"<pre><code>def get(\n    self,\n    key,\n    default=None\n)\n</code></pre> <p>Like normal item access but return a copy of the key.</p>"},{"location":"api/rio_tiler/profiles/#items","title":"items","text":"<pre><code>def items(\n    self\n)\n</code></pre> <p>D.items() -&gt; a set-like object providing a view on D's items</p>"},{"location":"api/rio_tiler/profiles/#keys","title":"keys","text":"<pre><code>def keys(\n    self\n)\n</code></pre> <p>D.keys() -&gt; a set-like object providing a view on D's keys</p>"},{"location":"api/rio_tiler/profiles/#pop","title":"pop","text":"<pre><code>def pop(\n    self,\n    key,\n    default=&lt;object object at 0x7f5b32447150&gt;\n)\n</code></pre> <p>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.</p> <p>If key is not found, d is returned if given, otherwise KeyError is raised.</p>"},{"location":"api/rio_tiler/profiles/#popitem","title":"popitem","text":"<pre><code>def popitem(\n    self\n)\n</code></pre> <p>D.popitem() -&gt; (k, v), remove and return some (key, value) pair</p> <p>as a 2-tuple; but raise KeyError if D is empty.</p>"},{"location":"api/rio_tiler/profiles/#setdefault","title":"setdefault","text":"<pre><code>def setdefault(\n    self,\n    key,\n    default=None\n)\n</code></pre> <p>D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</p>"},{"location":"api/rio_tiler/profiles/#update","title":"update","text":"<pre><code>def update(\n    self,\n    other=(),\n    /,\n    **kwds\n)\n</code></pre> <p>D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.</p> <p>If E present and has a .keys() method, does:     for k in E: D[k] = E[k] If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v</p>"},{"location":"api/rio_tiler/profiles/#values","title":"values","text":"<pre><code>def values(\n    self\n)\n</code></pre> <p>D.values() -&gt; an object providing a view on D's values</p>"},{"location":"api/rio_tiler/profiles/#jpegprofile","title":"JPEGProfile","text":"<pre><code>class JPEGProfile(\n    data={},\n    **kwds\n)\n</code></pre> <p>JPEG creation options ref: www.gdal.org/frmt_jpeg.html.</p>"},{"location":"api/rio_tiler/profiles/#ancestors-in-mro_1","title":"Ancestors (in MRO)","text":"<ul> <li>rasterio.profiles.Profile</li> <li>collections.UserDict</li> <li>collections.abc.MutableMapping</li> <li>collections.abc.Mapping</li> <li>collections.abc.Collection</li> <li>collections.abc.Sized</li> <li>collections.abc.Iterable</li> <li>collections.abc.Container</li> </ul>"},{"location":"api/rio_tiler/profiles/#class-variables","title":"Class variables","text":"<pre><code>defaults\n</code></pre>"},{"location":"api/rio_tiler/profiles/#static-methods_1","title":"Static methods","text":""},{"location":"api/rio_tiler/profiles/#fromkeys_1","title":"fromkeys","text":"<pre><code>def fromkeys(\n    iterable,\n    value=None\n)\n</code></pre>"},{"location":"api/rio_tiler/profiles/#methods_1","title":"Methods","text":""},{"location":"api/rio_tiler/profiles/#clear_1","title":"clear","text":"<pre><code>def clear(\n    self\n)\n</code></pre> <p>D.clear() -&gt; None.  Remove all items from D.</p>"},{"location":"api/rio_tiler/profiles/#copy_1","title":"copy","text":"<pre><code>def copy(\n    self\n)\n</code></pre>"},{"location":"api/rio_tiler/profiles/#get_1","title":"get","text":"<pre><code>def get(\n    self,\n    key,\n    default=None\n)\n</code></pre> <p>D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.</p>"},{"location":"api/rio_tiler/profiles/#items_1","title":"items","text":"<pre><code>def items(\n    self\n)\n</code></pre> <p>D.items() -&gt; a set-like object providing a view on D's items</p>"},{"location":"api/rio_tiler/profiles/#keys_1","title":"keys","text":"<pre><code>def keys(\n    self\n)\n</code></pre> <p>D.keys() -&gt; a set-like object providing a view on D's keys</p>"},{"location":"api/rio_tiler/profiles/#pop_1","title":"pop","text":"<pre><code>def pop(\n    self,\n    key,\n    default=&lt;object object at 0x7f5b32447150&gt;\n)\n</code></pre> <p>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.</p> <p>If key is not found, d is returned if given, otherwise KeyError is raised.</p>"},{"location":"api/rio_tiler/profiles/#popitem_1","title":"popitem","text":"<pre><code>def popitem(\n    self\n)\n</code></pre> <p>D.popitem() -&gt; (k, v), remove and return some (key, value) pair</p> <p>as a 2-tuple; but raise KeyError if D is empty.</p>"},{"location":"api/rio_tiler/profiles/#setdefault_1","title":"setdefault","text":"<pre><code>def setdefault(\n    self,\n    key,\n    default=None\n)\n</code></pre> <p>D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</p>"},{"location":"api/rio_tiler/profiles/#update_1","title":"update","text":"<pre><code>def update(\n    self,\n    other=(),\n    /,\n    **kwds\n)\n</code></pre> <p>D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.</p> <p>If E present and has a .keys() method, does:     for k in E: D[k] = E[k] If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v</p>"},{"location":"api/rio_tiler/profiles/#values_1","title":"values","text":"<pre><code>def values(\n    self\n)\n</code></pre> <p>D.values() -&gt; an object providing a view on D's values</p>"},{"location":"api/rio_tiler/profiles/#pngprofile","title":"PNGProfile","text":"<pre><code>class PNGProfile(\n    data={},\n    **kwds\n)\n</code></pre> <p>PNG creation options ref: www.gdal.org/frmt_png.html.</p>"},{"location":"api/rio_tiler/profiles/#ancestors-in-mro_2","title":"Ancestors (in MRO)","text":"<ul> <li>rasterio.profiles.Profile</li> <li>collections.UserDict</li> <li>collections.abc.MutableMapping</li> <li>collections.abc.Mapping</li> <li>collections.abc.Collection</li> <li>collections.abc.Sized</li> <li>collections.abc.Iterable</li> <li>collections.abc.Container</li> </ul>"},{"location":"api/rio_tiler/profiles/#class-variables_1","title":"Class variables","text":"<pre><code>defaults\n</code></pre>"},{"location":"api/rio_tiler/profiles/#static-methods_2","title":"Static methods","text":""},{"location":"api/rio_tiler/profiles/#fromkeys_2","title":"fromkeys","text":"<pre><code>def fromkeys(\n    iterable,\n    value=None\n)\n</code></pre>"},{"location":"api/rio_tiler/profiles/#methods_2","title":"Methods","text":""},{"location":"api/rio_tiler/profiles/#clear_2","title":"clear","text":"<pre><code>def clear(\n    self\n)\n</code></pre> <p>D.clear() -&gt; None.  Remove all items from D.</p>"},{"location":"api/rio_tiler/profiles/#copy_2","title":"copy","text":"<pre><code>def copy(\n    self\n)\n</code></pre>"},{"location":"api/rio_tiler/profiles/#get_2","title":"get","text":"<pre><code>def get(\n    self,\n    key,\n    default=None\n)\n</code></pre> <p>D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.</p>"},{"location":"api/rio_tiler/profiles/#items_2","title":"items","text":"<pre><code>def items(\n    self\n)\n</code></pre> <p>D.items() -&gt; a set-like object providing a view on D's items</p>"},{"location":"api/rio_tiler/profiles/#keys_2","title":"keys","text":"<pre><code>def keys(\n    self\n)\n</code></pre> <p>D.keys() -&gt; a set-like object providing a view on D's keys</p>"},{"location":"api/rio_tiler/profiles/#pop_2","title":"pop","text":"<pre><code>def pop(\n    self,\n    key,\n    default=&lt;object object at 0x7f5b32447150&gt;\n)\n</code></pre> <p>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.</p> <p>If key is not found, d is returned if given, otherwise KeyError is raised.</p>"},{"location":"api/rio_tiler/profiles/#popitem_2","title":"popitem","text":"<pre><code>def popitem(\n    self\n)\n</code></pre> <p>D.popitem() -&gt; (k, v), remove and return some (key, value) pair</p> <p>as a 2-tuple; but raise KeyError if D is empty.</p>"},{"location":"api/rio_tiler/profiles/#setdefault_2","title":"setdefault","text":"<pre><code>def setdefault(\n    self,\n    key,\n    default=None\n)\n</code></pre> <p>D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</p>"},{"location":"api/rio_tiler/profiles/#update_2","title":"update","text":"<pre><code>def update(\n    self,\n    other=(),\n    /,\n    **kwds\n)\n</code></pre> <p>D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.</p> <p>If E present and has a .keys() method, does:     for k in E: D[k] = E[k] If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v</p>"},{"location":"api/rio_tiler/profiles/#values_2","title":"values","text":"<pre><code>def values(\n    self\n)\n</code></pre> <p>D.values() -&gt; an object providing a view on D's values</p>"},{"location":"api/rio_tiler/profiles/#pngrawprofile","title":"PNGRAWProfile","text":"<pre><code>class PNGRAWProfile(\n    data={},\n    **kwds\n)\n</code></pre> <p>PNG creation options ref: www.gdal.org/frmt_png.html.</p>"},{"location":"api/rio_tiler/profiles/#ancestors-in-mro_3","title":"Ancestors (in MRO)","text":"<ul> <li>rasterio.profiles.Profile</li> <li>collections.UserDict</li> <li>collections.abc.MutableMapping</li> <li>collections.abc.Mapping</li> <li>collections.abc.Collection</li> <li>collections.abc.Sized</li> <li>collections.abc.Iterable</li> <li>collections.abc.Container</li> </ul>"},{"location":"api/rio_tiler/profiles/#class-variables_2","title":"Class variables","text":"<pre><code>defaults\n</code></pre>"},{"location":"api/rio_tiler/profiles/#static-methods_3","title":"Static methods","text":""},{"location":"api/rio_tiler/profiles/#fromkeys_3","title":"fromkeys","text":"<pre><code>def fromkeys(\n    iterable,\n    value=None\n)\n</code></pre>"},{"location":"api/rio_tiler/profiles/#methods_3","title":"Methods","text":""},{"location":"api/rio_tiler/profiles/#clear_3","title":"clear","text":"<pre><code>def clear(\n    self\n)\n</code></pre> <p>D.clear() -&gt; None.  Remove all items from D.</p>"},{"location":"api/rio_tiler/profiles/#copy_3","title":"copy","text":"<pre><code>def copy(\n    self\n)\n</code></pre>"},{"location":"api/rio_tiler/profiles/#get_3","title":"get","text":"<pre><code>def get(\n    self,\n    key,\n    default=None\n)\n</code></pre> <p>D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.</p>"},{"location":"api/rio_tiler/profiles/#items_3","title":"items","text":"<pre><code>def items(\n    self\n)\n</code></pre> <p>D.items() -&gt; a set-like object providing a view on D's items</p>"},{"location":"api/rio_tiler/profiles/#keys_3","title":"keys","text":"<pre><code>def keys(\n    self\n)\n</code></pre> <p>D.keys() -&gt; a set-like object providing a view on D's keys</p>"},{"location":"api/rio_tiler/profiles/#pop_3","title":"pop","text":"<pre><code>def pop(\n    self,\n    key,\n    default=&lt;object object at 0x7f5b32447150&gt;\n)\n</code></pre> <p>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.</p> <p>If key is not found, d is returned if given, otherwise KeyError is raised.</p>"},{"location":"api/rio_tiler/profiles/#popitem_3","title":"popitem","text":"<pre><code>def popitem(\n    self\n)\n</code></pre> <p>D.popitem() -&gt; (k, v), remove and return some (key, value) pair</p> <p>as a 2-tuple; but raise KeyError if D is empty.</p>"},{"location":"api/rio_tiler/profiles/#setdefault_3","title":"setdefault","text":"<pre><code>def setdefault(\n    self,\n    key,\n    default=None\n)\n</code></pre> <p>D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</p>"},{"location":"api/rio_tiler/profiles/#update_3","title":"update","text":"<pre><code>def update(\n    self,\n    other=(),\n    /,\n    **kwds\n)\n</code></pre> <p>D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.</p> <p>If E present and has a .keys() method, does:     for k in E: D[k] = E[k] If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v</p>"},{"location":"api/rio_tiler/profiles/#values_3","title":"values","text":"<pre><code>def values(\n    self\n)\n</code></pre> <p>D.values() -&gt; an object providing a view on D's values</p>"},{"location":"api/rio_tiler/profiles/#webpprofile","title":"WEBPProfile","text":"<pre><code>class WEBPProfile(\n    data={},\n    **kwds\n)\n</code></pre> <p>WEBP creation options ref: www.gdal.org/frmt_webp.html.</p>"},{"location":"api/rio_tiler/profiles/#ancestors-in-mro_4","title":"Ancestors (in MRO)","text":"<ul> <li>rasterio.profiles.Profile</li> <li>collections.UserDict</li> <li>collections.abc.MutableMapping</li> <li>collections.abc.Mapping</li> <li>collections.abc.Collection</li> <li>collections.abc.Sized</li> <li>collections.abc.Iterable</li> <li>collections.abc.Container</li> </ul>"},{"location":"api/rio_tiler/profiles/#class-variables_3","title":"Class variables","text":"<pre><code>defaults\n</code></pre>"},{"location":"api/rio_tiler/profiles/#static-methods_4","title":"Static methods","text":""},{"location":"api/rio_tiler/profiles/#fromkeys_4","title":"fromkeys","text":"<pre><code>def fromkeys(\n    iterable,\n    value=None\n)\n</code></pre>"},{"location":"api/rio_tiler/profiles/#methods_4","title":"Methods","text":""},{"location":"api/rio_tiler/profiles/#clear_4","title":"clear","text":"<pre><code>def clear(\n    self\n)\n</code></pre> <p>D.clear() -&gt; None.  Remove all items from D.</p>"},{"location":"api/rio_tiler/profiles/#copy_4","title":"copy","text":"<pre><code>def copy(\n    self\n)\n</code></pre>"},{"location":"api/rio_tiler/profiles/#get_4","title":"get","text":"<pre><code>def get(\n    self,\n    key,\n    default=None\n)\n</code></pre> <p>D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.</p>"},{"location":"api/rio_tiler/profiles/#items_4","title":"items","text":"<pre><code>def items(\n    self\n)\n</code></pre> <p>D.items() -&gt; a set-like object providing a view on D's items</p>"},{"location":"api/rio_tiler/profiles/#keys_4","title":"keys","text":"<pre><code>def keys(\n    self\n)\n</code></pre> <p>D.keys() -&gt; a set-like object providing a view on D's keys</p>"},{"location":"api/rio_tiler/profiles/#pop_4","title":"pop","text":"<pre><code>def pop(\n    self,\n    key,\n    default=&lt;object object at 0x7f5b32447150&gt;\n)\n</code></pre> <p>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.</p> <p>If key is not found, d is returned if given, otherwise KeyError is raised.</p>"},{"location":"api/rio_tiler/profiles/#popitem_4","title":"popitem","text":"<pre><code>def popitem(\n    self\n)\n</code></pre> <p>D.popitem() -&gt; (k, v), remove and return some (key, value) pair</p> <p>as a 2-tuple; but raise KeyError if D is empty.</p>"},{"location":"api/rio_tiler/profiles/#setdefault_4","title":"setdefault","text":"<pre><code>def setdefault(\n    self,\n    key,\n    default=None\n)\n</code></pre> <p>D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</p>"},{"location":"api/rio_tiler/profiles/#update_4","title":"update","text":"<pre><code>def update(\n    self,\n    other=(),\n    /,\n    **kwds\n)\n</code></pre> <p>D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.</p> <p>If E present and has a .keys() method, does:     for k in E: D[k] = E[k] If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v</p>"},{"location":"api/rio_tiler/profiles/#values_4","title":"values","text":"<pre><code>def values(\n    self\n)\n</code></pre> <p>D.values() -&gt; an object providing a view on D's values</p>"},{"location":"api/rio_tiler/reader/","title":"Module rio_tiler.reader","text":"<p>rio-tiler.reader: low level reader.</p>"},{"location":"api/rio_tiler/reader/#variables","title":"Variables","text":"<pre><code>WGS84_CRS\n</code></pre>"},{"location":"api/rio_tiler/reader/#functions","title":"Functions","text":""},{"location":"api/rio_tiler/reader/#part","title":"part","text":"<pre><code>def part(\n    src_dst: Union[rasterio.io.DatasetReader, rasterio.io.DatasetWriter, rasterio.vrt.WarpedVRT],\n    bounds: Tuple[float, float, float, float],\n    height: Union[int, NoneType] = None,\n    width: Union[int, NoneType] = None,\n    max_size: Union[int, NoneType] = None,\n    dst_crs: Union[rasterio.crs.CRS, NoneType] = None,\n    bounds_crs: Union[rasterio.crs.CRS, NoneType] = None,\n    indexes: Union[Sequence[int], int, NoneType] = None,\n    minimum_overlap: Union[float, NoneType] = None,\n    padding: Union[int, NoneType] = None,\n    buffer: Union[float, NoneType] = None,\n    force_binary_mask: bool = True,\n    nodata: Union[float, int, str, NoneType] = None,\n    vrt_options: Union[Dict, NoneType] = None,\n    align_bounds_with_dataset: bool = False,\n    resampling_method: Literal['nearest', 'bilinear', 'cubic', 'cubic_spline', 'lanczos', 'average', 'mode', 'gauss', 'rms'] = 'nearest',\n    reproject_method: Literal['nearest', 'bilinear', 'cubic', 'cubic_spline', 'lanczos', 'average', 'mode', 'sum', 'rms'] = 'nearest',\n    unscale: bool = False,\n    post_process: Union[Callable[[numpy.ma.core.MaskedArray], numpy.ma.core.MaskedArray], NoneType] = None\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read part of a dataset.</p> <p>Parameters:</p> Name Type Description Default src_dst rasterio.io.DatasetReader or rasterio.io.DatasetWriter or rasterio.vrt.WarpedVRT Rasterio dataset. None bounds tuple Output bounds (left, bottom, right, top). By default the coordinates are considered to be in either the dataset CRS or in the <code>dst_crs</code> if set. Use <code>bounds_crs</code> to set a specific CRS. None height int Output height of the image. None width int Output width of the image. None max_size int Limit output size image if not width and height. None dst_crs rasterio.crs.CRS Target coordinate reference system. None bounds_crs rasterio.crs.CRS Overwrite bounds Coordinate Reference System. None indexes sequence of int or int Band indexes. None minimum_overlap float Minimum % overlap for which to raise an error with dataset not covering enough of the tile. None padding int Padding to apply to each bbox edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code>. <code>0</code> buffer float Buffer to apply to each bbox edge. Defaults to <code>0.</code>. <code>0.</code> nodata int or float Overwrite dataset internal nodata value. None vrt_options dict Options to be passed to the rasterio.warp.WarpedVRT class. None align_bounds_with_dataset bool Align input bounds with dataset transform. Defaults to <code>False</code>. <code>False</code> resampling_method RIOResampling RasterIO resampling algorithm. Defaults to <code>nearest</code>. <code>nearest</code> reproject_method WarpResampling WarpKernel resampling algorithm. Defaults to <code>nearest</code>. <code>nearest</code> unscale bool Apply 'scales' and 'offsets' on output data value. Defaults to <code>False</code>. <code>False</code> post_process callable Function to apply on output data and mask values. None <p>Returns:</p> Type Description None ImageData"},{"location":"api/rio_tiler/reader/#point","title":"point","text":"<pre><code>def point(\n    src_dst: Union[rasterio.io.DatasetReader, rasterio.io.DatasetWriter, rasterio.vrt.WarpedVRT],\n    coordinates: Tuple[float, float],\n    indexes: Union[Sequence[int], int, NoneType] = None,\n    coord_crs: rasterio.crs.CRS = CRS.from_epsg(4326),\n    force_binary_mask: bool = True,\n    nodata: Union[float, int, str, NoneType] = None,\n    vrt_options: Union[Dict, NoneType] = None,\n    resampling_method: Literal['nearest', 'bilinear', 'cubic', 'cubic_spline', 'lanczos', 'average', 'mode', 'gauss', 'rms'] = 'nearest',\n    reproject_method: Literal['nearest', 'bilinear', 'cubic', 'cubic_spline', 'lanczos', 'average', 'mode', 'sum', 'rms'] = 'nearest',\n    unscale: bool = False,\n    post_process: Union[Callable[[numpy.ma.core.MaskedArray], numpy.ma.core.MaskedArray], NoneType] = None\n) -&gt; rio_tiler.models.PointData\n</code></pre> <p>Read a pixel value for a point.</p> <p>Parameters:</p> Name Type Description Default src_dst rasterio.io.DatasetReader or rasterio.io.DatasetWriter or rasterio.vrt.WarpedVRT Rasterio dataset. None coordinates tuple Coordinates in form of (X, Y). None indexes sequence of int or int Band indexes. None coord_crs rasterio.crs.CRS Coordinate Reference System of the input coords. Defaults to <code>epsg:4326</code>. <code>epsg:4326</code> nodata int or float Overwrite dataset internal nodata value. None vrt_options dict Options to be passed to the rasterio.warp.WarpedVRT class. None resampling_method RIOResampling RasterIO resampling algorithm. Defaults to <code>nearest</code>. <code>nearest</code> reproject_method WarpResampling WarpKernel resampling algorithm. Defaults to <code>nearest</code>. <code>nearest</code> unscale bool Apply 'scales' and 'offsets' on output data value. Defaults to <code>False</code>. <code>False</code> post_process callable Function to apply on output data and mask values. None <p>Returns:</p> Type Description None PointData"},{"location":"api/rio_tiler/reader/#read","title":"read","text":"<pre><code>def read(\n    src_dst: Union[rasterio.io.DatasetReader, rasterio.io.DatasetWriter, rasterio.vrt.WarpedVRT],\n    dst_crs: Union[rasterio.crs.CRS, NoneType] = None,\n    height: Union[int, NoneType] = None,\n    width: Union[int, NoneType] = None,\n    max_size: Union[int, NoneType] = None,\n    indexes: Union[Sequence[int], int, NoneType] = None,\n    window: Union[rasterio.windows.Window, NoneType] = None,\n    force_binary_mask: bool = True,\n    nodata: Union[float, int, str, NoneType] = None,\n    vrt_options: Union[Dict, NoneType] = None,\n    resampling_method: Literal['nearest', 'bilinear', 'cubic', 'cubic_spline', 'lanczos', 'average', 'mode', 'gauss', 'rms'] = 'nearest',\n    reproject_method: Literal['nearest', 'bilinear', 'cubic', 'cubic_spline', 'lanczos', 'average', 'mode', 'sum', 'rms'] = 'nearest',\n    unscale: bool = False,\n    post_process: Union[Callable[[numpy.ma.core.MaskedArray], numpy.ma.core.MaskedArray], NoneType] = None\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Low level read function.</p> <p>Parameters:</p> Name Type Description Default src_dst rasterio.io.DatasetReader or rasterio.io.DatasetWriter or rasterio.vrt.WarpedVRT Rasterio dataset. None dst_crs rasterio.crs.CRS Target coordinate reference system. None height int Output height of the image. None width int Output width of the image. None max_size int Limit output size image if not width and height. None indexes sequence of int or int Band indexes. None window rasterio.windows.Window Window to read. None nodata int or float Overwrite dataset internal nodata value. None vrt_options dict Options to be passed to the rasterio.warp.WarpedVRT class. None resampling_method RIOResampling RasterIO resampling algorithm. Defaults to <code>nearest</code>. <code>nearest</code> reproject_method WarpResampling WarpKernel resampling algorithm. Defaults to <code>nearest</code>. <code>nearest</code> force_binary_mask bool Cast returned mask to binary values (0 or 255). Defaults to <code>True</code>. <code>True</code> unscale bool Apply 'scales' and 'offsets' on output data value. Defaults to <code>False</code>. <code>False</code> post_process callable Function to apply on output data and mask values. None <p>Returns:</p> Type Description None ImageData"},{"location":"api/rio_tiler/reader/#classes","title":"Classes","text":""},{"location":"api/rio_tiler/reader/#options","title":"Options","text":"<pre><code>class Options(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Reader Options.</p>"},{"location":"api/rio_tiler/reader/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>builtins.dict</li> </ul>"},{"location":"api/rio_tiler/reader/#methods","title":"Methods","text":""},{"location":"api/rio_tiler/reader/#clear","title":"clear","text":"<pre><code>def clear(\n    ...\n)\n</code></pre> <p>D.clear() -&gt; None.  Remove all items from D.</p>"},{"location":"api/rio_tiler/reader/#copy","title":"copy","text":"<pre><code>def copy(\n    ...\n)\n</code></pre> <p>D.copy() -&gt; a shallow copy of D</p>"},{"location":"api/rio_tiler/reader/#fromkeys","title":"fromkeys","text":"<pre><code>def fromkeys(\n    iterable,\n    value=None,\n    /\n)\n</code></pre> <p>Create a new dictionary with keys from iterable and values set to value.</p>"},{"location":"api/rio_tiler/reader/#get","title":"get","text":"<pre><code>def get(\n    self,\n    key,\n    default=None,\n    /\n)\n</code></pre> <p>Return the value for key if key is in the dictionary, else default.</p>"},{"location":"api/rio_tiler/reader/#items","title":"items","text":"<pre><code>def items(\n    ...\n)\n</code></pre> <p>D.items() -&gt; a set-like object providing a view on D's items</p>"},{"location":"api/rio_tiler/reader/#keys","title":"keys","text":"<pre><code>def keys(\n    ...\n)\n</code></pre> <p>D.keys() -&gt; a set-like object providing a view on D's keys</p>"},{"location":"api/rio_tiler/reader/#pop","title":"pop","text":"<pre><code>def pop(\n    ...\n)\n</code></pre> <p>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.</p> <p>If key is not found, d is returned if given, otherwise KeyError is raised</p>"},{"location":"api/rio_tiler/reader/#popitem","title":"popitem","text":"<pre><code>def popitem(\n    self,\n    /\n)\n</code></pre> <p>Remove and return a (key, value) pair as a 2-tuple.</p> <p>Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty.</p>"},{"location":"api/rio_tiler/reader/#setdefault","title":"setdefault","text":"<pre><code>def setdefault(\n    self,\n    key,\n    default=None,\n    /\n)\n</code></pre> <p>Insert key with a value of default if key is not in the dictionary.</p> <p>Return the value for key if key is in the dictionary, else default.</p>"},{"location":"api/rio_tiler/reader/#update","title":"update","text":"<pre><code>def update(\n    ...\n)\n</code></pre> <p>D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.</p> <p>If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v In either case, this is followed by: for k in F:  D[k] = F[k]</p>"},{"location":"api/rio_tiler/reader/#values","title":"values","text":"<pre><code>def values(\n    ...\n)\n</code></pre> <p>D.values() -&gt; an object providing a view on D's values</p>"},{"location":"api/rio_tiler/tasks/","title":"Module rio_tiler.tasks","text":"<p>rio_tiler.tasks: tools for handling rio-tiler's future tasks.</p>"},{"location":"api/rio_tiler/tasks/#variables","title":"Variables","text":"<pre><code>MAX_THREADS\n</code></pre> <pre><code>TaskType\n</code></pre>"},{"location":"api/rio_tiler/tasks/#functions","title":"Functions","text":""},{"location":"api/rio_tiler/tasks/#create_tasks","title":"create_tasks","text":"<pre><code>def create_tasks(\n    reader: Callable,\n    asset_list: Sequence,\n    threads: int,\n    *args,\n    **kwargs\n) -&gt; Sequence[Tuple[Union[concurrent.futures._base.Future, Callable], Any]]\n</code></pre> <p>Create Future Tasks.</p>"},{"location":"api/rio_tiler/tasks/#filter_tasks","title":"filter_tasks","text":"<pre><code>def filter_tasks(\n    tasks: Sequence[Tuple[Union[concurrent.futures._base.Future, Callable], Any]],\n    allowed_exceptions: Union[Tuple, NoneType] = None\n) -&gt; Generator\n</code></pre> <p>Filter Tasks to remove Exceptions.</p> <p>Parameters:</p> Name Type Description Default tasks sequence Sequence of 'concurrent.futures._base.Future' or 'Callable' None allowed_exceptions tuple List of exceptions which won't be raised. None <p>Yields:</p> Type Description None Task results."},{"location":"api/rio_tiler/tasks/#multi_arrays","title":"multi_arrays","text":"<pre><code>def multi_arrays(\n    asset_list: Sequence,\n    reader: Callable[..., rio_tiler.models.ImageData],\n    *args: Any,\n    threads: int = 20,\n    allowed_exceptions: Union[Tuple, NoneType] = None,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Merge arrays returned from tasks.</p>"},{"location":"api/rio_tiler/tasks/#multi_points","title":"multi_points","text":"<pre><code>def multi_points(\n    asset_list: Sequence,\n    reader: Callable[..., rio_tiler.models.PointData],\n    *args: Any,\n    threads: int = 20,\n    allowed_exceptions: Union[Tuple, NoneType] = None,\n    **kwargs: Any\n) -&gt; rio_tiler.models.PointData\n</code></pre> <p>Merge points returned from tasks.</p>"},{"location":"api/rio_tiler/tasks/#multi_values","title":"multi_values","text":"<pre><code>def multi_values(\n    asset_list: Sequence,\n    reader: Callable,\n    *args: Any,\n    threads: int = 20,\n    allowed_exceptions: Union[Tuple, NoneType] = None,\n    **kwargs: Any\n) -&gt; Dict\n</code></pre> <p>Merge values returned from tasks.</p>"},{"location":"api/rio_tiler/utils/","title":"Module rio_tiler.utils","text":"<p>rio_tiler.utils: utility functions.</p>"},{"location":"api/rio_tiler/utils/#variables","title":"Variables","text":"<pre><code>WEB_MERCATOR_CRS\n</code></pre> <pre><code>WGS84_CRS\n</code></pre>"},{"location":"api/rio_tiler/utils/#functions","title":"Functions","text":""},{"location":"api/rio_tiler/utils/#create_cutline","title":"create_cutline","text":"<pre><code>def create_cutline(\n    src_dst: Union[rasterio.io.DatasetReader, rasterio.io.DatasetWriter, rasterio.vrt.WarpedVRT],\n    geometry: Dict,\n    geometry_crs: rasterio.crs.CRS = None\n) -&gt; str\n</code></pre> <p>Create WKT Polygon Cutline for GDALWarpOptions.</p> <p>Ref: gdal.org/api/gdalwarp_cpp.html?highlight=vrt#_CPPv415GDALWarpOptions</p> <p>Parameters:</p> Name Type Description Default src_dst rasterio.io.DatasetReader or rasterio.io.DatasetWriter or rasterio.vrt.WarpedVRT Rasterio dataset. None geometry dict GeoJSON feature or GeoJSON geometry. By default the coordinates are considered to be in the dataset CRS. Use <code>geometry_crs</code> to set a specific CRS. None geometry_crs rasterio.crs.CRS Input geometry Coordinate Reference System None <p>Returns:</p> Type Description str WKT geometry in form of `POLYGON ((x y, x y, ...)))"},{"location":"api/rio_tiler/utils/#get_array_statistics","title":"get_array_statistics","text":"<pre><code>def get_array_statistics(\n    data: numpy.ma.core.MaskedArray,\n    categorical: bool = False,\n    categories: Union[List[float], NoneType] = None,\n    percentiles: Union[List[int], NoneType] = None,\n    coverage: Union[numpy.ndarray[Any, numpy.dtype[numpy.floating]], NoneType] = None,\n    **kwargs: Any\n) -&gt; List[Dict[Any, Any]]\n</code></pre> <p>Calculate per band array statistics.</p> <p>Parameters:</p> Name Type Description Default data numpy.ma.MaskedArray input masked array data to get the statistics from. None categorical bool treat input data as categorical data. Defaults to <code>False</code>. <code>False</code> categories list of numbers list of categories to return value for. None percentiles list of numbers list of percentile values to calculate. Defaults to <code>[2, 98]</code>. <code>[2, 98]</code> coverage numpy.array Data coverage fraction. None kwargs optional options to forward to <code>numpy.histogram</code> function (only applies for non-categorical data). None <p>Returns:</p> Type Description list list of array statistics (dict)"},{"location":"api/rio_tiler/utils/#get_overview_level","title":"get_overview_level","text":"<pre><code>def get_overview_level(\n    src_dst: Union[rasterio.io.DatasetReader, rasterio.io.DatasetWriter, rasterio.vrt.WarpedVRT],\n    bounds: Tuple[float, float, float, float],\n    height: int,\n    width: int,\n    dst_crs: rasterio.crs.CRS = CRS.from_epsg(3857)\n) -&gt; int\n</code></pre> <p>Return the overview level corresponding to the tile resolution.</p> <p>Freely adapted from github.com/OSGeo/gdal/blob/41993f127e6e1669fbd9e944744b7c9b2bd6c400/gdal/apps/gdalwarp_lib.cpp#L2293-L2362</p> <p>Parameters:</p> Name Type Description Default src_dst rasterio.io.DatasetReader or rasterio.io.DatasetWriter or rasterio.vrt.WarpedVRT Rasterio dataset. None bounds tuple Bounding box coordinates in target crs (dst_crs). None height int Desired output height of the array for the input bounds. None width int Desired output width of the array for the input bounds. None dst_crs rasterio.crs.CRS Target Coordinate Reference System. Defaults to <code>epsg:3857</code>. <code>epsg:3857</code> <p>Returns:</p> Type Description int Overview level."},{"location":"api/rio_tiler/utils/#get_vrt_transform","title":"get_vrt_transform","text":"<pre><code>def get_vrt_transform(\n    src_dst: Union[rasterio.io.DatasetReader, rasterio.io.DatasetWriter, rasterio.vrt.WarpedVRT],\n    bounds: Tuple[float, float, float, float],\n    height: Union[int, NoneType] = None,\n    width: Union[int, NoneType] = None,\n    dst_crs: rasterio.crs.CRS = CRS.from_epsg(3857),\n    window_precision: int = 6,\n    align_bounds_with_dataset: bool = False\n) -&gt; Tuple[affine.Affine, int, int]\n</code></pre> <p>Calculate VRT transform.</p> <p>Parameters:</p> Name Type Description Default src_dst rasterio.io.DatasetReader or rasterio.io.DatasetWriter or rasterio.vrt.WarpedVRT Rasterio dataset. None bounds tuple Bounding box coordinates in target crs (dst_crs). None height int Output height of the array for the input bounds. None width int Output width of the array for the input bounds. None dst_crs rasterio.crs.CRS Target Coordinate Reference System. Defaults to <code>epsg:3857</code>. <code>epsg:3857</code> align_bounds_with_dataset bool Align input bounds with dataset transform. Defaults to <code>False</code>. <code>False</code> <p>Returns:</p> Type Description tuple VRT transform (affine.Affine), width (int) and height (int)"},{"location":"api/rio_tiler/utils/#has_alpha_band","title":"has_alpha_band","text":"<pre><code>def has_alpha_band(\n    src_dst: Union[rasterio.io.DatasetReader, rasterio.io.DatasetWriter, rasterio.vrt.WarpedVRT]\n) -&gt; bool\n</code></pre> <p>Check for alpha band or mask in source.</p>"},{"location":"api/rio_tiler/utils/#has_mask_band","title":"has_mask_band","text":"<pre><code>def has_mask_band(\n    src_dst: Union[rasterio.io.DatasetReader, rasterio.io.DatasetWriter, rasterio.vrt.WarpedVRT]\n) -&gt; bool\n</code></pre> <p>Check for mask band in source.</p>"},{"location":"api/rio_tiler/utils/#linear_rescale","title":"linear_rescale","text":"<pre><code>def linear_rescale(\n    image: numpy.ndarray,\n    in_range: Tuple[Union[float, int], Union[float, int]],\n    out_range: Tuple[Union[float, int], Union[float, int]] = (0, 255)\n) -&gt; numpy.ndarray\n</code></pre> <p>Apply linear rescaling to a numpy array.</p> <p>Parameters:</p> Name Type Description Default image numpy.ndarray array to rescale. None in_range tuple array min/max value to rescale from. None out_range tuple output min/max bounds to rescale to. Defaults to <code>(0, 255)</code>. <code>(0, 255)</code> <p>Returns:</p> Type Description numpy.ndarray linear rescaled array."},{"location":"api/rio_tiler/utils/#mapzen_elevation_rgb","title":"mapzen_elevation_rgb","text":"<pre><code>def mapzen_elevation_rgb(\n    data: numpy.ndarray\n) -&gt; numpy.ndarray\n</code></pre> <p>Encode elevation value to RGB values compatible with Mapzen tangram.</p> <p>Parameters:</p> Name Type Description Default data numpy.ndarray Image array to encode. None"},{"location":"api/rio_tiler/utils/#non_alpha_indexes","title":"non_alpha_indexes","text":"<pre><code>def non_alpha_indexes(\n    src_dst: Union[rasterio.io.DatasetReader, rasterio.io.DatasetWriter, rasterio.vrt.WarpedVRT]\n) -&gt; Tuple\n</code></pre> <p>Return indexes of non-alpha bands.</p>"},{"location":"api/rio_tiler/utils/#normalize_bounds","title":"normalize_bounds","text":"<pre><code>def normalize_bounds(\n    bounds: Tuple[float, float, float, float]\n) -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Return BBox in correct minx, miny, maxx, maxy order.</p>"},{"location":"api/rio_tiler/utils/#pansharpening_brovey","title":"pansharpening_brovey","text":"<pre><code>def pansharpening_brovey(\n    rgb: numpy.ndarray,\n    pan: numpy.ndarray,\n    weight: float,\n    pan_dtype: str\n) -&gt; numpy.ndarray\n</code></pre> <p>Apply Brovey pansharpening method.</p> <p>Brovey Method: Each resampled, multispectral pixel is multiplied by the ratio of the corresponding panchromatic pixel intensity to the sum of all the multispectral intensities.</p> <p>Original code from mapbox/rio-pansharpen</p>"},{"location":"api/rio_tiler/utils/#render","title":"render","text":"<pre><code>def render(\n    data: numpy.ndarray,\n    mask: Union[numpy.ndarray, NoneType] = None,\n    img_format: str = 'PNG',\n    colormap: Union[Dict[int, Tuple[int, int, int, int]], Sequence[Tuple[Tuple[Union[float, int], Union[float, int]], Tuple[int, int, int, int]]], NoneType] = None,\n    **creation_options: Any\n) -&gt; bytes\n</code></pre> <p>Translate numpy.ndarray to image bytes.</p> <p>Parameters:</p> Name Type Description Default data numpy.ndarray Image array to encode. None mask numpy.ndarray Mask array. None img_format str Image format. See: for the list of supported format by GDAL: www.gdal.org/formats_list.html. Defaults to <code>PNG</code>. <code>PNG</code> colormap dict or sequence RGBA Color Table dictionary or sequence. None creation_options optional Image driver creation options to forward to GDAL. None"},{"location":"api/rio_tiler/utils/#resize_array","title":"resize_array","text":"<pre><code>def resize_array(\n    data: numpy.ndarray,\n    height: int,\n    width: int,\n    resampling_method: Literal['nearest', 'bilinear', 'cubic', 'cubic_spline', 'lanczos', 'average', 'mode', 'gauss', 'rms'] = 'nearest'\n) -&gt; numpy.ndarray\n</code></pre> <p>resize array to a given height and width.</p>"},{"location":"api/rio_tiler/io/base/","title":"Module rio_tiler.io.base","text":"<p>rio_tiler.io.base: ABC class for rio-tiler readers.</p>"},{"location":"api/rio_tiler/io/base/#variables","title":"Variables","text":"<pre><code>WGS84_CRS\n</code></pre>"},{"location":"api/rio_tiler/io/base/#classes","title":"Classes","text":""},{"location":"api/rio_tiler/io/base/#basereader","title":"BaseReader","text":"<pre><code>class BaseReader(\n    input: Any,\n    tms: morecantile.models.TileMatrixSet = &lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;\n)\n</code></pre> <p>Rio-tiler.io BaseReader.</p>"},{"location":"api/rio_tiler/io/base/#attributes","title":"Attributes","text":"Name Type Description Default input any Reader's input. None tms morecantile.TileMatrixSet TileMatrixSet grid definition. Defaults to <code>WebMercatorQuad</code>. <code>WebMercatorQuad</code>"},{"location":"api/rio_tiler/io/base/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.io.base.SpatialMixin</li> </ul>"},{"location":"api/rio_tiler/io/base/#descendants","title":"Descendants","text":"<ul> <li>rio_tiler.io.rasterio.Reader</li> <li>rio_tiler.io.xarray.XarrayReader</li> </ul>"},{"location":"api/rio_tiler/io/base/#methods","title":"Methods","text":""},{"location":"api/rio_tiler/io/base/#feature","title":"feature","text":"<pre><code>def feature(\n    self,\n    shape: Dict\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read a Dataset for a GeoJSON feature.</p> <p>Parameters:</p> Name Type Description Default shape dict Valid GeoJSON feature. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and input spatial info."},{"location":"api/rio_tiler/io/base/#geographic_bounds","title":"geographic_bounds","text":"<pre><code>def geographic_bounds(\n    ...\n)\n</code></pre> <p>Return dataset bounds in geographic_crs.</p>"},{"location":"api/rio_tiler/io/base/#info","title":"info","text":"<pre><code>def info(\n    self\n) -&gt; rio_tiler.models.Info\n</code></pre> <p>Return Dataset's info.</p> <p>Returns:</p> Type Description rio_tile.models.Info Dataset info."},{"location":"api/rio_tiler/io/base/#part","title":"part","text":"<pre><code>def part(\n    self,\n    bbox: Tuple[float, float, float, float]\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read a Part of a Dataset.</p> <p>Parameters:</p> Name Type Description Default bbox tuple Output bounds (left, bottom, right, top) in target crs. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and input spatial info."},{"location":"api/rio_tiler/io/base/#point","title":"point","text":"<pre><code>def point(\n    self,\n    lon: float,\n    lat: float\n) -&gt; rio_tiler.models.PointData\n</code></pre> <p>Read a value from a Dataset.</p> <p>Parameters:</p> Name Type Description Default lon float Longitude. None lat float Latitude. None <p>Returns:</p> Type Description rio_tiler.models.PointData PointData instance with data, mask and spatial info."},{"location":"api/rio_tiler/io/base/#preview","title":"preview","text":"<pre><code>def preview(\n    self\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read a preview of a Dataset.</p> <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and input spatial info."},{"location":"api/rio_tiler/io/base/#statistics","title":"statistics","text":"<pre><code>def statistics(\n    self\n) -&gt; Dict[str, rio_tiler.models.BandStatistics]\n</code></pre> <p>Return bands statistics from a dataset.</p> <p>Returns:</p> Type Description Dict[str, rio_tiler.models.BandStatistics] bands statistics."},{"location":"api/rio_tiler/io/base/#tile","title":"tile","text":"<pre><code>def tile(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read a Map tile from the Dataset.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/base/#tile_exists","title":"tile_exists","text":"<pre><code>def tile_exists(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int\n) -&gt; bool\n</code></pre> <p>Check if a tile intersects the dataset bounds.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None <p>Returns:</p> Type Description bool True if the tile intersects the dataset bounds."},{"location":"api/rio_tiler/io/base/#multibandreader","title":"MultiBandReader","text":"<pre><code>class MultiBandReader(\n    input: Any,\n    tms: morecantile.models.TileMatrixSet = &lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;,\n    minzoom: int = None,\n    maxzoom: int = None,\n    reader_options: Dict = NOTHING\n)\n</code></pre> <p>Multi Band Reader.</p> <p>This Abstract Base Class Reader is suited for dataset that stores spectral bands as separate files  (e.g. Sentinel 2).</p>"},{"location":"api/rio_tiler/io/base/#attributes_1","title":"Attributes","text":"Name Type Description Default input any input data. None tms morecantile.TileMatrixSet TileMatrixSet grid definition. Defaults to <code>WebMercatorQuad</code>. <code>WebMercatorQuad</code> minzoom int Set dataset's minzoom. None maxzoom int Set dataset's maxzoom. None reader_options dict, option options to forward to the reader. Defaults to <code>{}</code>. <code>{}</code>"},{"location":"api/rio_tiler/io/base/#ancestors-in-mro_1","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.io.base.SpatialMixin</li> </ul>"},{"location":"api/rio_tiler/io/base/#methods_1","title":"Methods","text":""},{"location":"api/rio_tiler/io/base/#feature_1","title":"feature","text":"<pre><code>def feature(\n    self,\n    shape: Dict,\n    bands: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge parts defined by geojson feature from multiple bands.</p> <p>Parameters:</p> Name Type Description Default shape dict Valid GeoJSON feature. None bands sequence of str or str bands to fetch info from. None expression str rio-tiler expression for the band list (e.g. b1/b2+b3). None kwargs optional Options to forward to the <code>self.reader.feature</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/base/#geographic_bounds_1","title":"geographic_bounds","text":"<pre><code>def geographic_bounds(\n    ...\n)\n</code></pre> <p>Return dataset bounds in geographic_crs.</p>"},{"location":"api/rio_tiler/io/base/#info_1","title":"info","text":"<pre><code>def info(\n    self,\n    bands: Union[Sequence[str], str] = None,\n    *args,\n    **kwargs: Any\n) -&gt; rio_tiler.models.Info\n</code></pre> <p>Return metadata from multiple bands.</p> <p>Parameters:</p> Name Type Description Default bands sequence of str or str band names to fetch info from. Required keyword argument. None <p>Returns:</p> Type Description dict Multiple bands info in form of {\"band1\": rio_tile.models.Info}."},{"location":"api/rio_tiler/io/base/#parse_expression","title":"parse_expression","text":"<pre><code>def parse_expression(\n    self,\n    expression: str\n) -&gt; Tuple\n</code></pre> <p>Parse rio-tiler band math expression.</p>"},{"location":"api/rio_tiler/io/base/#part_1","title":"part","text":"<pre><code>def part(\n    self,\n    bbox: Tuple[float, float, float, float],\n    bands: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge parts from multiple bands.</p> <p>Parameters:</p> Name Type Description Default bbox tuple Output bounds (left, bottom, right, top) in target crs. None bands sequence of str or str bands to fetch info from. None expression str rio-tiler expression for the band list (e.g. b1/b2+b3). None kwargs optional Options to forward to the 'self.reader.part' method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/base/#point_1","title":"point","text":"<pre><code>def point(\n    self,\n    lon: float,\n    lat: float,\n    bands: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    **kwargs: Any\n) -&gt; rio_tiler.models.PointData\n</code></pre> <p>Read a pixel values from multiple bands.</p> <p>Parameters:</p> Name Type Description Default lon float Longitude. None lat float Latitude. None bands sequence of str or str bands to fetch info from. None expression str rio-tiler expression for the band list (e.g. b1/b2+b3). None kwargs optional Options to forward to the <code>self.reader.point</code> method. None <p>Returns:</p> Type Description None PointData"},{"location":"api/rio_tiler/io/base/#preview_1","title":"preview","text":"<pre><code>def preview(\n    self,\n    bands: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge previews from multiple bands.</p> <p>Parameters:</p> Name Type Description Default bands sequence of str or str bands to fetch info from. None expression str rio-tiler expression for the band list (e.g. b1/b2+b3). None kwargs optional Options to forward to the <code>self.reader.preview</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/base/#statistics_1","title":"statistics","text":"<pre><code>def statistics(\n    self,\n    bands: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    categorical: bool = False,\n    categories: Union[List[float], NoneType] = None,\n    percentiles: Union[List[int], NoneType] = None,\n    hist_options: Union[Dict, NoneType] = None,\n    max_size: int = 1024,\n    **kwargs: Any\n) -&gt; Dict[str, rio_tiler.models.BandStatistics]\n</code></pre> <p>Return array statistics for multiple assets.</p> <p>Parameters:</p> Name Type Description Default bands sequence of str or str bands to fetch info from. Required keyword argument. None expression str rio-tiler expression for the band list (e.g. b1/b2+b3). None categorical bool treat input data as categorical data. Defaults to False. False categories list of numbers list of categories to return value for. None percentiles list of numbers list of percentile values to calculate. Defaults to <code>[2, 98]</code>. <code>[2, 98]</code> hist_options dict Options to forward to numpy.histogram function. None max_size int Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to 1024. 1024 kwargs optional Options to forward to the <code>self.preview</code> method. None <p>Returns:</p> Type Description dict Multiple assets statistics in form of {\"{band}/{expression}\": rio_tiler.models.BandStatistics, ...}."},{"location":"api/rio_tiler/io/base/#tile_1","title":"tile","text":"<pre><code>def tile(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int,\n    bands: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge Web Map tiles multiple bands.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None bands sequence of str or str bands to fetch info from. None expression str rio-tiler expression for the band list (e.g. b1/b2+b3). None kwargs optional Options to forward to the <code>self.reader.tile</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/base/#tile_exists_1","title":"tile_exists","text":"<pre><code>def tile_exists(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int\n) -&gt; bool\n</code></pre> <p>Check if a tile intersects the dataset bounds.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None <p>Returns:</p> Type Description bool True if the tile intersects the dataset bounds."},{"location":"api/rio_tiler/io/base/#multibasereader","title":"MultiBaseReader","text":"<pre><code>class MultiBaseReader(\n    input: Any,\n    tms: morecantile.models.TileMatrixSet = &lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;,\n    minzoom: int = None,\n    maxzoom: int = None,\n    reader_options: Dict = NOTHING\n)\n</code></pre> <p>MultiBaseReader Reader.</p> <p>This Abstract Base Class Reader is suited for dataset that are composed of multiple assets (e.g. STAC).</p>"},{"location":"api/rio_tiler/io/base/#attributes_2","title":"Attributes","text":"Name Type Description Default input any input data. None tms morecantile.TileMatrixSet TileMatrixSet grid definition. Defaults to <code>WebMercatorQuad</code>. <code>WebMercatorQuad</code> minzoom int Set dataset's minzoom. None maxzoom int Set dataset's maxzoom. None reader_options dict, option options to forward to the reader. Defaults to <code>{}</code>. <code>{}</code>"},{"location":"api/rio_tiler/io/base/#ancestors-in-mro_2","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.io.base.SpatialMixin</li> </ul>"},{"location":"api/rio_tiler/io/base/#descendants_1","title":"Descendants","text":"<ul> <li>rio_tiler.io.stac.STACReader</li> </ul>"},{"location":"api/rio_tiler/io/base/#methods_2","title":"Methods","text":""},{"location":"api/rio_tiler/io/base/#feature_2","title":"feature","text":"<pre><code>def feature(\n    self,\n    shape: Dict,\n    assets: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    asset_indexes: Union[Dict[str, Union[Sequence[int], int]], NoneType] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge parts defined by geojson feature from multiple assets.</p> <p>Parameters:</p> Name Type Description Default shape dict Valid GeoJSON feature. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.feature</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/base/#geographic_bounds_2","title":"geographic_bounds","text":"<pre><code>def geographic_bounds(\n    ...\n)\n</code></pre> <p>Return dataset bounds in geographic_crs.</p>"},{"location":"api/rio_tiler/io/base/#info_2","title":"info","text":"<pre><code>def info(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    **kwargs: Any\n) -&gt; Dict[str, rio_tiler.models.Info]\n</code></pre> <p>Return metadata from multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. Required keyword argument. None <p>Returns:</p> Type Description dict Multiple assets info in form of {\"asset1\": rio_tile.models.Info}."},{"location":"api/rio_tiler/io/base/#merged_statistics","title":"merged_statistics","text":"<pre><code>def merged_statistics(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    asset_indexes: Union[Dict[str, Union[Sequence[int], int]], NoneType] = None,\n    categorical: bool = False,\n    categories: Union[List[float], NoneType] = None,\n    percentiles: Union[List[int], NoneType] = None,\n    hist_options: Union[Dict, NoneType] = None,\n    max_size: int = 1024,\n    **kwargs: Any\n) -&gt; Dict[str, rio_tiler.models.BandStatistics]\n</code></pre> <p>Return array statistics for multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None categorical bool treat input data as categorical data. Defaults to False. False categories list of numbers list of categories to return value for. None percentiles list of numbers list of percentile values to calculate. Defaults to <code>[2, 98]</code>. <code>[2, 98]</code> hist_options dict Options to forward to numpy.histogram function. None max_size int Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to 1024. 1024 kwargs optional Options to forward to the <code>self.preview</code> method. None <p>Returns:</p> Type Description Dict[str, rio_tiler.models.BandStatistics] bands statistics."},{"location":"api/rio_tiler/io/base/#parse_expression_1","title":"parse_expression","text":"<pre><code>def parse_expression(\n    self,\n    expression: str,\n    asset_as_band: bool = False\n) -&gt; Tuple\n</code></pre> <p>Parse rio-tiler band math expression.</p>"},{"location":"api/rio_tiler/io/base/#part_2","title":"part","text":"<pre><code>def part(\n    self,\n    bbox: Tuple[float, float, float, float],\n    assets: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    asset_indexes: Union[Dict[str, Union[Sequence[int], int]], NoneType] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge parts from multiple assets.</p> <p>Parameters:</p> Name Type Description Default bbox tuple Output bounds (left, bottom, right, top) in target crs. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.part</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/base/#point_2","title":"point","text":"<pre><code>def point(\n    self,\n    lon: float,\n    lat: float,\n    assets: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    asset_indexes: Union[Dict[str, Union[Sequence[int], int]], NoneType] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.PointData\n</code></pre> <p>Read pixel value from multiple assets.</p> <p>Parameters:</p> Name Type Description Default lon float Longitude. None lat float Latitude. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.point</code> method. None <p>Returns:</p> Type Description None PointData"},{"location":"api/rio_tiler/io/base/#preview_2","title":"preview","text":"<pre><code>def preview(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    asset_indexes: Union[Dict[str, Union[Sequence[int], int]], NoneType] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge previews from multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.preview</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/base/#statistics_2","title":"statistics","text":"<pre><code>def statistics(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    asset_indexes: Union[Dict[str, Union[Sequence[int], int]], NoneType] = None,\n    asset_expression: Union[Dict[str, str], NoneType] = None,\n    **kwargs: Any\n) -&gt; Dict[str, Dict[str, rio_tiler.models.BandStatistics]]\n</code></pre> <p>Return array statistics for multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None asset_expression dict rio-tiler expression for each asset (e.g. {\"asset1\": \"b1/b2+b3\", \"asset2\": ...}). None kwargs optional Options to forward to the <code>self.reader.statistics</code> method. None <p>Returns:</p> Type Description dict Multiple assets statistics in form of {\"asset1\": {\"1\": rio_tiler.models.BandStatistics, ...}}."},{"location":"api/rio_tiler/io/base/#tile_2","title":"tile","text":"<pre><code>def tile(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int,\n    assets: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    asset_indexes: Union[Dict[str, Union[Sequence[int], int]], NoneType] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge Wep Map tiles from multiple assets.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.tile</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/base/#tile_exists_2","title":"tile_exists","text":"<pre><code>def tile_exists(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int\n) -&gt; bool\n</code></pre> <p>Check if a tile intersects the dataset bounds.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None <p>Returns:</p> Type Description bool True if the tile intersects the dataset bounds."},{"location":"api/rio_tiler/io/base/#spatialmixin","title":"SpatialMixin","text":"<pre><code>class SpatialMixin(\n    tms: morecantile.models.TileMatrixSet = &lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;\n)\n</code></pre> <p>Spatial Info Mixin.</p>"},{"location":"api/rio_tiler/io/base/#attributes_3","title":"Attributes","text":"Name Type Description Default tms morecantile.TileMatrixSet TileMatrixSet grid definition. Defaults to <code>WebMercatorQuad</code>. <code>WebMercatorQuad</code>"},{"location":"api/rio_tiler/io/base/#descendants_2","title":"Descendants","text":"<ul> <li>rio_tiler.io.base.BaseReader</li> <li>rio_tiler.io.base.MultiBaseReader</li> <li>rio_tiler.io.base.MultiBandReader</li> </ul>"},{"location":"api/rio_tiler/io/base/#methods_3","title":"Methods","text":""},{"location":"api/rio_tiler/io/base/#geographic_bounds_3","title":"geographic_bounds","text":"<pre><code>def geographic_bounds(\n    ...\n)\n</code></pre> <p>Return dataset bounds in geographic_crs.</p>"},{"location":"api/rio_tiler/io/base/#tile_exists_3","title":"tile_exists","text":"<pre><code>def tile_exists(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int\n) -&gt; bool\n</code></pre> <p>Check if a tile intersects the dataset bounds.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None <p>Returns:</p> Type Description bool True if the tile intersects the dataset bounds."},{"location":"api/rio_tiler/io/rasterio/","title":"Module rio_tiler.io.rasterio","text":"<p>rio_tiler.io.rasterio: rio-tiler reader built on top Rasterio</p>"},{"location":"api/rio_tiler/io/rasterio/#variables","title":"Variables","text":"<pre><code>WGS84_CRS\n</code></pre>"},{"location":"api/rio_tiler/io/rasterio/#classes","title":"Classes","text":""},{"location":"api/rio_tiler/io/rasterio/#imagereader","title":"ImageReader","text":"<pre><code>class ImageReader(\n    input: str,\n    dataset: Union[rasterio.io.DatasetReader, rasterio.io.DatasetWriter, rasterio.io.MemoryFile, rasterio.vrt.WarpedVRT] = None,\n    colormap: Dict = None,\n    options: rio_tiler.reader.Options = NOTHING\n)\n</code></pre> <p>Non Geo Image Reader</p>"},{"location":"api/rio_tiler/io/rasterio/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.io.rasterio.Reader</li> <li>rio_tiler.io.base.BaseReader</li> <li>rio_tiler.io.base.SpatialMixin</li> </ul>"},{"location":"api/rio_tiler/io/rasterio/#instance-variables","title":"Instance variables","text":"<pre><code>maxzoom\n</code></pre> <p>Return dataset maxzoom.</p> <pre><code>minzoom\n</code></pre> <p>Return dataset minzoom.</p>"},{"location":"api/rio_tiler/io/rasterio/#methods","title":"Methods","text":""},{"location":"api/rio_tiler/io/rasterio/#close","title":"close","text":"<pre><code>def close(\n    self\n)\n</code></pre> <p>Close rasterio dataset.</p>"},{"location":"api/rio_tiler/io/rasterio/#feature","title":"feature","text":"<pre><code>def feature(\n    self,\n    shape: Dict,\n    indexes: Union[Sequence[int], int, NoneType] = None,\n    expression: Union[str, NoneType] = None,\n    max_size: Union[int, NoneType] = None,\n    height: Union[int, NoneType] = None,\n    width: Union[int, NoneType] = None,\n    force_binary_mask: bool = True,\n    resampling_method: Literal['nearest', 'bilinear', 'cubic', 'cubic_spline', 'lanczos', 'average', 'mode', 'gauss', 'rms'] = 'nearest',\n    unscale: bool = False,\n    post_process: Union[Callable[[numpy.ma.core.MaskedArray], numpy.ma.core.MaskedArray], NoneType] = None\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read part of an Image defined by a geojson feature.</p>"},{"location":"api/rio_tiler/io/rasterio/#geographic_bounds","title":"geographic_bounds","text":"<pre><code>def geographic_bounds(\n    ...\n)\n</code></pre> <p>Return dataset bounds in geographic_crs.</p>"},{"location":"api/rio_tiler/io/rasterio/#get_maxzoom","title":"get_maxzoom","text":"<pre><code>def get_maxzoom(\n    self\n) -&gt; int\n</code></pre> <p>Define dataset maximum zoom level.</p>"},{"location":"api/rio_tiler/io/rasterio/#get_minzoom","title":"get_minzoom","text":"<pre><code>def get_minzoom(\n    self\n) -&gt; int\n</code></pre> <p>Define dataset minimum zoom level.</p>"},{"location":"api/rio_tiler/io/rasterio/#info","title":"info","text":"<pre><code>def info(\n    self\n) -&gt; rio_tiler.models.Info\n</code></pre> <p>Return Dataset info.</p>"},{"location":"api/rio_tiler/io/rasterio/#part","title":"part","text":"<pre><code>def part(\n    self,\n    bbox: Tuple[float, float, float, float],\n    indexes: Union[int, Sequence, NoneType] = None,\n    expression: Union[str, NoneType] = None,\n    max_size: Union[int, NoneType] = None,\n    height: Union[int, NoneType] = None,\n    width: Union[int, NoneType] = None,\n    force_binary_mask: bool = True,\n    resampling_method: Literal['nearest', 'bilinear', 'cubic', 'cubic_spline', 'lanczos', 'average', 'mode', 'gauss', 'rms'] = 'nearest',\n    unscale: bool = False,\n    post_process: Union[Callable[[numpy.ma.core.MaskedArray], numpy.ma.core.MaskedArray], NoneType] = None\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read part of an Image.</p> <p>Parameters:</p> Name Type Description Default bbox tuple Output bounds (left, bottom, right, top). None indexes sequence of int or int Band indexes. None expression str rio-tiler expression (e.g. b1/b2+b3). None max_size int Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. None height int Output height of the array. None width int Output width of the array. None force_binary_mask bool Cast returned mask to binary values (0 or 255). Defaults to <code>True</code>. <code>True</code> resampling_method RIOResampling RasterIO resampling algorithm. Defaults to <code>nearest</code>. <code>nearest</code> unscale bool Apply 'scales' and 'offsets' on output data value. Defaults to <code>False</code>. <code>False</code> post_process callable Function to apply on output data and mask values. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and input spatial info."},{"location":"api/rio_tiler/io/rasterio/#point","title":"point","text":"<pre><code>def point(\n    self,\n    x: float,\n    y: float,\n    indexes: Union[Sequence[int], int, NoneType] = None,\n    expression: Union[str, NoneType] = None,\n    unscale: bool = False,\n    post_process: Union[Callable[[numpy.ma.core.MaskedArray], numpy.ma.core.MaskedArray], NoneType] = None\n) -&gt; rio_tiler.models.PointData\n</code></pre> <p>Read a pixel value from an Image.</p> <p>Parameters:</p> Name Type Description Default lon float X coordinate. None lat float Y coordinate. None indexes sequence of int or int Band indexes. None expression str rio-tiler expression (e.g. b1/b2+b3). None unscale bool Apply 'scales' and 'offsets' on output data value. Defaults to <code>False</code>. <code>False</code> post_process callable Function to apply on output data and mask values. None <p>Returns:</p> Type Description None PointData"},{"location":"api/rio_tiler/io/rasterio/#preview","title":"preview","text":"<pre><code>def preview(\n    self,\n    indexes: Union[Sequence[int], int, NoneType] = None,\n    expression: Union[str, NoneType] = None,\n    max_size: int = 1024,\n    height: Union[int, NoneType] = None,\n    width: Union[int, NoneType] = None,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Return a preview of a Dataset.</p> <p>Parameters:</p> Name Type Description Default indexes sequence of int or int Band indexes. None expression str rio-tiler expression (e.g. b1/b2+b3). None max_size int Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to 1024. 1024 height int Output height of the array. None width int Output width of the array. None kwargs optional Options to forward to the <code>self.read</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and input spatial info."},{"location":"api/rio_tiler/io/rasterio/#read","title":"read","text":"<pre><code>def read(\n    self,\n    indexes: Union[Sequence[int], int, NoneType] = None,\n    expression: Union[str, NoneType] = None,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read the Dataset.</p> <p>Parameters:</p> Name Type Description Default indexes sequence of int or int Band indexes. None expression str rio-tiler expression (e.g. b1/b2+b3). None kwargs optional Options to forward to the <code>rio_tiler.reader.read</code> function. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and input spatial info."},{"location":"api/rio_tiler/io/rasterio/#statistics","title":"statistics","text":"<pre><code>def statistics(\n    self,\n    categorical: bool = False,\n    categories: Union[List[float], NoneType] = None,\n    percentiles: Union[List[int], NoneType] = None,\n    hist_options: Union[Dict, NoneType] = None,\n    max_size: int = 1024,\n    indexes: Union[Sequence[int], int, NoneType] = None,\n    expression: Union[str, NoneType] = None,\n    **kwargs: Any\n) -&gt; Dict[str, rio_tiler.models.BandStatistics]\n</code></pre> <p>Return bands statistics from a dataset.</p> <p>Parameters:</p> Name Type Description Default categorical bool treat input data as categorical data. Defaults to False. False categories list of numbers list of categories to return value for. None percentiles list of numbers list of percentile values to calculate. Defaults to <code>[2, 98]</code>. <code>[2, 98]</code> hist_options dict Options to forward to numpy.histogram function. None max_size int Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to 1024. 1024 kwargs optional Options to forward to <code>self.read</code>. None <p>Returns:</p> Type Description Dict[str, rio_tiler.models.BandStatistics] bands statistics."},{"location":"api/rio_tiler/io/rasterio/#tile","title":"tile","text":"<pre><code>def tile(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int,\n    tilesize: int = 256,\n    indexes: Union[Sequence[int], int, NoneType] = None,\n    expression: Union[str, NoneType] = None,\n    force_binary_mask: bool = True,\n    resampling_method: Literal['nearest', 'bilinear', 'cubic', 'cubic_spline', 'lanczos', 'average', 'mode', 'gauss', 'rms'] = 'nearest',\n    unscale: bool = False,\n    post_process: Union[Callable[[numpy.ma.core.MaskedArray], numpy.ma.core.MaskedArray], NoneType] = None\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read a Web Map tile from an Image.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None tilesize int Output image size. Defaults to <code>256</code>. <code>256</code> indexes int or sequence of int Band indexes. None expression str rio-tiler expression (e.g. b1/b2+b3). None force_binary_mask bool Cast returned mask to binary values (0 or 255). Defaults to <code>True</code>. <code>True</code> resampling_method RIOResampling RasterIO resampling algorithm. Defaults to <code>nearest</code>. <code>nearest</code> unscale bool Apply 'scales' and 'offsets' on output data value. Defaults to <code>False</code>. <code>False</code> post_process callable Function to apply on output data and mask values. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/rasterio/#tile_exists","title":"tile_exists","text":"<pre><code>def tile_exists(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int\n) -&gt; bool\n</code></pre> <p>Check if a tile intersects the dataset bounds.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None <p>Returns:</p> Type Description bool True if the tile intersects the dataset bounds."},{"location":"api/rio_tiler/io/rasterio/#localtilematrixset","title":"LocalTileMatrixSet","text":"<pre><code>class LocalTileMatrixSet(\n    width: int,\n    height: int,\n    tile_size: int = 256\n)\n</code></pre> <p>Fake TMS for non-geo image.</p>"},{"location":"api/rio_tiler/io/rasterio/#methods_1","title":"Methods","text":""},{"location":"api/rio_tiler/io/rasterio/#xy_bounds","title":"xy_bounds","text":"<pre><code>def xy_bounds(\n    self,\n    *tile: morecantile.commons.Tile\n) -&gt; morecantile.commons.BoundingBox\n</code></pre> <p>Return the bounding box of the (x, y, z) tile</p>"},{"location":"api/rio_tiler/io/rasterio/#reader","title":"Reader","text":"<pre><code>class Reader(\n    input: str,\n    dataset: Union[rasterio.io.DatasetReader, rasterio.io.DatasetWriter, rasterio.io.MemoryFile, rasterio.vrt.WarpedVRT] = None,\n    tms: morecantile.models.TileMatrixSet = &lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;,\n    geographic_crs: rasterio.crs.CRS = CRS.from_epsg(4326),\n    colormap: Dict = None,\n    options: rio_tiler.reader.Options = NOTHING\n)\n</code></pre> <p>Rasterio Reader.</p>"},{"location":"api/rio_tiler/io/rasterio/#attributes","title":"Attributes","text":"Name Type Description Default input str dataset path. None dataset rasterio.io.DatasetReader or rasterio.io.DatasetWriter or rasterio.vrt.WarpedVRT Rasterio dataset. None tms morecantile.TileMatrixSet TileMatrixSet grid definition. Defaults to <code>WebMercatorQuad</code>. <code>WebMercatorQuad</code> geographic_crs rasterio.crs.CRS CRS to use as geographic coordinate system. Defaults to WGS84. WGS84 colormap dict Overwrite internal colormap. None options dict Options to forward to low-level reader methods. None"},{"location":"api/rio_tiler/io/rasterio/#ancestors-in-mro_1","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.io.base.BaseReader</li> <li>rio_tiler.io.base.SpatialMixin</li> </ul>"},{"location":"api/rio_tiler/io/rasterio/#descendants","title":"Descendants","text":"<ul> <li>rio_tiler.io.rasterio.ImageReader</li> </ul>"},{"location":"api/rio_tiler/io/rasterio/#instance-variables_1","title":"Instance variables","text":"<pre><code>maxzoom\n</code></pre> <p>Return dataset maxzoom.</p> <pre><code>minzoom\n</code></pre> <p>Return dataset minzoom.</p>"},{"location":"api/rio_tiler/io/rasterio/#methods_2","title":"Methods","text":""},{"location":"api/rio_tiler/io/rasterio/#close_1","title":"close","text":"<pre><code>def close(\n    self\n)\n</code></pre> <p>Close rasterio dataset.</p>"},{"location":"api/rio_tiler/io/rasterio/#feature_1","title":"feature","text":"<pre><code>def feature(\n    self,\n    shape: Dict,\n    dst_crs: Union[rasterio.crs.CRS, NoneType] = None,\n    shape_crs: rasterio.crs.CRS = CRS.from_epsg(4326),\n    indexes: Union[Sequence[int], int, NoneType] = None,\n    expression: Union[str, NoneType] = None,\n    max_size: Union[int, NoneType] = None,\n    height: Union[int, NoneType] = None,\n    width: Union[int, NoneType] = None,\n    buffer: Union[float, int, NoneType] = None,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read part of a Dataset defined by a geojson feature.</p> <p>Parameters:</p> Name Type Description Default shape dict Valid GeoJSON feature. None dst_crs rasterio.crs.CRS Overwrite target coordinate reference system. None shape_crs rasterio.crs.CRS Input geojson coordinate reference system. Defaults to <code>epsg:4326</code>. <code>epsg:4326</code> indexes sequence of int or int Band indexes. None expression str rio-tiler expression (e.g. b1/b2+b3). None max_size int Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. None height int Output height of the array. None width int Output width of the array. None buffer int or float Buffer on each side of the given aoi. It must be a multiple of <code>0.5</code>. Output image size will be expanded to <code>output imagesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258). None kwargs optional Options to forward to the <code>Reader.part</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and input spatial info."},{"location":"api/rio_tiler/io/rasterio/#geographic_bounds_1","title":"geographic_bounds","text":"<pre><code>def geographic_bounds(\n    ...\n)\n</code></pre> <p>Return dataset bounds in geographic_crs.</p>"},{"location":"api/rio_tiler/io/rasterio/#get_maxzoom_1","title":"get_maxzoom","text":"<pre><code>def get_maxzoom(\n    self\n) -&gt; int\n</code></pre> <p>Define dataset maximum zoom level.</p>"},{"location":"api/rio_tiler/io/rasterio/#get_minzoom_1","title":"get_minzoom","text":"<pre><code>def get_minzoom(\n    self\n) -&gt; int\n</code></pre> <p>Define dataset minimum zoom level.</p>"},{"location":"api/rio_tiler/io/rasterio/#info_1","title":"info","text":"<pre><code>def info(\n    self\n) -&gt; rio_tiler.models.Info\n</code></pre> <p>Return Dataset info.</p>"},{"location":"api/rio_tiler/io/rasterio/#part_1","title":"part","text":"<pre><code>def part(\n    self,\n    bbox: Tuple[float, float, float, float],\n    dst_crs: Union[rasterio.crs.CRS, NoneType] = None,\n    bounds_crs: rasterio.crs.CRS = CRS.from_epsg(4326),\n    indexes: Union[int, Sequence, NoneType] = None,\n    expression: Union[str, NoneType] = None,\n    max_size: Union[int, NoneType] = None,\n    height: Union[int, NoneType] = None,\n    width: Union[int, NoneType] = None,\n    buffer: Union[float, NoneType] = None,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read part of a Dataset.</p> <p>Parameters:</p> Name Type Description Default bbox tuple Output bounds (left, bottom, right, top) in target crs (\"dst_crs\"). None dst_crs rasterio.crs.CRS Overwrite target coordinate reference system. None bounds_crs rasterio.crs.CRS Bounds Coordinate Reference System. Defaults to <code>epsg:4326</code>. <code>epsg:4326</code> indexes sequence of int or int Band indexes. None expression str rio-tiler expression (e.g. b1/b2+b3). None max_size int Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. None height int Output height of the array. None width int Output width of the array. None buffer float Buffer on each side of the given aoi. It must be a multiple of <code>0.5</code>. Output image size will be expanded to <code>output imagesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258). None kwargs optional Options to forward to the <code>rio_tiler.reader.part</code> function. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and input spatial info."},{"location":"api/rio_tiler/io/rasterio/#point_1","title":"point","text":"<pre><code>def point(\n    self,\n    lon: float,\n    lat: float,\n    coord_crs: rasterio.crs.CRS = CRS.from_epsg(4326),\n    indexes: Union[Sequence[int], int, NoneType] = None,\n    expression: Union[str, NoneType] = None,\n    **kwargs: Any\n) -&gt; rio_tiler.models.PointData\n</code></pre> <p>Read a pixel value from a Dataset.</p> <p>Parameters:</p> Name Type Description Default lon float Longitude. None lat float Latitude. None coord_crs rasterio.crs.CRS Coordinate Reference System of the input coords. Defaults to <code>epsg:4326</code>. <code>epsg:4326</code> indexes sequence of int or int Band indexes. None expression str rio-tiler expression (e.g. b1/b2+b3). None kwargs optional Options to forward to the <code>rio_tiler.reader.point</code> function. None <p>Returns:</p> Type Description None PointData"},{"location":"api/rio_tiler/io/rasterio/#preview_1","title":"preview","text":"<pre><code>def preview(\n    self,\n    indexes: Union[Sequence[int], int, NoneType] = None,\n    expression: Union[str, NoneType] = None,\n    max_size: int = 1024,\n    height: Union[int, NoneType] = None,\n    width: Union[int, NoneType] = None,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Return a preview of a Dataset.</p> <p>Parameters:</p> Name Type Description Default indexes sequence of int or int Band indexes. None expression str rio-tiler expression (e.g. b1/b2+b3). None max_size int Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to 1024. 1024 height int Output height of the array. None width int Output width of the array. None kwargs optional Options to forward to the <code>self.read</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and input spatial info."},{"location":"api/rio_tiler/io/rasterio/#read_1","title":"read","text":"<pre><code>def read(\n    self,\n    indexes: Union[Sequence[int], int, NoneType] = None,\n    expression: Union[str, NoneType] = None,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read the Dataset.</p> <p>Parameters:</p> Name Type Description Default indexes sequence of int or int Band indexes. None expression str rio-tiler expression (e.g. b1/b2+b3). None kwargs optional Options to forward to the <code>rio_tiler.reader.read</code> function. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and input spatial info."},{"location":"api/rio_tiler/io/rasterio/#statistics_1","title":"statistics","text":"<pre><code>def statistics(\n    self,\n    categorical: bool = False,\n    categories: Union[List[float], NoneType] = None,\n    percentiles: Union[List[int], NoneType] = None,\n    hist_options: Union[Dict, NoneType] = None,\n    max_size: int = 1024,\n    indexes: Union[Sequence[int], int, NoneType] = None,\n    expression: Union[str, NoneType] = None,\n    **kwargs: Any\n) -&gt; Dict[str, rio_tiler.models.BandStatistics]\n</code></pre> <p>Return bands statistics from a dataset.</p> <p>Parameters:</p> Name Type Description Default categorical bool treat input data as categorical data. Defaults to False. False categories list of numbers list of categories to return value for. None percentiles list of numbers list of percentile values to calculate. Defaults to <code>[2, 98]</code>. <code>[2, 98]</code> hist_options dict Options to forward to numpy.histogram function. None max_size int Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to 1024. 1024 kwargs optional Options to forward to <code>self.read</code>. None <p>Returns:</p> Type Description Dict[str, rio_tiler.models.BandStatistics] bands statistics."},{"location":"api/rio_tiler/io/rasterio/#tile_1","title":"tile","text":"<pre><code>def tile(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int,\n    tilesize: int = 256,\n    indexes: Union[Sequence[int], int, NoneType] = None,\n    expression: Union[str, NoneType] = None,\n    buffer: Union[float, NoneType] = None,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read a Web Map tile from a Dataset.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None tilesize int Output image size. Defaults to <code>256</code>. <code>256</code> indexes int or sequence of int Band indexes. None expression str rio-tiler expression (e.g. b1/b2+b3). None buffer float Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * tile_buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258). None kwargs optional Options to forward to the <code>Reader.part</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/rasterio/#tile_exists_1","title":"tile_exists","text":"<pre><code>def tile_exists(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int\n) -&gt; bool\n</code></pre> <p>Check if a tile intersects the dataset bounds.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None <p>Returns:</p> Type Description bool True if the tile intersects the dataset bounds."},{"location":"api/rio_tiler/io/stac/","title":"Module rio_tiler.io.stac","text":"<p>rio_tiler.io.stac: STAC reader.</p>"},{"location":"api/rio_tiler/io/stac/#variables","title":"Variables","text":"<pre><code>DEFAULT_VALID_TYPE\n</code></pre> <pre><code>WGS84_CRS\n</code></pre> <pre><code>boto3_session\n</code></pre>"},{"location":"api/rio_tiler/io/stac/#functions","title":"Functions","text":""},{"location":"api/rio_tiler/io/stac/#aws_get_object","title":"aws_get_object","text":"<pre><code>def aws_get_object(\n    bucket: str,\n    key: str,\n    request_pays: bool = False,\n    client: 'boto3_session.client' = None\n) -&gt; bytes\n</code></pre> <p>AWS s3 get object content.</p>"},{"location":"api/rio_tiler/io/stac/#fetch","title":"fetch","text":"<pre><code>def fetch(\n    filepath: str,\n    **kwargs: Any\n) -&gt; Dict\n</code></pre> <p>Fetch STAC items.</p> <p>A LRU cache is set on top of this function.</p> <p>Parameters:</p> Name Type Description Default filepath str STAC item URL. None kwargs any additional options to pass to client. None <p>Returns:</p> Type Description dict STAC Item content."},{"location":"api/rio_tiler/io/stac/#classes","title":"Classes","text":""},{"location":"api/rio_tiler/io/stac/#stacreader","title":"STACReader","text":"<pre><code>class STACReader(\n    input: str,\n    item: Union[NoneType, Dict, pystac.item.Item] = None,\n    tms: morecantile.models.TileMatrixSet = &lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;,\n    minzoom: int = NOTHING,\n    maxzoom: int = NOTHING,\n    geographic_crs: rasterio.crs.CRS = CRS.from_epsg(4326),\n    include_assets: Union[Set[str], NoneType] = None,\n    exclude_assets: Union[Set[str], NoneType] = None,\n    include_asset_types: Set[str] = {'image/jp2', 'image/tiff; application=geotiff; profile=cloud-optimized', 'image/tiff; application=geotiff', 'image/x.geotiff', 'image/vnd.stac.geotiff; cloud-optimized=true', 'image/tiff; profile=cloud-optimized; application=geotiff', 'image/tiff', 'application/x-hdf5', 'application/x-hdf'},\n    exclude_asset_types: Union[Set[str], NoneType] = None,\n    reader: Type[rio_tiler.io.base.BaseReader] = &lt;class 'rio_tiler.io.rasterio.Reader'&gt;,\n    reader_options: Dict = NOTHING,\n    fetch_options: Dict = NOTHING,\n    ctx: Any = &lt;class 'rasterio.env.Env'&gt;\n)\n</code></pre> <p>STAC Reader.</p>"},{"location":"api/rio_tiler/io/stac/#attributes","title":"Attributes","text":"Name Type Description Default input str STAC Item path, URL or S3 URL. None item dict or pystac.Item, STAC Stac Item. None tms morecantile.TileMatrixSet TileMatrixSet grid definition. Defaults to <code>WebMercatorQuad</code>. <code>WebMercatorQuad</code> minzoom int Set minzoom for the tiles. None maxzoom int Set maxzoom for the tiles. None geographic_crs rasterio.crs.CRS CRS to use as geographic coordinate system. Defaults to WGS84. WGS84 include_assets set of string Only Include specific assets. None exclude_assets set of string Exclude specific assets. None include_asset_types set of string Only include some assets base on their type. None exclude_asset_types set of string Exclude some assets base on their type. None reader rio_tiler.io.BaseReader rio-tiler Reader. Defaults to <code>rio_tiler.io.Reader</code>. <code>rio_tiler.io.Reader</code> reader_options dict Additional option to forward to the Reader. Defaults to <code>{}</code>. <code>{}</code> fetch_options dict Options to pass to <code>rio_tiler.io.stac.fetch</code> function fetching the STAC Items. Defaults to <code>{}</code>. <code>{}</code>"},{"location":"api/rio_tiler/io/stac/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.io.base.MultiBaseReader</li> <li>rio_tiler.io.base.SpatialMixin</li> </ul>"},{"location":"api/rio_tiler/io/stac/#methods","title":"Methods","text":""},{"location":"api/rio_tiler/io/stac/#feature","title":"feature","text":"<pre><code>def feature(\n    self,\n    shape: Dict,\n    assets: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    asset_indexes: Union[Dict[str, Union[Sequence[int], int]], NoneType] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge parts defined by geojson feature from multiple assets.</p> <p>Parameters:</p> Name Type Description Default shape dict Valid GeoJSON feature. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.feature</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/stac/#geographic_bounds","title":"geographic_bounds","text":"<pre><code>def geographic_bounds(\n    ...\n)\n</code></pre> <p>Return dataset bounds in geographic_crs.</p>"},{"location":"api/rio_tiler/io/stac/#info","title":"info","text":"<pre><code>def info(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    **kwargs: Any\n) -&gt; Dict[str, rio_tiler.models.Info]\n</code></pre> <p>Return metadata from multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. Required keyword argument. None <p>Returns:</p> Type Description dict Multiple assets info in form of {\"asset1\": rio_tile.models.Info}."},{"location":"api/rio_tiler/io/stac/#merged_statistics","title":"merged_statistics","text":"<pre><code>def merged_statistics(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    asset_indexes: Union[Dict[str, Union[Sequence[int], int]], NoneType] = None,\n    categorical: bool = False,\n    categories: Union[List[float], NoneType] = None,\n    percentiles: Union[List[int], NoneType] = None,\n    hist_options: Union[Dict, NoneType] = None,\n    max_size: int = 1024,\n    **kwargs: Any\n) -&gt; Dict[str, rio_tiler.models.BandStatistics]\n</code></pre> <p>Return array statistics for multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None categorical bool treat input data as categorical data. Defaults to False. False categories list of numbers list of categories to return value for. None percentiles list of numbers list of percentile values to calculate. Defaults to <code>[2, 98]</code>. <code>[2, 98]</code> hist_options dict Options to forward to numpy.histogram function. None max_size int Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to 1024. 1024 kwargs optional Options to forward to the <code>self.preview</code> method. None <p>Returns:</p> Type Description Dict[str, rio_tiler.models.BandStatistics] bands statistics."},{"location":"api/rio_tiler/io/stac/#parse_expression","title":"parse_expression","text":"<pre><code>def parse_expression(\n    self,\n    expression: str,\n    asset_as_band: bool = False\n) -&gt; Tuple\n</code></pre> <p>Parse rio-tiler band math expression.</p>"},{"location":"api/rio_tiler/io/stac/#part","title":"part","text":"<pre><code>def part(\n    self,\n    bbox: Tuple[float, float, float, float],\n    assets: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    asset_indexes: Union[Dict[str, Union[Sequence[int], int]], NoneType] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge parts from multiple assets.</p> <p>Parameters:</p> Name Type Description Default bbox tuple Output bounds (left, bottom, right, top) in target crs. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.part</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/stac/#point","title":"point","text":"<pre><code>def point(\n    self,\n    lon: float,\n    lat: float,\n    assets: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    asset_indexes: Union[Dict[str, Union[Sequence[int], int]], NoneType] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.PointData\n</code></pre> <p>Read pixel value from multiple assets.</p> <p>Parameters:</p> Name Type Description Default lon float Longitude. None lat float Latitude. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.point</code> method. None <p>Returns:</p> Type Description None PointData"},{"location":"api/rio_tiler/io/stac/#preview","title":"preview","text":"<pre><code>def preview(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    asset_indexes: Union[Dict[str, Union[Sequence[int], int]], NoneType] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge previews from multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.preview</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/stac/#statistics","title":"statistics","text":"<pre><code>def statistics(\n    self,\n    assets: Union[Sequence[str], str] = None,\n    asset_indexes: Union[Dict[str, Union[Sequence[int], int]], NoneType] = None,\n    asset_expression: Union[Dict[str, str], NoneType] = None,\n    **kwargs: Any\n) -&gt; Dict[str, Dict[str, rio_tiler.models.BandStatistics]]\n</code></pre> <p>Return array statistics for multiple assets.</p> <p>Parameters:</p> Name Type Description Default assets sequence of str or str assets to fetch info from. None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None asset_expression dict rio-tiler expression for each asset (e.g. {\"asset1\": \"b1/b2+b3\", \"asset2\": ...}). None kwargs optional Options to forward to the <code>self.reader.statistics</code> method. None <p>Returns:</p> Type Description dict Multiple assets statistics in form of {\"asset1\": {\"1\": rio_tiler.models.BandStatistics, ...}}."},{"location":"api/rio_tiler/io/stac/#tile","title":"tile","text":"<pre><code>def tile(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int,\n    assets: Union[Sequence[str], str] = None,\n    expression: Union[str, NoneType] = None,\n    asset_indexes: Union[Dict[str, Union[Sequence[int], int]], NoneType] = None,\n    asset_as_band: bool = False,\n    **kwargs: Any\n) -&gt; rio_tiler.models.ImageData\n</code></pre> <p>Read and merge Wep Map tiles from multiple assets.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None assets sequence of str or str assets to fetch info from. None expression str rio-tiler expression for the asset list (e.g. asset1/asset2+asset3). None asset_indexes dict Band indexes for each asset (e.g {\"asset1\": 1, \"asset2\": (1, 2,)}). None kwargs optional Options to forward to the <code>self.reader.tile</code> method. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/stac/#tile_exists","title":"tile_exists","text":"<pre><code>def tile_exists(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int\n) -&gt; bool\n</code></pre> <p>Check if a tile intersects the dataset bounds.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None <p>Returns:</p> Type Description bool True if the tile intersects the dataset bounds."},{"location":"api/rio_tiler/io/xarray/","title":"Module rio_tiler.io.xarray","text":"<p>rio_tiler.io.xarray: Xarray Reader.</p>"},{"location":"api/rio_tiler/io/xarray/#variables","title":"Variables","text":"<pre><code>WGS84_CRS\n</code></pre> <pre><code>rioxarray\n</code></pre> <pre><code>xarray\n</code></pre>"},{"location":"api/rio_tiler/io/xarray/#classes","title":"Classes","text":""},{"location":"api/rio_tiler/io/xarray/#xarrayreader","title":"XarrayReader","text":"<pre><code>class XarrayReader(\n    input: 'xarray.DataArray',\n    tms: 'TileMatrixSet' = &lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;,\n    geographic_crs: 'CRS' = CRS.from_epsg(4326)\n)\n</code></pre> <p>Xarray Reader.</p>"},{"location":"api/rio_tiler/io/xarray/#attributes","title":"Attributes","text":"Name Type Description Default dataset xarray.DataArray Xarray DataArray dataset. None tms morecantile.TileMatrixSet TileMatrixSet grid definition. Defaults to <code>WebMercatorQuad</code>. <code>WebMercatorQuad</code> geographic_crs rasterio.crs.CRS CRS to use as geographic coordinate system. Defaults to WGS84. WGS84"},{"location":"api/rio_tiler/io/xarray/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.io.base.BaseReader</li> <li>rio_tiler.io.base.SpatialMixin</li> </ul>"},{"location":"api/rio_tiler/io/xarray/#instance-variables","title":"Instance variables","text":"<pre><code>band_names\n</code></pre> <p>Return list of <code>band names</code> in DataArray.</p> <pre><code>maxzoom\n</code></pre> <p>Return dataset maxzoom.</p> <pre><code>minzoom\n</code></pre> <p>Return dataset minzoom.</p>"},{"location":"api/rio_tiler/io/xarray/#methods","title":"Methods","text":""},{"location":"api/rio_tiler/io/xarray/#feature","title":"feature","text":"<pre><code>def feature(\n    self,\n    shape: 'Dict',\n    dst_crs: 'Optional[CRS]' = None,\n    shape_crs: 'CRS' = CRS.from_epsg(4326),\n    resampling_method: 'Optional[WarpResampling]' = None,\n    reproject_method: 'WarpResampling' = 'nearest',\n    nodata: 'Optional[NoData]' = None\n) -&gt; 'ImageData'\n</code></pre> <p>Read part of a dataset defined by a geojson feature.</p> <p>Parameters:</p> Name Type Description Default shape dict Valid GeoJSON feature. None dst_crs rasterio.crs.CRS Overwrite target coordinate reference system. None shape_crs rasterio.crs.CRS Input geojson coordinate reference system. Defaults to <code>epsg:4326</code>. <code>epsg:4326</code> resampling_method WarpResampling DEPRECATED, WarpKernel resampling algorithm. Defaults to <code>nearest</code>. <code>nearest</code> reproject_method WarpResampling WarpKernel resampling algorithm. Defaults to <code>nearest</code>. <code>nearest</code> nodata int or float Overwrite dataset internal nodata value. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and input spatial info."},{"location":"api/rio_tiler/io/xarray/#geographic_bounds","title":"geographic_bounds","text":"<pre><code>def geographic_bounds(\n    ...\n)\n</code></pre> <p>Return dataset bounds in geographic_crs.</p>"},{"location":"api/rio_tiler/io/xarray/#get_maxzoom","title":"get_maxzoom","text":"<pre><code>def get_maxzoom(\n    self\n) -&gt; 'int'\n</code></pre> <p>Define dataset maximum zoom level.</p>"},{"location":"api/rio_tiler/io/xarray/#get_minzoom","title":"get_minzoom","text":"<pre><code>def get_minzoom(\n    self\n) -&gt; 'int'\n</code></pre> <p>Define dataset minimum zoom level.</p>"},{"location":"api/rio_tiler/io/xarray/#info","title":"info","text":"<pre><code>def info(\n    self\n) -&gt; 'Info'\n</code></pre> <p>Return xarray.DataArray info.</p>"},{"location":"api/rio_tiler/io/xarray/#part","title":"part","text":"<pre><code>def part(\n    self,\n    bbox: 'BBox',\n    dst_crs: 'Optional[CRS]' = None,\n    bounds_crs: 'CRS' = CRS.from_epsg(4326),\n    resampling_method: 'Optional[WarpResampling]' = None,\n    reproject_method: 'WarpResampling' = 'nearest',\n    auto_expand: 'bool' = True,\n    nodata: 'Optional[NoData]' = None\n) -&gt; 'ImageData'\n</code></pre> <p>Read part of a dataset.</p> <p>Parameters:</p> Name Type Description Default bbox tuple Output bounds (left, bottom, right, top) in target crs (\"dst_crs\"). None dst_crs rasterio.crs.CRS Overwrite target coordinate reference system. None bounds_crs rasterio.crs.CRS Bounds Coordinate Reference System. Defaults to <code>epsg:4326</code>. <code>epsg:4326</code> resampling_method WarpResampling DEPRECATED, WarpKernel resampling algorithm. Defaults to <code>nearest</code>. <code>nearest</code> reproject_method WarpResampling WarpKernel resampling algorithm. Defaults to <code>nearest</code>. <code>nearest</code> auto_expand boolean When True, rioxarray's clip_box will expand clip search if only 1D raster found with clip. When False, will throw <code>OneDimensionalRaster</code> error if only 1 x or y data point is found. Defaults to True. True nodata int or float Overwrite dataset internal nodata value. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and input spatial info."},{"location":"api/rio_tiler/io/xarray/#point","title":"point","text":"<pre><code>def point(\n    self,\n    lon: 'float',\n    lat: 'float',\n    coord_crs: 'CRS' = CRS.from_epsg(4326),\n    nodata: 'Optional[NoData]' = None\n) -&gt; 'PointData'\n</code></pre> <p>Read a pixel value from a dataset.</p> <p>Parameters:</p> Name Type Description Default lon float Longitude. None lat float Latitude. None coord_crs rasterio.crs.CRS Coordinate Reference System of the input coords. Defaults to <code>epsg:4326</code>. <code>epsg:4326</code> nodata int or float Overwrite dataset internal nodata value. None <p>Returns:</p> Type Description None PointData"},{"location":"api/rio_tiler/io/xarray/#preview","title":"preview","text":"<pre><code>def preview(\n    self,\n    max_size: 'int' = 1024,\n    height: 'Optional[int]' = None,\n    width: 'Optional[int]' = None\n) -&gt; 'ImageData'\n</code></pre> <p>Return a preview of a dataset.</p> <p>Parameters:</p> Name Type Description Default max_size int Limit the size of the longest dimension of the dataset read, respecting bounds X/Y aspect ratio. Defaults to 1024. 1024 height int Output height of the array. None width int Output width of the array. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and input spatial info."},{"location":"api/rio_tiler/io/xarray/#statistics","title":"statistics","text":"<pre><code>def statistics(\n    self,\n    categorical: 'bool' = False,\n    categories: 'Optional[List[float]]' = None,\n    percentiles: 'Optional[List[int]]' = None,\n    hist_options: 'Optional[Dict]' = None,\n    max_size: 'int' = 1024,\n    **kwargs: 'Any'\n) -&gt; 'Dict[str, BandStatistics]'\n</code></pre> <p>Return bands statistics from a dataset.</p>"},{"location":"api/rio_tiler/io/xarray/#tile","title":"tile","text":"<pre><code>def tile(\n    self,\n    tile_x: 'int',\n    tile_y: 'int',\n    tile_z: 'int',\n    tilesize: 'int' = 256,\n    resampling_method: 'Optional[WarpResampling]' = None,\n    reproject_method: 'WarpResampling' = 'nearest',\n    auto_expand: 'bool' = True,\n    nodata: 'Optional[NoData]' = None\n) -&gt; 'ImageData'\n</code></pre> <p>Read a Web Map tile from a dataset.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None tilesize int Output image size. Defaults to <code>256</code>. <code>256</code> resampling_method WarpResampling DEPRECATED, WarpKernel resampling algorithm. Defaults to <code>nearest</code>. <code>nearest</code> reproject_method WarpResampling WarpKernel resampling algorithm. Defaults to <code>nearest</code>. <code>nearest</code> auto_expand boolean When True, rioxarray's clip_box will expand clip search if only 1D raster found with clip. When False, will throw <code>OneDimensionalRaster</code> error if only 1 x or y data point is found. Defaults to True. True nodata int or float Overwrite dataset internal nodata value. None <p>Returns:</p> Type Description rio_tiler.models.ImageData ImageData instance with data, mask and tile spatial info."},{"location":"api/rio_tiler/io/xarray/#tile_exists","title":"tile_exists","text":"<pre><code>def tile_exists(\n    self,\n    tile_x: int,\n    tile_y: int,\n    tile_z: int\n) -&gt; bool\n</code></pre> <p>Check if a tile intersects the dataset bounds.</p> <p>Parameters:</p> Name Type Description Default tile_x int Tile's horizontal index. None tile_y int Tile's vertical index. None tile_z int Tile's zoom level index. None <p>Returns:</p> Type Description bool True if the tile intersects the dataset bounds."},{"location":"api/rio_tiler/mosaic/reader/","title":"Module rio_tiler.mosaic.reader","text":"<p>rio_tiler.mosaic: create tile from multiple assets.</p>"},{"location":"api/rio_tiler/mosaic/reader/#variables","title":"Variables","text":"<pre><code>MAX_THREADS\n</code></pre>"},{"location":"api/rio_tiler/mosaic/reader/#functions","title":"Functions","text":""},{"location":"api/rio_tiler/mosaic/reader/#mosaic_point_reader","title":"mosaic_point_reader","text":"<pre><code>def mosaic_point_reader(\n    mosaic_assets: Sequence,\n    reader: Callable[..., rio_tiler.models.PointData],\n    *args: Any,\n    pixel_selection: Union[Type[rio_tiler.mosaic.methods.base.MosaicMethodBase], rio_tiler.mosaic.methods.base.MosaicMethodBase] = &lt;class 'rio_tiler.mosaic.methods.defaults.FirstMethod'&gt;,\n    chunk_size: Union[int, NoneType] = None,\n    threads: int = 20,\n    allowed_exceptions: Tuple = (&lt;class 'rio_tiler.errors.PointOutsideBounds'&gt;,),\n    **kwargs\n) -&gt; Tuple[rio_tiler.models.PointData, List]\n</code></pre> <p>Merge multiple assets.</p> <p>Parameters:</p> Name Type Description Default mosaic_assets sequence List of assets. None reader callable Reader function. The function MUST take <code>(asset, *args, **kwargs)</code> as arguments, and MUST return a PointData object. None args Any Argument to forward to the reader function. None pixel_selection MosaicMethod Instance of MosaicMethodBase class. Defaults to <code>rio_tiler.mosaic.methods.defaults.FirstMethod</code>. <code>rio_tiler.mosaic.methods.defaults.FirstMethod</code> chunk_size int Control the number of asset to process per loop. None threads int Number of threads to use. If &lt;= 1, runs single threaded without an event loop. By default reads from the MAX_THREADS environment variable, and if not found defaults to multiprocessing.cpu_count() * 5. None allowed_exceptions tuple List of exceptions which will be ignored. Note: <code>PointOutsideBounds</code> is likely to be raised and should be included in the allowed_exceptions. Defaults to <code>(TileOutsideBounds, )</code>. <code>(TileOutsideBounds, )</code> kwargs optional Reader callable's keywords options. None <p>Returns:</p> Type Description tuple PointData and assets (list)."},{"location":"api/rio_tiler/mosaic/reader/#mosaic_reader","title":"mosaic_reader","text":"<pre><code>def mosaic_reader(\n    mosaic_assets: Sequence,\n    reader: Callable[..., rio_tiler.models.ImageData],\n    *args: Any,\n    pixel_selection: Union[Type[rio_tiler.mosaic.methods.base.MosaicMethodBase], rio_tiler.mosaic.methods.base.MosaicMethodBase] = &lt;class 'rio_tiler.mosaic.methods.defaults.FirstMethod'&gt;,\n    chunk_size: Union[int, NoneType] = None,\n    threads: int = 20,\n    allowed_exceptions: Tuple = (&lt;class 'rio_tiler.errors.TileOutsideBounds'&gt;,),\n    **kwargs\n) -&gt; Tuple[rio_tiler.models.ImageData, List]\n</code></pre> <p>Merge multiple assets.</p> <p>Parameters:</p> Name Type Description Default mosaic_assets sequence List of assets. None reader callable Reader function. The function MUST take <code>(asset, *args, **kwargs)</code> as arguments, and MUST return an ImageData. None args Any Argument to forward to the reader function. None pixel_selection MosaicMethod Instance of MosaicMethodBase class. Defaults to <code>rio_tiler.mosaic.methods.defaults.FirstMethod</code>. <code>rio_tiler.mosaic.methods.defaults.FirstMethod</code> chunk_size int Control the number of asset to process per loop. None threads int Number of threads to use. If &lt;= 1, runs single threaded without an event loop. By default reads from the MAX_THREADS environment variable, and if not found defaults to multiprocessing.cpu_count() * 5. None allowed_exceptions tuple List of exceptions which will be ignored. Note: <code>TileOutsideBounds</code> is likely to be raised and should be included in the allowed_exceptions. Defaults to <code>(TileOutsideBounds, )</code>. <code>(TileOutsideBounds, )</code> kwargs optional Reader callable's keywords options. None <p>Returns:</p> Type Description tuple ImageData and assets (list)."},{"location":"api/rio_tiler/mosaic/methods/base/","title":"Module rio_tiler.mosaic.methods.base","text":"<p>rio-tiler.mosaic.methods abc class.</p>"},{"location":"api/rio_tiler/mosaic/methods/base/#classes","title":"Classes","text":""},{"location":"api/rio_tiler/mosaic/methods/base/#mosaicmethodbase","title":"MosaicMethodBase","text":"<pre><code>class MosaicMethodBase(\n\n)\n</code></pre> <p>Abstract base class for rio-tiler-mosaic methods objects.</p>"},{"location":"api/rio_tiler/mosaic/methods/base/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>abc.ABC</li> </ul>"},{"location":"api/rio_tiler/mosaic/methods/base/#descendants","title":"Descendants","text":"<ul> <li>rio_tiler.mosaic.methods.defaults.FirstMethod</li> <li>rio_tiler.mosaic.methods.defaults.HighestMethod</li> <li>rio_tiler.mosaic.methods.defaults.LowestMethod</li> <li>rio_tiler.mosaic.methods.defaults.MeanMethod</li> <li>rio_tiler.mosaic.methods.defaults.MedianMethod</li> <li>rio_tiler.mosaic.methods.defaults.StdevMethod</li> <li>rio_tiler.mosaic.methods.defaults.LastBandHighMethod</li> <li>rio_tiler.mosaic.methods.defaults.LastBandLowMethod</li> <li>rio_tiler.mosaic.methods.defaults.CountMethod</li> </ul>"},{"location":"api/rio_tiler/mosaic/methods/base/#class-variables","title":"Class variables","text":"<pre><code>cutline_mask\n</code></pre> <pre><code>exit_when_filled\n</code></pre> <pre><code>mosaic\n</code></pre>"},{"location":"api/rio_tiler/mosaic/methods/base/#instance-variables","title":"Instance variables","text":"<pre><code>data\n</code></pre> <p>Return data.</p> <pre><code>is_done\n</code></pre> <p>Check if the mosaic filling is done.</p>"},{"location":"api/rio_tiler/mosaic/methods/base/#methods","title":"Methods","text":""},{"location":"api/rio_tiler/mosaic/methods/base/#feed","title":"feed","text":"<pre><code>def feed(\n    self,\n    array: numpy.ma.core.MaskedArray\n)\n</code></pre> <p>Fill mosaic array.</p> <p>Parameters:</p> Name Type Description Default array numpy.ma.ndarray data None"},{"location":"api/rio_tiler/mosaic/methods/defaults/","title":"Module rio_tiler.mosaic.methods.defaults","text":"<p>rio_tiler.mosaic.methods.defaults: default mosaic filling methods.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#classes","title":"Classes","text":""},{"location":"api/rio_tiler/mosaic/methods/defaults/#countmethod","title":"CountMethod","text":"<pre><code>class CountMethod(\n\n)\n</code></pre> <p>Stack the arrays and return the valid pixel count.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.mosaic.methods.base.MosaicMethodBase</li> <li>abc.ABC</li> </ul>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#class-variables","title":"Class variables","text":"<pre><code>cutline_mask\n</code></pre> <pre><code>exit_when_filled\n</code></pre> <pre><code>mosaic\n</code></pre>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#instance-variables","title":"Instance variables","text":"<pre><code>data\n</code></pre> <p>Return valid data count of the data stack.</p> <pre><code>is_done\n</code></pre> <p>Check if the mosaic filling is done.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#methods","title":"Methods","text":""},{"location":"api/rio_tiler/mosaic/methods/defaults/#feed","title":"feed","text":"<pre><code>def feed(\n    self,\n    array: Union[numpy.ma.core.MaskedArray, NoneType]\n)\n</code></pre> <p>Add array to the stack.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#firstmethod","title":"FirstMethod","text":"<pre><code>class FirstMethod(\n\n)\n</code></pre> <p>Feed the mosaic array with the first pixel available.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#ancestors-in-mro_1","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.mosaic.methods.base.MosaicMethodBase</li> <li>abc.ABC</li> </ul>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#class-variables_1","title":"Class variables","text":"<pre><code>cutline_mask\n</code></pre> <pre><code>exit_when_filled\n</code></pre> <pre><code>mosaic\n</code></pre>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#instance-variables_1","title":"Instance variables","text":"<pre><code>data\n</code></pre> <p>Return data.</p> <pre><code>is_done\n</code></pre> <p>Check if the mosaic filling is done.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#methods_1","title":"Methods","text":""},{"location":"api/rio_tiler/mosaic/methods/defaults/#feed_1","title":"feed","text":"<pre><code>def feed(\n    self,\n    array: Union[numpy.ma.core.MaskedArray, NoneType]\n)\n</code></pre> <p>Add data to the mosaic array.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#highestmethod","title":"HighestMethod","text":"<pre><code>class HighestMethod(\n\n)\n</code></pre> <p>Feed the mosaic array with the highest pixel values.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#ancestors-in-mro_2","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.mosaic.methods.base.MosaicMethodBase</li> <li>abc.ABC</li> </ul>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#class-variables_2","title":"Class variables","text":"<pre><code>cutline_mask\n</code></pre> <pre><code>exit_when_filled\n</code></pre> <pre><code>mosaic\n</code></pre>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#instance-variables_2","title":"Instance variables","text":"<pre><code>data\n</code></pre> <p>Return data.</p> <pre><code>is_done\n</code></pre> <p>Check if the mosaic filling is done.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#methods_2","title":"Methods","text":""},{"location":"api/rio_tiler/mosaic/methods/defaults/#feed_2","title":"feed","text":"<pre><code>def feed(\n    self,\n    array: Union[numpy.ma.core.MaskedArray, NoneType]\n)\n</code></pre> <p>Add data to the mosaic array.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#lastbandhighmethod","title":"LastBandHighMethod","text":"<pre><code>class LastBandHighMethod(\n\n)\n</code></pre> <p>Feed the mosaic array using the last band as decision factor (highest value).</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#ancestors-in-mro_3","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.mosaic.methods.base.MosaicMethodBase</li> <li>abc.ABC</li> </ul>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#class-variables_3","title":"Class variables","text":"<pre><code>cutline_mask\n</code></pre> <pre><code>exit_when_filled\n</code></pre> <pre><code>mosaic\n</code></pre>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#instance-variables_3","title":"Instance variables","text":"<pre><code>data\n</code></pre> <p>Return data.</p> <pre><code>is_done\n</code></pre> <p>Check if the mosaic filling is done.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#methods_3","title":"Methods","text":""},{"location":"api/rio_tiler/mosaic/methods/defaults/#feed_3","title":"feed","text":"<pre><code>def feed(\n    self,\n    array: Union[numpy.ma.core.MaskedArray, NoneType]\n)\n</code></pre> <p>Add data to the mosaic array.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#lastbandlowmethod","title":"LastBandLowMethod","text":"<pre><code>class LastBandLowMethod(\n\n)\n</code></pre> <p>Feed the mosaic array using the last band as decision factor (lowest value).</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#ancestors-in-mro_4","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.mosaic.methods.base.MosaicMethodBase</li> <li>abc.ABC</li> </ul>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#class-variables_4","title":"Class variables","text":"<pre><code>cutline_mask\n</code></pre> <pre><code>exit_when_filled\n</code></pre> <pre><code>mosaic\n</code></pre>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#instance-variables_4","title":"Instance variables","text":"<pre><code>data\n</code></pre> <p>Return data.</p> <pre><code>is_done\n</code></pre> <p>Check if the mosaic filling is done.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#methods_4","title":"Methods","text":""},{"location":"api/rio_tiler/mosaic/methods/defaults/#feed_4","title":"feed","text":"<pre><code>def feed(\n    self,\n    array: Union[numpy.ma.core.MaskedArray, NoneType]\n)\n</code></pre> <p>Add data to the mosaic array.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#lowestmethod","title":"LowestMethod","text":"<pre><code>class LowestMethod(\n\n)\n</code></pre> <p>Feed the mosaic array with the lowest pixel values.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#ancestors-in-mro_5","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.mosaic.methods.base.MosaicMethodBase</li> <li>abc.ABC</li> </ul>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#class-variables_5","title":"Class variables","text":"<pre><code>cutline_mask\n</code></pre> <pre><code>exit_when_filled\n</code></pre> <pre><code>mosaic\n</code></pre>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#instance-variables_5","title":"Instance variables","text":"<pre><code>data\n</code></pre> <p>Return data.</p> <pre><code>is_done\n</code></pre> <p>Check if the mosaic filling is done.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#methods_5","title":"Methods","text":""},{"location":"api/rio_tiler/mosaic/methods/defaults/#feed_5","title":"feed","text":"<pre><code>def feed(\n    self,\n    array: Union[numpy.ma.core.MaskedArray, NoneType]\n)\n</code></pre> <p>Add data to the mosaic array.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#meanmethod","title":"MeanMethod","text":"<pre><code>class MeanMethod(\n    enforce_data_type: bool = True\n)\n</code></pre> <p>Stack the arrays and return the Mean pixel value.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#ancestors-in-mro_6","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.mosaic.methods.base.MosaicMethodBase</li> <li>abc.ABC</li> </ul>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#class-variables_6","title":"Class variables","text":"<pre><code>cutline_mask\n</code></pre> <pre><code>enforce_data_type\n</code></pre> <pre><code>exit_when_filled\n</code></pre> <pre><code>mosaic\n</code></pre>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#instance-variables_6","title":"Instance variables","text":"<pre><code>data\n</code></pre> <p>Return Mean of the data stack.</p> <pre><code>is_done\n</code></pre> <p>Check if the mosaic filling is done.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#methods_6","title":"Methods","text":""},{"location":"api/rio_tiler/mosaic/methods/defaults/#feed_6","title":"feed","text":"<pre><code>def feed(\n    self,\n    array: numpy.ma.core.MaskedArray\n)\n</code></pre> <p>Add array to the stack.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#medianmethod","title":"MedianMethod","text":"<pre><code>class MedianMethod(\n    enforce_data_type: bool = True\n)\n</code></pre> <p>Stack the arrays and return the Median pixel value.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#ancestors-in-mro_7","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.mosaic.methods.base.MosaicMethodBase</li> <li>abc.ABC</li> </ul>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#class-variables_7","title":"Class variables","text":"<pre><code>cutline_mask\n</code></pre> <pre><code>enforce_data_type\n</code></pre> <pre><code>exit_when_filled\n</code></pre> <pre><code>mosaic\n</code></pre>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#instance-variables_7","title":"Instance variables","text":"<pre><code>data\n</code></pre> <p>Return Median of the data stack.</p> <pre><code>is_done\n</code></pre> <p>Check if the mosaic filling is done.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#methods_7","title":"Methods","text":""},{"location":"api/rio_tiler/mosaic/methods/defaults/#feed_7","title":"feed","text":"<pre><code>def feed(\n    self,\n    array: Union[numpy.ma.core.MaskedArray, NoneType]\n)\n</code></pre> <p>Add array to the stack.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#stdevmethod","title":"StdevMethod","text":"<pre><code>class StdevMethod(\n\n)\n</code></pre> <p>Stack the arrays and return the Standard Deviation value.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#ancestors-in-mro_8","title":"Ancestors (in MRO)","text":"<ul> <li>rio_tiler.mosaic.methods.base.MosaicMethodBase</li> <li>abc.ABC</li> </ul>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#class-variables_8","title":"Class variables","text":"<pre><code>cutline_mask\n</code></pre> <pre><code>exit_when_filled\n</code></pre> <pre><code>mosaic\n</code></pre>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#instance-variables_8","title":"Instance variables","text":"<pre><code>data\n</code></pre> <p>Return STDDEV of the data stack.</p> <pre><code>is_done\n</code></pre> <p>Check if the mosaic filling is done.</p>"},{"location":"api/rio_tiler/mosaic/methods/defaults/#methods_8","title":"Methods","text":""},{"location":"api/rio_tiler/mosaic/methods/defaults/#feed_8","title":"feed","text":"<pre><code>def feed(\n    self,\n    array: Union[numpy.ma.core.MaskedArray, NoneType]\n)\n</code></pre> <p>Add array to the stack.</p>"},{"location":"examples/Using-nonEarth-dataset/","title":"Using Non Earth dataset","text":"<p>Starting with version 3.0, rio-tiler can work with non-earth based dataset (e.g Mars data). In this notebook we'll show how to read such dataset and how to create a simple <code>non-earth</code> Tile server.</p> In\u00a0[1]: Copied! <pre># !pip install rio-tiler\n# !pip install ipyleaflet\n# !pip install matplotlib\n# !pip install tornado\n</pre> # !pip install rio-tiler # !pip install ipyleaflet # !pip install matplotlib # !pip install tornado In\u00a0[2]: Copied! <pre>from matplotlib.pyplot import imshow\n\nfrom rio_tiler.io import Reader\n\n# In order to fully work, we'll need to build a custom TileMatrixSet\nfrom morecantile import TileMatrixSet\nfrom pyproj import CRS\n\n# For this DEMO we will use this file\nsrc_path = \"https://raw.githubusercontent.com/cogeotiff/rio-tiler/main/tests/fixtures/cog_nonearth.tif\"\n</pre> from matplotlib.pyplot import imshow  from rio_tiler.io import Reader  # In order to fully work, we'll need to build a custom TileMatrixSet from morecantile import TileMatrixSet from pyproj import CRS  # For this DEMO we will use this file src_path = \"https://raw.githubusercontent.com/cogeotiff/rio-tiler/main/tests/fixtures/cog_nonearth.tif\" In\u00a0[3]: Copied! <pre># Let's first try with default\n# We should see 3 different warnings here\n# - UserWarning: Cannot dertermine bounds in WGS84: There is no existing transformation to WGS84\n# - UserWarning: Cannot dertermine minzoom based on dataset informations: We cannot get default Zooms in WebMercator projection\n# - UserWarning: Cannot dertermine maxzoom based on dataset informations: We cannot get default Zooms in WebMercator projection\nwith Reader(src_path) as src:\n    print(src.info().model_dump_json())\n</pre> # Let's first try with default # We should see 3 different warnings here # - UserWarning: Cannot dertermine bounds in WGS84: There is no existing transformation to WGS84 # - UserWarning: Cannot dertermine minzoom based on dataset informations: We cannot get default Zooms in WebMercator projection # - UserWarning: Cannot dertermine maxzoom based on dataset informations: We cannot get default Zooms in WebMercator projection with Reader(src_path) as src:     print(src.info().model_dump_json()) <pre>{\"bounds\": [-180.0, -90, 180.0, 90], \"minzoom\": 0, \"maxzoom\": 24, \"band_metadata\": [[\"b1\", {}]], \"band_descriptions\": [[\"b1\", \"IR-9680\"]], \"dtype\": \"float32\", \"nodata_type\": \"Nodata\", \"colorinterp\": [\"gray\"], \"scale\": null, \"offset\": null, \"colormap\": null, \"driver\": \"GTiff\", \"width\": 921, \"height\": 884, \"count\": 1, \"nodata_value\": -3.4028226550889045e+38, \"overviews\": [2]}\n</pre> <pre>/Users/vincentsarago/Dev/CogeoTiff/rio-tiler/rio_tiler/io/base.py:59: UserWarning: Cannot determine bounds in geographic CRS, will default to (-180.0, -90.0, 180.0, 90.0).\n  warnings.warn(\n/Users/vincentsarago/Dev/CogeoTiff/rio-tiler/rio_tiler/io/rasterio.py:183: UserWarning: Cannot determine minzoom based on dataset information, will default to TMS minzoom.\n  warnings.warn(\n/Users/vincentsarago/Dev/CogeoTiff/rio-tiler/rio_tiler/io/rasterio.py:204: UserWarning: Cannot determine maxzoom based on dataset information, will default to TMS maxzoom.\n  warnings.warn(\n</pre> In\u00a0[4]: Copied! <pre># Create a CUSTOM TMS using the europa ESRI:104915 projection\neuropa_crs = CRS.from_authority(\"ESRI\", 104915)\neuropa_tms = TileMatrixSet.custom(\n    crs=europa_crs, extent=europa_crs.area_of_use.bounds, matrix_scale=[2, 1],\n)\n\n# Use Custom TMS instead of Web Mercator\n# We should see 2 different warnings here\n# - UserWarning: Could not create coordinate Transformer from input CRS to WGS84: This is from morecantile. It means some methods won't be available but we can ignore. \n# - UserWarning: Cannot dertermine bounds in WGS84: Same as before. the `src.geographic_bounds` property will return default (-180.0, -90.0, 180.0, 90.0)\nwith Reader(src_path, tms=europa_tms) as src:\n    print(src.info().model_dump_json())\n    img = src.preview()\n    imshow(img.data_as_image())\n</pre> # Create a CUSTOM TMS using the europa ESRI:104915 projection europa_crs = CRS.from_authority(\"ESRI\", 104915) europa_tms = TileMatrixSet.custom(     crs=europa_crs, extent=europa_crs.area_of_use.bounds, matrix_scale=[2, 1], )  # Use Custom TMS instead of Web Mercator # We should see 2 different warnings here # - UserWarning: Could not create coordinate Transformer from input CRS to WGS84: This is from morecantile. It means some methods won't be available but we can ignore.  # - UserWarning: Cannot dertermine bounds in WGS84: Same as before. the `src.geographic_bounds` property will return default (-180.0, -90.0, 180.0, 90.0) with Reader(src_path, tms=europa_tms) as src:     print(src.info().model_dump_json())     img = src.preview()     imshow(img.data_as_image()) <pre>/Users/vincentsarago/Dev/DevSeed/morecantile/morecantile/models.py:290: UserWarning: Could not create coordinate Transformer from input CRS to the given geographic CRSsome methods might not be available.\n  warnings.warn(\n</pre> <pre>{\"bounds\": [-180.0, -90, 180.0, 90], \"minzoom\": 4, \"maxzoom\": 6, \"band_metadata\": [[\"b1\", {}]], \"band_descriptions\": [[\"b1\", \"IR-9680\"]], \"dtype\": \"float32\", \"nodata_type\": \"Nodata\", \"colorinterp\": [\"gray\"], \"scale\": null, \"offset\": null, \"colormap\": null, \"driver\": \"GTiff\", \"width\": 921, \"height\": 884, \"count\": 1, \"nodata_value\": -3.4028226550889045e+38, \"overviews\": [2]}\n</pre> In\u00a0[5]: Copied! <pre># Read a Tile\nfrom rasterio.warp import transform_bounds\n\nwith Reader(src_path, tms=europa_tms) as src:\n    # get dataset bounds in TMS's CRS projection\n    bounds_in_tms = transform_bounds(src.crs, europa_tms.rasterio_crs, *src.bounds)\n    tile = src.tms._tile(bounds_in_tms[0], bounds_in_tms[1], src.minzoom)\n    print(tile)\n\n    img = src.tile(tile.x, tile.y, tile.z)\n    imshow(img.data_as_image())\n</pre> # Read a Tile from rasterio.warp import transform_bounds  with Reader(src_path, tms=europa_tms) as src:     # get dataset bounds in TMS's CRS projection     bounds_in_tms = transform_bounds(src.crs, europa_tms.rasterio_crs, *src.bounds)     tile = src.tms._tile(bounds_in_tms[0], bounds_in_tms[1], src.minzoom)     print(tile)      img = src.tile(tile.x, tile.y, tile.z)     imshow(img.data_as_image()) <pre>Tile(x=27, y=6, z=4)\n</pre> In\u00a0[12]: Copied! <pre>from ipyleaflet import (\n    Map,\n    TileLayer,\n    projections\n)\n</pre> from ipyleaflet import (     Map,     TileLayer,     projections ) In\u00a0[13]: Copied! <pre>import json\nfrom concurrent import futures\n\nfrom tornado import web\nfrom tornado import gen\nfrom tornado.httpserver import HTTPServer\nfrom tornado.concurrent import run_on_executor\n\nfrom rio_tiler.io import Reader\nfrom rio_tiler.errors import TileOutsideBounds\nfrom rio_tiler.profiles import img_profiles\n\nfrom pyproj import CRS\nfrom morecantile import TileMatrixSet\n\n# Create a CUSTOM TMS using the europa ESRI:104915 projection\neuropa_crs = CRS.from_authority(\"ESRI\", 104915)\neuropa_tms = TileMatrixSet.custom(\n    crs=europa_crs, extent=europa_crs.area_of_use.bounds, matrix_scale=[2, 1],\n)\n\nclass TileServer:\n    def __init__(self, src_path):\n        \"\"\"Initialize Tornado app.\"\"\"\n        self.server = None\n        self.app = web.Application([\n            (r\"^/tiles/(\\d+)/(\\d+)/(\\d+)\", TileHandler, {\"url\": src_path}),\n        ])\n\n    def start(self):\n        \"\"\"Start tile server.\"\"\"\n        self.server = HTTPServer(self.app)\n        self.server.listen(8080)\n  \n    def stop(self):\n        \"\"\"Stop tile server.\"\"\"\n        if self.server:\n            self.server.stop()\n\n\nclass TileHandler(web.RequestHandler):\n    \"\"\"Tile requests handler.\"\"\"\n\n    executor = futures.ThreadPoolExecutor(max_workers=16)\n\n    def initialize(self, url):\n        \"\"\"Initialize tiles handler.\"\"\"\n        self.url = url\n\n    @run_on_executor\n    def _get_tile(self, z, x, y):\n\n        try:\n            with Reader(self.url, tms=europa_tms) as src:\n                data = src.tile(x, y, z)\n        except TileOutsideBounds:\n            raise web.HTTPError(404)\n\n        image = data.post_process(in_range=((0, 0.5),))\n\n        prof = img_profiles.get(\"PNG\", {})\n        return image.render(img_format=\"PNG\", **prof)\n\n    @gen.coroutine\n    def get(self, z, x, y):\n        \"\"\"Retunrs tile data and header.\"\"\"\n        self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n        self.set_header(\"Access-Control-Allow-Methods\", \"GET\")\n        self.set_header(\"Content-Type\", \"image/png\")\n        self.set_header(\"Cache-Control\", \"no-store, no-cache, must-revalidate\")\n        res = yield self._get_tile(int(z), int(x), int(y))\n        self.write(res)\n\n\nts = TileServer(src_path)\nts.start()\n</pre> import json from concurrent import futures  from tornado import web from tornado import gen from tornado.httpserver import HTTPServer from tornado.concurrent import run_on_executor  from rio_tiler.io import Reader from rio_tiler.errors import TileOutsideBounds from rio_tiler.profiles import img_profiles  from pyproj import CRS from morecantile import TileMatrixSet  # Create a CUSTOM TMS using the europa ESRI:104915 projection europa_crs = CRS.from_authority(\"ESRI\", 104915) europa_tms = TileMatrixSet.custom(     crs=europa_crs, extent=europa_crs.area_of_use.bounds, matrix_scale=[2, 1], )  class TileServer:     def __init__(self, src_path):         \"\"\"Initialize Tornado app.\"\"\"         self.server = None         self.app = web.Application([             (r\"^/tiles/(\\d+)/(\\d+)/(\\d+)\", TileHandler, {\"url\": src_path}),         ])      def start(self):         \"\"\"Start tile server.\"\"\"         self.server = HTTPServer(self.app)         self.server.listen(8080)        def stop(self):         \"\"\"Stop tile server.\"\"\"         if self.server:             self.server.stop()   class TileHandler(web.RequestHandler):     \"\"\"Tile requests handler.\"\"\"      executor = futures.ThreadPoolExecutor(max_workers=16)      def initialize(self, url):         \"\"\"Initialize tiles handler.\"\"\"         self.url = url      @run_on_executor     def _get_tile(self, z, x, y):          try:             with Reader(self.url, tms=europa_tms) as src:                 data = src.tile(x, y, z)         except TileOutsideBounds:             raise web.HTTPError(404)          image = data.post_process(in_range=((0, 0.5),))          prof = img_profiles.get(\"PNG\", {})         return image.render(img_format=\"PNG\", **prof)      @gen.coroutine     def get(self, z, x, y):         \"\"\"Retunrs tile data and header.\"\"\"         self.set_header(\"Access-Control-Allow-Origin\", \"*\")         self.set_header(\"Access-Control-Allow-Methods\", \"GET\")         self.set_header(\"Content-Type\", \"image/png\")         self.set_header(\"Cache-Control\", \"no-store, no-cache, must-revalidate\")         res = yield self._get_tile(int(z), int(x), int(y))         self.write(res)   ts = TileServer(src_path) ts.start() <pre>/Users/vincentsarago/Dev/venv/py39/lib/python3.9/site-packages/morecantile/models.py:162: UserWarning: Could not create coordinate Transformer from input CRS to the given geographic CRSsome methods might not be available.\n  warnings.warn(\n</pre> In\u00a0[14]: Copied! <pre>bounds = (129.36834223297478, 13.985559117409744, 138.90253908503576, 23.13673177454536)\n\nm = Map(\n    center=(\n        (bounds[1] + bounds[3]) / 2,\n        (bounds[0] + bounds[2]) / 2\n    ),\n    zoom=4,\n    basemap={},\n    crs=projections.EPSG4326,  # HACK: the europa TMS is in degree and covers -180, -90, 180, 90 like the WGS84\n)\n\nlayer = TileLayer(\n    url=\"http://127.0.0.1:8080/tiles/{z}/{x}/{y}\",\n    min_zoom=4,\n    max_zoom=6,\n    opacity=1,\n)\nm.add_layer(layer)\nm\n</pre> bounds = (129.36834223297478, 13.985559117409744, 138.90253908503576, 23.13673177454536)  m = Map(     center=(         (bounds[1] + bounds[3]) / 2,         (bounds[0] + bounds[2]) / 2     ),     zoom=4,     basemap={},     crs=projections.EPSG4326,  # HACK: the europa TMS is in degree and covers -180, -90, 180, 90 like the WGS84 )  layer = TileLayer(     url=\"http://127.0.0.1:8080/tiles/{z}/{x}/{y}\",     min_zoom=4,     max_zoom=6,     opacity=1, ) m.add_layer(layer) m Out[14]: <pre>Map(center=[18.56114544597755, 134.13544065900527], controls=(ZoomControl(options=['position', 'zoom_in_text',\u2026</pre> <pre>WARNING:tornado.access:404 GET /tiles/4/27/7 (127.0.0.1) 2376.62ms\nWARNING:tornado.access:404 GET /tiles/4/28/7 (127.0.0.1) 2376.60ms\nWARNING:tornado.access:404 GET /tiles/4/26/6 (127.0.0.1) 247.34ms\nWARNING:tornado.access:404 GET /tiles/4/29/6 (127.0.0.1) 317.36ms\nWARNING:tornado.access:404 GET /tiles/4/26/5 (127.0.0.1) 398.04ms\nWARNING:tornado.access:404 GET /tiles/4/29/5 (127.0.0.1) 88.59ms\nWARNING:tornado.access:404 GET /tiles/4/26/7 (127.0.0.1) 330.95ms\nWARNING:tornado.access:404 GET /tiles/4/29/7 (127.0.0.1) 411.70ms\nWARNING:tornado.access:404 GET /tiles/4/25/6 (127.0.0.1) 247.50ms\nWARNING:tornado.access:404 GET /tiles/4/30/6 (127.0.0.1) 247.38ms\nWARNING:tornado.access:404 GET /tiles/4/25/5 (127.0.0.1) 83.29ms\nWARNING:tornado.access:404 GET /tiles/4/30/5 (127.0.0.1) 161.35ms\nWARNING:tornado.access:404 GET /tiles/4/25/7 (127.0.0.1) 162.02ms\nWARNING:tornado.access:404 GET /tiles/4/31/6 (127.0.0.1) 321.71ms\nWARNING:tornado.access:404 GET /tiles/4/24/6 (127.0.0.1) 322.11ms\nWARNING:tornado.access:404 GET /tiles/4/24/5 (127.0.0.1) 323.51ms\nWARNING:tornado.access:404 GET /tiles/4/30/7 (127.0.0.1) 322.74ms\nWARNING:tornado.access:404 GET /tiles/4/24/7 (127.0.0.1) 246.76ms\nWARNING:tornado.access:404 GET /tiles/4/31/5 (127.0.0.1) 247.04ms\nWARNING:tornado.access:404 GET /tiles/4/31/7 (127.0.0.1) 84.63ms\n</pre> In\u00a0[15]: Copied! <pre>ts.stop()\n</pre> ts.stop() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Using-nonEarth-dataset/#using-non-earth-dataset","title":"Using Non Earth dataset\u00b6","text":""},{"location":"examples/Using-nonEarth-dataset/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>rio-tiler~=5.0</li> <li>ipyleaflet</li> <li>matplotlib</li> <li>tornado</li> </ul>"},{"location":"examples/Using-nonEarth-dataset/#tile-server","title":"Tile Server\u00b6","text":""},{"location":"examples/Using-nonEarth-dataset/#requirements","title":"Requirements\u00b6","text":"<ul> <li>tornado</li> </ul>"},{"location":"examples/Using-rio-tiler-STACReader/","title":"Introduction to rio-tiler + STAC","text":"<p>The goal of this notebook is to give a quick introduction of the rio-tiler STACReader.</p> In\u00a0[1]: Copied! <pre># !pip install rio-tiler matplotlib\n</pre> # !pip install rio-tiler matplotlib In\u00a0[2]: Copied! <pre>from rio_tiler.io import STACReader\nfrom rio_tiler.profiles import img_profiles\nfrom rio_tiler.models import ImageData\n\nfrom matplotlib.pyplot import subplots, imshow\n</pre> from rio_tiler.io import STACReader from rio_tiler.profiles import img_profiles from rio_tiler.models import ImageData  from matplotlib.pyplot import subplots, imshow In\u00a0[3]: Copied! <pre># For this DEMO we will use this file\nsrc_path = \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\"\n</pre> # For this DEMO we will use this file src_path = \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" In\u00a0[4]: Copied! <pre>?STACReader\n</pre> ?STACReader In\u00a0[6]: Copied! <pre>with STACReader(src_path) as stac:\n    pass\n\n# see the list of available assets\nprint(stac.assets)\n\n# print the bounds\nprint(stac.bounds)\nprint(stac.crs)\n</pre> with STACReader(src_path) as stac:     pass  # see the list of available assets print(stac.assets)  # print the bounds print(stac.bounds) print(stac.crs)  <pre>['overview', 'B11', 'B01', 'B12', 'B02', 'B03', 'B04', 'AOT', 'B05', 'B06', 'B07', 'B08', 'B8A', 'B09', 'WVP', 'visual', 'SCL']\n[23.293255090449595, 31.505183020453355, 24.296453548295318, 32.51147809805106]\nEPSG:4326\n</pre> In\u00a0[7]: Copied! <pre>with STACReader(src_path) as stac:\n    # This method will return a Dict of `{asset: rio_tiler.models.Info, asset2: rio_tiler.models.Info}`\n    # Checkout the docs https://cogeotiff.github.io/rio-tiler/models/#info for more info about the model.\n    info = stac.info(assets=(\"B01\", \"B02\"))\n    print(\"B01:\")\n    print(info[\"B01\"].model_dump(exclude_none=True))\n    print(\"B02:\")\n    print(info[\"B02\"].model_dump(exclude_none=True))\n</pre> with STACReader(src_path) as stac:     # This method will return a Dict of `{asset: rio_tiler.models.Info, asset2: rio_tiler.models.Info}`     # Checkout the docs https://cogeotiff.github.io/rio-tiler/models/#info for more info about the model.     info = stac.info(assets=(\"B01\", \"B02\"))     print(\"B01:\")     print(info[\"B01\"].model_dump(exclude_none=True))     print(\"B02:\")     print(info[\"B02\"].model_dump(exclude_none=True)) <pre>B01:\n{'bounds': BoundingBox(left=23.106076243528157, bottom=31.505173744374172, right=24.296464503939948, top=32.519334871696195), 'minzoom': 8, 'maxzoom': 11, 'band_metadata': [('b1', {})], 'band_descriptions': [('b1', '')], 'dtype': 'uint16', 'nodata_type': 'Nodata', 'colorinterp': ['gray'], 'height': 1830, 'width': 1830, 'overviews': [2, 4, 8], 'driver': 'GTiff', 'count': 1, 'nodata_value': 0.0}\nB02:\n{'bounds': BoundingBox(left=23.106076243528157, bottom=31.505173744374172, right=24.296464503939948, top=32.519334871696195), 'minzoom': 8, 'maxzoom': 14, 'band_metadata': [('b1', {})], 'band_descriptions': [('b1', '')], 'dtype': 'uint16', 'nodata_type': 'Nodata', 'colorinterp': ['gray'], 'height': 10980, 'width': 10980, 'overviews': [2, 4, 8, 16], 'driver': 'GTiff', 'count': 1, 'nodata_value': 0.0}\n</pre> In\u00a0[8]: Copied! <pre>with STACReader(src_path) as stac:\n    meta = stac.statistics(assets=(\"B01\", \"B02\", \"B03\", \"B04\"), max_size=256) # Here we use max_size option to limit the data transfer (default to 1024)\n    print(\"available assets statistics:\")\n    print(list(meta))\n    print()\n    print(\"statistics for asset B01:\")\n    # For each asset, we will get a Dict in form of {\"1\": BandStatistics(...), ...} with `1` being the band index.\n    print(meta[\"B01\"])\n</pre> with STACReader(src_path) as stac:     meta = stac.statistics(assets=(\"B01\", \"B02\", \"B03\", \"B04\"), max_size=256) # Here we use max_size option to limit the data transfer (default to 1024)     print(\"available assets statistics:\")     print(list(meta))     print()     print(\"statistics for asset B01:\")     # For each asset, we will get a Dict in form of {\"1\": BandStatistics(...), ...} with `1` being the band index.     print(meta[\"B01\"]) <pre>available assets statistics:\n['B01', 'B02', 'B03', 'B04']\n\nstatistics for asset B01:\n{'b1': BandStatistics(min=266.0, max=8177.0, mean=2000.2489664959585, count=48621.0, sum=97254105.0, std=1219.279372960457, median=1865.0, majority=322.0, minority=266.0, unique=5132.0, histogram=[[13396.0, 10624.0, 11190.0, 7230.0, 3801.0, 1425.0, 621.0, 244.0, 77.0, 13.0], [266.0, 1057.1, 1848.2, 2639.3, 3430.4, 4221.5, 5012.6, 5803.7, 6594.8, 7385.900000000001, 8177.0]], valid_percent=74.19, masked_pixels=16915.0, valid_pixels=48621.0, percentile_98=4990.0, percentile_2=325.0)}\n</pre> In\u00a0[9]: Copied! <pre>fig, axs = subplots(1, 4, sharey=True, tight_layout=True, dpi=150)\n\naxs[0].plot(meta[\"B01\"][\"b1\"].histogram[1][0:-1], meta[\"B01\"][\"b1\"].histogram[0])\naxs[1].plot(meta[\"B02\"][\"b1\"].histogram[1][0:-1], meta[\"B02\"][\"b1\"].histogram[0])\naxs[2].plot(meta[\"B03\"][\"b1\"].histogram[1][0:-1], meta[\"B03\"][\"b1\"].histogram[0])\naxs[3].plot(meta[\"B04\"][\"b1\"].histogram[1][0:-1], meta[\"B04\"][\"b1\"].histogram[0])\n</pre> fig, axs = subplots(1, 4, sharey=True, tight_layout=True, dpi=150)  axs[0].plot(meta[\"B01\"][\"b1\"].histogram[1][0:-1], meta[\"B01\"][\"b1\"].histogram[0]) axs[1].plot(meta[\"B02\"][\"b1\"].histogram[1][0:-1], meta[\"B02\"][\"b1\"].histogram[0]) axs[2].plot(meta[\"B03\"][\"b1\"].histogram[1][0:-1], meta[\"B03\"][\"b1\"].histogram[0]) axs[3].plot(meta[\"B04\"][\"b1\"].histogram[1][0:-1], meta[\"B04\"][\"b1\"].histogram[0]) Out[9]: <pre>[&lt;matplotlib.lines.Line2D at 0x16e6a6ca0&gt;]</pre> In\u00a0[10]: Copied! <pre>with STACReader(src_path) as stac:\n    # By default `preview()` will return an array with its longest dimension lower or equal to 1024px\n    img = stac.preview(assets=(\"B04\", \"B03\", \"B02\"), max_size=256)\n    print(img.data.shape)\n    # learn more about the ImageData model https://cogeotiff.github.io/rio-tiler/models/#imagedata\n    assert isinstance(img, ImageData)\n</pre> with STACReader(src_path) as stac:     # By default `preview()` will return an array with its longest dimension lower or equal to 1024px     img = stac.preview(assets=(\"B04\", \"B03\", \"B02\"), max_size=256)     print(img.data.shape)     # learn more about the ImageData model https://cogeotiff.github.io/rio-tiler/models/#imagedata     assert isinstance(img, ImageData) <pre>(3, 256, 256)\n</pre> In\u00a0[11]: Copied! <pre># Rasterio doesn't use the same axis order than visualization libraries (e.g matplotlib, PIL)\n# in order to display the data we need to change the order (using rasterio.plot.array_to_image).\n# the ImageData class wraps the rasterio function in the `data_as_image()` method.\nprint(type(img))\nprint(img.data.shape)\n\nimage = img.data_as_image()\n# data_as_image() returns a numpy.ndarray in form of (col, row, band)\nprint(type(image))\nprint(image.shape)\n\nimshow(image)\n</pre> # Rasterio doesn't use the same axis order than visualization libraries (e.g matplotlib, PIL) # in order to display the data we need to change the order (using rasterio.plot.array_to_image). # the ImageData class wraps the rasterio function in the `data_as_image()` method. print(type(img)) print(img.data.shape)  image = img.data_as_image() # data_as_image() returns a numpy.ndarray in form of (col, row, band) print(type(image)) print(image.shape)  imshow(image) <pre>Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n</pre> <pre>&lt;class 'rio_tiler.models.ImageData'&gt;\n(3, 256, 256)\n&lt;class 'numpy.ndarray'&gt;\n(256, 256, 3)\n</pre> Out[11]: <pre>&lt;matplotlib.image.AxesImage at 0x17950ba60&gt;</pre> In\u00a0[12]: Copied! <pre># The sentinel data is stored as UInt16, we need to do some data rescaling to display data from 0 to 255\nprint(img.data.min(), img.data.max())\n\nimg.rescale(in_range=((0, 10000),))\nprint(img.data.min(), img.data.max())\n\nimage = img.data_as_image()\nimshow(image)\n</pre> # The sentinel data is stored as UInt16, we need to do some data rescaling to display data from 0 to 255 print(img.data.min(), img.data.max())  img.rescale(in_range=((0, 10000),)) print(img.data.min(), img.data.max())  image = img.data_as_image() imshow(image) <pre>0 7671\n0 195\n</pre> Out[12]: <pre>&lt;matplotlib.image.AxesImage at 0x179537700&gt;</pre> In\u00a0[13]: Copied! <pre>with STACReader(src_path) as stac:\n    # By default `preview()` will return an array with its longest dimension lower or equal to 1024px\n    img = stac.preview(expression=\"(B08_b1-B04_b1)/(B08_b1+B04_b1)\", max_size=256)\n    print(img.data.shape)\n    # learn more about the ImageData model https://cogeotiff.github.io/rio-tiler/models/#imagedata\n    assert isinstance(img, ImageData)\n\n# NDVI data range should be between -1 and 1\nprint(img.data.min(), img.data.max())\n\nimg.rescale(in_range=((-1,1),))\nimage = img.data_as_image()\nimshow(image)\n</pre> with STACReader(src_path) as stac:     # By default `preview()` will return an array with its longest dimension lower or equal to 1024px     img = stac.preview(expression=\"(B08_b1-B04_b1)/(B08_b1+B04_b1)\", max_size=256)     print(img.data.shape)     # learn more about the ImageData model https://cogeotiff.github.io/rio-tiler/models/#imagedata     assert isinstance(img, ImageData)  # NDVI data range should be between -1 and 1 print(img.data.min(), img.data.max())  img.rescale(in_range=((-1,1),)) image = img.data_as_image() imshow(image) <pre>(1, 256, 256)\n-0.10652920962199312 0.6103714085494043\n</pre> Out[13]: <pre>&lt;matplotlib.image.AxesImage at 0x17b563670&gt;</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Using-rio-tiler-STACReader/#introduction-to-rio-tiler-stac","title":"Introduction to rio-tiler + STAC\u00b6","text":""},{"location":"examples/Using-rio-tiler-STACReader/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>rio-tiler~= 5.0</li> <li>matplotlib</li> </ul>"},{"location":"examples/Using-rio-tiler-STACReader/#data","title":"Data\u00b6","text":"<p>For this demo we will use a STAC Item for the Sentinel-2 data stored as COGs on AWS.</p>"},{"location":"examples/Using-rio-tiler-STACReader/#sentinel-2-cogs","title":"Sentinel 2 COGs\u00b6","text":"<p>Thanks to Digital Earth Africa and in collaboration with Sinergise, Element 84, Amazon Web Services (AWS) and the Committee on Earth Observation Satellites (CEOS), Sentinel 2 (Level 2) data over Africa, usually stored as JPEG2000, has been translated to COG more important a STAC database and API has been setup.</p> <p>https://www.digitalearthafrica.org/news/operational-and-ready-use-satellite-data-now-available-across-africa</p>"},{"location":"examples/Using-rio-tiler-STACReader/#rio_tileriostacreader","title":"rio_tiler.io.STACReader\u00b6","text":"<p>In <code>rio-tiler</code> 2.0 we introduced STACReader, which is a python class providing usefull methods get and parse the STAC item and then read and inspect any GDAL/rasterio raster assets.</p> <p>Docs: https://cogeotiff.github.io/rio-tiler/readers/#stacreader</p>"},{"location":"examples/Using-rio-tiler-STACReader/#initialize-the-reader","title":"Initialize the Reader\u00b6","text":""},{"location":"examples/Using-rio-tiler-STACReader/#info","title":"Info\u00b6","text":"<p>Get some info about some assets</p>"},{"location":"examples/Using-rio-tiler-STACReader/#statistics","title":"Statistics\u00b6","text":"<p>Return basic data statistics</p>"},{"location":"examples/Using-rio-tiler-STACReader/#plot-histogram-values","title":"Plot Histogram values\u00b6","text":""},{"location":"examples/Using-rio-tiler-STACReader/#preview","title":"Preview\u00b6","text":"<p>Read a low resolution version of the data (useful when working with COG, because this method will only fetch the overview layer it needs)</p>"},{"location":"examples/Using-rio-tiler-STACReader/#display-the-data","title":"Display the data\u00b6","text":""},{"location":"examples/Using-rio-tiler-STACReader/#use-expression","title":"Use Expression\u00b6","text":""},{"location":"examples/Using-rio-tiler-XarrayReader/","title":"Xarray + rio-tiler","text":"In\u00a0[1]: Copied! <pre>import xarray\nimport matplotlib.pyplot as plt\n\nfrom rio_tiler.io.xarray import XarrayReader\n</pre> import xarray import matplotlib.pyplot as plt  from rio_tiler.io.xarray import XarrayReader In\u00a0[2]: Copied! <pre>ds = xarray.open_dataset(\n    \"https://pangeo.blob.core.windows.net/pangeo-public/daymet-rio-tiler/na-wgs84.zarr/\",\n    engine=\"zarr\",\n    decode_coords=\"all\",\n    consolidated=True,\n)\nds\n</pre> ds = xarray.open_dataset(     \"https://pangeo.blob.core.windows.net/pangeo-public/daymet-rio-tiler/na-wgs84.zarr/\",     engine=\"zarr\",     decode_coords=\"all\",     consolidated=True, ) ds Out[2]: <pre>&lt;xarray.Dataset&gt;\nDimensions:                  (time: 1, y: 3728, x: 17268)\nCoordinates:\n    lambert_conformal_conic  int64 0\n  * time                     (time) datetime64[ns] 1980-07-01T12:00:00\n  * x                        (x) float64 -180.0 -180.0 -179.9 ... 180.0 180.0\n  * y                        (y) float64 83.78 83.76 83.74 ... 6.126 6.105 6.084\nData variables:\n    tmax                     (time, y, x) float32 ...\nAttributes:\n    Conventions:       CF-1.6\n    Version_data:      Daymet Data Version 4.0\n    Version_software:  Daymet Software Version 4.0\n    citation:          Please see http://daymet.ornl.gov/ for current Daymet ...\n    references:        Please see http://daymet.ornl.gov/ for current informa...\n    source:            Daymet Software Version 4.0\n    start_year:        1980</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 1</li><li>y: 3728</li><li>x: 17268</li></ul></li><li>Coordinates: (4)<ul><li>lambert_conformal_conic()int64...GeoTransform :-179.99998449579846 0.020846750664780467 0.0 83.79467217916716 0.0 -0.02084795798224527crs_wkt :GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]geographic_crs_name :WGS 84grid_mapping_name :latitude_longitudeinverse_flattening :298.257223563longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichreference_ellipsoid_name :WGS 84semi_major_axis :6378137.0semi_minor_axis :6356752.314245179spatial_ref :GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]<pre>array(0)</pre></li><li>time(time)datetime64[ns]1980-07-01T12:00:00long_name :24-hour day based on local timestandard_name :time<pre>array(['1980-07-01T12:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>x(x)float64-180.0 -180.0 ... 180.0 180.0axis :Xlong_name :longitudestandard_name :longitudeunits :degrees_east<pre>array([-179.989561, -179.968714, -179.947868, ...,  179.929589,  179.950436,\n        179.971283])</pre></li><li>y(y)float6483.78 83.76 83.74 ... 6.105 6.084axis :Ylong_name :latitudestandard_name :latitudeunits :degrees_north<pre>array([83.784248, 83.7634  , 83.742552, ...,  6.125605,  6.104757,  6.083909])</pre></li></ul></li><li>Data variables: (1)<ul><li>tmax(time, y, x)float32...cell_methods :area: mean time: maximum within days time: mean over dayscoordinates :lon latlong_name :annual average of daily maximum temperatureunits :degrees C<pre>[64375104 values with dtype=float32]</pre></li></ul></li><li>Attributes: (7)Conventions :CF-1.6Version_data :Daymet Data Version 4.0Version_software :Daymet Software Version 4.0citation :Please see http://daymet.ornl.gov/ for current Daymet data citation informationreferences :Please see http://daymet.ornl.gov/ for current information on Daymet referencessource :Daymet Software Version 4.0start_year :1980</li></ul> In\u00a0[3]: Copied! <pre>da = ds[\"tmax\"]\nda\n</pre> da = ds[\"tmax\"] da Out[3]: <pre>&lt;xarray.DataArray 'tmax' (time: 1, y: 3728, x: 17268)&gt;\n[64375104 values with dtype=float32]\nCoordinates:\n    lambert_conformal_conic  int64 0\n  * time                     (time) datetime64[ns] 1980-07-01T12:00:00\n  * x                        (x) float64 -180.0 -180.0 -179.9 ... 180.0 180.0\n  * y                        (y) float64 83.78 83.76 83.74 ... 6.126 6.105 6.084\nAttributes:\n    cell_methods:  area: mean time: maximum within days time: mean over days\n    coordinates:   lon lat\n    long_name:     annual average of daily maximum temperature\n    units:         degrees C</pre>xarray.DataArray'tmax'<ul><li>time: 1</li><li>y: 3728</li><li>x: 17268</li></ul><ul><li>...<pre>[64375104 values with dtype=float32]</pre></li><li>Coordinates: (4)<ul><li>lambert_conformal_conic()int640GeoTransform :-179.99998449579846 0.020846750664780467 0.0 83.79467217916716 0.0 -0.02084795798224527crs_wkt :GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]geographic_crs_name :WGS 84grid_mapping_name :latitude_longitudeinverse_flattening :298.257223563longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichreference_ellipsoid_name :WGS 84semi_major_axis :6378137.0semi_minor_axis :6356752.314245179spatial_ref :GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]<pre>array(0)</pre></li><li>time(time)datetime64[ns]1980-07-01T12:00:00long_name :24-hour day based on local timestandard_name :time<pre>array(['1980-07-01T12:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>x(x)float64-180.0 -180.0 ... 180.0 180.0axis :Xlong_name :longitudestandard_name :longitudeunits :degrees_east<pre>array([-179.989561, -179.968714, -179.947868, ...,  179.929589,  179.950436,\n        179.971283])</pre></li><li>y(y)float6483.78 83.76 83.74 ... 6.105 6.084axis :Ylong_name :latitudestandard_name :latitudeunits :degrees_north<pre>array([83.784248, 83.7634  , 83.742552, ...,  6.125605,  6.104757,  6.083909])</pre></li></ul></li><li>Attributes: (4)cell_methods :area: mean time: maximum within days time: mean over dayscoordinates :lon latlong_name :annual average of daily maximum temperatureunits :degrees C</li></ul> In\u00a0[4]: Copied! <pre>da = ds[\"tmax\"]\nwith XarrayReader(da) as dst:\n    print(dst.info())\n</pre> da = ds[\"tmax\"] with XarrayReader(da) as dst:     print(dst.info()) <pre>bounds=BoundingBox(left=-179.99998449579846, bottom=6.073484821356791, right=179.98170598363066, top=83.79467217916716) minzoom=1 maxzoom=6 band_metadata=[('b1', {'long_name': '24-hour day based on local time', 'standard_name': 'time'})] band_descriptions=[('b1', '1980-07-01T12:00:00.000000000')] dtype='float32' nodata_type='Nodata' colorinterp=None scale=None offset=None colormap=None count=1 width=17268 attrs={'cell_methods': 'area: mean time: maximum within days time: mean over days', 'coordinates': 'lon lat', 'long_name': 'annual average of daily maximum temperature', 'units': 'degrees C'} name='tmax' height=3728\n</pre> In\u00a0[5]: Copied! <pre>with XarrayReader(da) as dst:\n    img = dst.tile(1, 1, 2)\n\nplt.imshow(img.data_as_image());\n</pre> with XarrayReader(da) as dst:     img = dst.tile(1, 1, 2)  plt.imshow(img.data_as_image()); In\u00a0[6]: Copied! <pre>with xarray.open_dataset(\n    \"https://ncsa.osn.xsede.org/Pangeo/pangeo-forge/noaa-coastwatch-geopolar-sst-feedstock/noaa-coastwatch-geopolar-sst.zarr\",\n    engine=\"zarr\",\n    decode_coords=\"all\"\n) as src:\n    \n    ds = src[\"analysed_sst\"][:1]\n    \n    # the SST dataset do not have a CRS info\n    # so we need to add it to `virtualy` within the Xarray DataArray\n    ds.rio.write_crs(\"epsg:4326\", inplace=True)\n    \n    with XarrayReader(ds) as dst:\n        print(dst.info())\n        img = dst.tile(1, 1, 2)\n\n    plt.imshow(img.data_as_image())\n</pre> with xarray.open_dataset(     \"https://ncsa.osn.xsede.org/Pangeo/pangeo-forge/noaa-coastwatch-geopolar-sst-feedstock/noaa-coastwatch-geopolar-sst.zarr\",     engine=\"zarr\",     decode_coords=\"all\" ) as src:          ds = src[\"analysed_sst\"][:1]          # the SST dataset do not have a CRS info     # so we need to add it to `virtualy` within the Xarray DataArray     ds.rio.write_crs(\"epsg:4326\", inplace=True)          with XarrayReader(ds) as dst:         print(dst.info())         img = dst.tile(1, 1, 2)      plt.imshow(img.data_as_image()) <pre>bounds=BoundingBox(left=-180.00000610436345, bottom=-89.99999847369712, right=180.00000610436345, top=89.99999847369712) minzoom=0 maxzoom=2 band_metadata=[('b1', {'axis': 'T', 'comment': 'Nominal time of Level 4 analysis', 'long_name': 'reference time of sst field', 'standard_name': 'time'})] band_descriptions=[('b1', '2002-09-01T12:00:00.000000000')] dtype='float32' nodata_type='Nodata' colorinterp=None scale=None offset=None colormap=None count=1 width=7200 attrs={'comment': 'Analysed SST for each ocean grid point', 'long_name': 'analysed sea surface temperature', 'reference': 'Fieguth,P.W. et al. \"Mapping Mediterranean altimeter data with a multiresolution optimal interpolation algorithm\", J. Atmos. Ocean Tech, 15 (2): 535-546, 1998.     Fieguth, P. Multiply-Rooted Multiscale Models for Large-Scale Estimation, IEEE Image Processing, 10(11), 1676-1686, 2001.     Khellah, F., P.W. Fieguth, M.J. Murray and M.R. Allen, \"Statistical Processing of Large Image Sequences\", IEEE Transactions on Geoscience and Remote Sensing, 12 (1), 80-93, 2005.     Maturi, E., A. Harris, J. Mittaz, J. Sapper, G. Wick, X. Zhu, P. Dash, P. Koner, \"A New High-Resolution Sea Surface Temperature Blended Analysis\", Bulleting of the American Meteorological Society, 98 (5), 1015-1026, 2017.', 'source': 'STAR-ACSPO_GAC, STAR-ACSPO_H-8, STAR-Geo_SST, UKMO-OSTIA', 'standard_name': 'sea_surface_foundation_temperature', 'units': 'kelvin', 'valid_max': 4000, 'valid_min': -200} name='analysed_sst' height=3600\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Using-rio-tiler-XarrayReader/#daymet","title":"daymet\u00b6","text":""},{"location":"examples/Using-rio-tiler-XarrayReader/#noaa-coastwatch-geopolar-sst","title":"noaa-coastwatch-geopolar-sst\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/","title":"rio-tiler.mosaic","text":"<p>In This notebook you'll learn how to:</p> <ul> <li>use create mercator tiles from multiple observations (assets) using <code>rio_tiler.mosaic</code> submodule</li> <li>create custom <code>pixel_selection</code> methods</li> <li>look for sentinel-2-cogs data</li> <li>create custom tiler using <code>STACReader</code></li> </ul> In\u00a0[1]: Copied! <pre># !pip install rio-tiler\n# !pip install ipyleaflet\n# !pip install matplotlib\n</pre> # !pip install rio-tiler # !pip install ipyleaflet # !pip install matplotlib In\u00a0[2]: Copied! <pre>import json\nimport datetime\nimport httpx\n\nimport morecantile\n\nfrom rio_tiler.io import Reader, STACReader\nfrom rio_tiler.mosaic import mosaic_reader\nfrom rio_tiler.mosaic.methods import defaults\nfrom rio_tiler.mosaic.methods.base import MosaicMethodBase\nfrom rio_tiler.models import ImageData\n\nfrom rasterio.features import bounds as featureBounds\n\nimport numpy\nfrom matplotlib.pyplot import figure\nfrom ipyleaflet import Map, basemaps, GeoJSON\n</pre> import json import datetime import httpx  import morecantile  from rio_tiler.io import Reader, STACReader from rio_tiler.mosaic import mosaic_reader from rio_tiler.mosaic.methods import defaults from rio_tiler.mosaic.methods.base import MosaicMethodBase from rio_tiler.models import ImageData  from rasterio.features import bounds as featureBounds  import numpy from matplotlib.pyplot import figure from ipyleaflet import Map, basemaps, GeoJSON In\u00a0[3]: Copied! <pre>stac_endpoint = \"https://earth-search.aws.element84.com/v0/search\"\n</pre> stac_endpoint = \"https://earth-search.aws.element84.com/v0/search\" In\u00a0[4]: Copied! <pre># use geojson.io\ngeojson = {\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {},\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              30.810813903808594,\n              29.454247067148533\n            ],\n            [\n              30.88600158691406,\n              29.454247067148533\n            ],\n            [\n              30.88600158691406,\n              29.51879923863822\n            ],\n            [\n              30.810813903808594,\n              29.51879923863822\n            ],\n            [\n              30.810813903808594,\n              29.454247067148533\n            ]\n          ]\n        ]\n      }\n    }\n  ]\n}\n\nbounds = featureBounds(geojson)\n</pre> # use geojson.io geojson = {   \"type\": \"FeatureCollection\",   \"features\": [     {       \"type\": \"Feature\",       \"properties\": {},       \"geometry\": {         \"type\": \"Polygon\",         \"coordinates\": [           [             [               30.810813903808594,               29.454247067148533             ],             [               30.88600158691406,               29.454247067148533             ],             [               30.88600158691406,               29.51879923863822             ],             [               30.810813903808594,               29.51879923863822             ],             [               30.810813903808594,               29.454247067148533             ]           ]         ]       }     }   ] }  bounds = featureBounds(geojson) In\u00a0[5]: Copied! <pre># Date filter\ndate_min=\"2019-06-01\"\ndate_max=\"2019-09-01\"\n\nstart = datetime.datetime.strptime(date_min, \"%Y-%m-%d\").strftime(\"%Y-%m-%dT00:00:00Z\")\nend = datetime.datetime.strptime(date_max, \"%Y-%m-%d\").strftime(\"%Y-%m-%dT23:59:59Z\")\n\nquery = {\n    \"collections\": [\"sentinel-s2-l2a-cogs\"], # Make sure to query only sentinel-2 COGs collection\n    \"datetime\": f\"{start}/{end}\",\n    \"query\": {\n        \"eo:cloud_cover\": {\n            \"lt\": 5\n        }  # Use low cloud cover\n    },\n    \"intersects\": geojson[\"features\"][0][\"geometry\"],\n    \"limit\": 1000,\n    \"fields\": {\n      'include': ['id', 'properties.datetime', 'properties.eo:cloud_cover'],  # Make returned response ligth \n      'exclude': ['links']\n    }\n}\n\nheaders = {\n    \"Content-Type\": \"application/json\",\n    \"Accept-Encoding\": \"gzip\",\n    \"Accept\": \"application/geo+json\",\n}\n\n\ndata = httpx.post(stac_endpoint, headers=headers, json=query).json()\nprint(data[\"context\"])\nprint()\nprint(\"Example:\")\nprint(json.dumps(data[\"features\"][0], indent=4))\n\nsceneid = [f[\"id\"] for f in data[\"features\"]]\ncloudcover = [f[\"properties\"][\"eo:cloud_cover\"] for f in data[\"features\"]]\ndates = [f[\"properties\"][\"datetime\"][0:10] for f in data[\"features\"]]\n\n# For this demo we will use the True color image `TCI` asset\nassets = [f[\"assets\"][\"visual\"][\"href\"] for f in data[\"features\"]]\n</pre> # Date filter date_min=\"2019-06-01\" date_max=\"2019-09-01\"  start = datetime.datetime.strptime(date_min, \"%Y-%m-%d\").strftime(\"%Y-%m-%dT00:00:00Z\") end = datetime.datetime.strptime(date_max, \"%Y-%m-%d\").strftime(\"%Y-%m-%dT23:59:59Z\")  query = {     \"collections\": [\"sentinel-s2-l2a-cogs\"], # Make sure to query only sentinel-2 COGs collection     \"datetime\": f\"{start}/{end}\",     \"query\": {         \"eo:cloud_cover\": {             \"lt\": 5         }  # Use low cloud cover     },     \"intersects\": geojson[\"features\"][0][\"geometry\"],     \"limit\": 1000,     \"fields\": {       'include': ['id', 'properties.datetime', 'properties.eo:cloud_cover'],  # Make returned response ligth        'exclude': ['links']     } }  headers = {     \"Content-Type\": \"application/json\",     \"Accept-Encoding\": \"gzip\",     \"Accept\": \"application/geo+json\", }   data = httpx.post(stac_endpoint, headers=headers, json=query).json() print(data[\"context\"]) print() print(\"Example:\") print(json.dumps(data[\"features\"][0], indent=4))  sceneid = [f[\"id\"] for f in data[\"features\"]] cloudcover = [f[\"properties\"][\"eo:cloud_cover\"] for f in data[\"features\"]] dates = [f[\"properties\"][\"datetime\"][0:10] for f in data[\"features\"]]  # For this demo we will use the True color image `TCI` asset assets = [f[\"assets\"][\"visual\"][\"href\"] for f in data[\"features\"]] <pre>{'page': 1, 'limit': 1000, 'matched': 23, 'returned': 23}\n\nExample:\n{\n    \"assets\": {\n        \"overview\": {\n            \"proj:shape\": [\n                343,\n                343\n            ],\n            \"proj:transform\": [\n                320,\n                0,\n                199980,\n                0,\n                -320,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/L2A_PVI.tif\",\n            \"title\": \"True color image\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"thumbnail\": {\n            \"href\": \"https://roda.sentinel-hub.com/sentinel-s2-l1c/tiles/36/R/TT/2019/8/30/0/preview.jpg\",\n            \"title\": \"Thumbnail\",\n            \"type\": \"image/png\"\n        },\n        \"metadata\": {\n            \"href\": \"https://roda.sentinel-hub.com/sentinel-s2-l2a/tiles/36/R/TT/2019/8/30/0/metadata.xml\",\n            \"title\": \"Original XML metadata\",\n            \"type\": \"application/xml\"\n        },\n        \"B11\": {\n            \"proj:shape\": [\n                5490,\n                5490\n            ],\n            \"proj:transform\": [\n                20,\n                0,\n                199980,\n                0,\n                -20,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/B11.tif\",\n            \"title\": \"Band 11 (swir16)\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"B01\": {\n            \"proj:shape\": [\n                1830,\n                1830\n            ],\n            \"proj:transform\": [\n                60,\n                0,\n                199980,\n                0,\n                -60,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/B01.tif\",\n            \"title\": \"Band 1 (coastal)\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"B12\": {\n            \"proj:shape\": [\n                5490,\n                5490\n            ],\n            \"proj:transform\": [\n                20,\n                0,\n                199980,\n                0,\n                -20,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/B12.tif\",\n            \"title\": \"Band 12 (swir22)\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"B02\": {\n            \"proj:shape\": [\n                10980,\n                10980\n            ],\n            \"proj:transform\": [\n                10,\n                0,\n                199980,\n                0,\n                -10,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/B02.tif\",\n            \"title\": \"Band 2 (blue)\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"B03\": {\n            \"proj:shape\": [\n                10980,\n                10980\n            ],\n            \"proj:transform\": [\n                10,\n                0,\n                199980,\n                0,\n                -10,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/B03.tif\",\n            \"title\": \"Band 3 (green)\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"B04\": {\n            \"proj:shape\": [\n                10980,\n                10980\n            ],\n            \"proj:transform\": [\n                10,\n                0,\n                199980,\n                0,\n                -10,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/B04.tif\",\n            \"title\": \"Band 4 (red)\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"AOT\": {\n            \"proj:shape\": [\n                1830,\n                1830\n            ],\n            \"proj:transform\": [\n                60,\n                0,\n                199980,\n                0,\n                -60,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/AOT.tif\",\n            \"title\": \"Aerosol Optical Thickness (AOT)\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"B05\": {\n            \"proj:shape\": [\n                5490,\n                5490\n            ],\n            \"proj:transform\": [\n                20,\n                0,\n                199980,\n                0,\n                -20,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/B05.tif\",\n            \"title\": \"Band 5\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"B06\": {\n            \"proj:shape\": [\n                5490,\n                5490\n            ],\n            \"proj:transform\": [\n                20,\n                0,\n                199980,\n                0,\n                -20,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/B06.tif\",\n            \"title\": \"Band 6\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"B07\": {\n            \"proj:shape\": [\n                5490,\n                5490\n            ],\n            \"proj:transform\": [\n                20,\n                0,\n                199980,\n                0,\n                -20,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/B07.tif\",\n            \"title\": \"Band 7\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"B08\": {\n            \"proj:shape\": [\n                10980,\n                10980\n            ],\n            \"proj:transform\": [\n                10,\n                0,\n                199980,\n                0,\n                -10,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/B08.tif\",\n            \"title\": \"Band 8 (nir)\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"B8A\": {\n            \"proj:shape\": [\n                5490,\n                5490\n            ],\n            \"proj:transform\": [\n                20,\n                0,\n                199980,\n                0,\n                -20,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/B8A.tif\",\n            \"title\": \"Band 8A\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"B09\": {\n            \"proj:shape\": [\n                1830,\n                1830\n            ],\n            \"proj:transform\": [\n                60,\n                0,\n                199980,\n                0,\n                -60,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/B09.tif\",\n            \"title\": \"Band 9\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"WVP\": {\n            \"proj:shape\": [\n                10980,\n                10980\n            ],\n            \"proj:transform\": [\n                10,\n                0,\n                199980,\n                0,\n                -10,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/WVP.tif\",\n            \"title\": \"Water Vapour (WVP)\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"visual\": {\n            \"proj:shape\": [\n                10980,\n                10980\n            ],\n            \"proj:transform\": [\n                10,\n                0,\n                199980,\n                0,\n                -10,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/TCI.tif\",\n            \"title\": \"True color image\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"SCL\": {\n            \"proj:shape\": [\n                5490,\n                5490\n            ],\n            \"proj:transform\": [\n                20,\n                0,\n                199980,\n                0,\n                -20,\n                3300000,\n                0,\n                0,\n                1\n            ],\n            \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/SCL.tif\",\n            \"title\": \"Scene Classification Map (SCL)\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\"\n        },\n        \"info\": {\n            \"href\": \"https://roda.sentinel-hub.com/sentinel-s2-l2a/tiles/36/R/TT/2019/8/30/0/tileInfo.json\",\n            \"title\": \"Original JSON metadata\",\n            \"type\": \"application/json\"\n        }\n    },\n    \"bbox\": [\n        29.896473859714554,\n        28.804454491507947,\n        31.003792553495717,\n        29.81537540150385\n    ],\n    \"geometry\": {\n        \"coordinates\": [\n            [\n                [\n                    29.92628490999458,\n                    28.804454491507947\n                ],\n                [\n                    29.896473859714554,\n                    29.793998377705638\n                ],\n                [\n                    31.003792553495717,\n                    29.81537540150385\n                ],\n                [\n                    30.721048631911938,\n                    28.8202241961706\n                ],\n                [\n                    29.92628490999458,\n                    28.804454491507947\n                ]\n            ]\n        ],\n        \"type\": \"Polygon\"\n    },\n    \"id\": \"S2B_36RTT_20190830_0_L2A\",\n    \"collection\": \"sentinel-s2-l2a-cogs\",\n    \"type\": \"Feature\",\n    \"properties\": {\n        \"datetime\": \"2019-08-30T08:52:09Z\",\n        \"eo:cloud_cover\": 1.96\n    }\n}\n</pre> In\u00a0[6]: Copied! <pre>m = Map(\n    basemap=basemaps.OpenStreetMap.Mapnik,\n    center=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom=8\n)\n\n# add scenes\ngeo_json = GeoJSON(\n    data=data,\n    style={\n        'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1\n    },\n)\nm.add_layer(geo_json)\n\n# add AOI\ngeo_json = GeoJSON(\n    data=geojson,\n    style={\n        'opacity': 1, 'dashArray': '1', 'fillOpacity': 1, 'weight': 1\n    },\n)\nm.add_layer(geo_json)\n\nm\n</pre> m = Map(     basemap=basemaps.OpenStreetMap.Mapnik,     center=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom=8 )  # add scenes geo_json = GeoJSON(     data=data,     style={         'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1     }, ) m.add_layer(geo_json)  # add AOI geo_json = GeoJSON(     data=geojson,     style={         'opacity': 1, 'dashArray': '1', 'fillOpacity': 1, 'weight': 1     }, ) m.add_layer(geo_json)  m Out[6]: <pre>Map(center=[29.486523152893376, 30.848407745361328], controls=(ZoomControl(options=['position', 'zoom_in_text'\u2026</pre> In\u00a0[7]: Copied! <pre>def tiler(asset, *args, **kwargs):\n    with Reader(asset) as src:\n        return src.tile(*args, **kwargs)\n</pre> def tiler(asset, *args, **kwargs):     with Reader(asset) as src:         return src.tile(*args, **kwargs) In\u00a0[8]: Copied! <pre># List of z12 mercator tiles\ntms = morecantile.tms.get(\"WebMercatorQuad\")\n\ntiles = list(tms.tiles(*bounds, 12))\nprint(len(tiles))\n</pre> # List of z12 mercator tiles tms = morecantile.tms.get(\"WebMercatorQuad\")  tiles = list(tms.tiles(*bounds, 12)) print(len(tiles)) <pre>4\n</pre> In\u00a0[9]: Copied! <pre>tile = tiles[0]\n\nimg, assets_used = mosaic_reader(\n    assets,\n    tiler,\n    tile.x,\n    tile.y,\n    tile.z,\n    threads=1,\n)\n\nfig = figure(figsize=(30, 10))\n\nax = fig.add_subplot(1, 2, 1)\nax.imshow(img.data_as_image())\n\nax = fig.add_subplot(1, 2, 2)\nax.imshow(img.mask)\n</pre> tile = tiles[0]  img, assets_used = mosaic_reader(     assets,     tiler,     tile.x,     tile.y,     tile.z,     threads=1, )  fig = figure(figsize=(30, 10))  ax = fig.add_subplot(1, 2, 1) ax.imshow(img.data_as_image())  ax = fig.add_subplot(1, 2, 2) ax.imshow(img.mask) Out[9]: <pre>&lt;matplotlib.image.AxesImage at 0x17b3ef160&gt;</pre> <p>Print the number and list of assets used to construct the image</p> In\u00a0[10]: Copied! <pre>print(len(assets_used))\nprint(assets_used)\n</pre> print(len(assets_used)) print(assets_used) <pre>1\n['https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/TCI.tif']\n</pre> In\u00a0[11]: Copied! <pre>tile = tiles[0]\n\nimg, assets_used = mosaic_reader(\n    assets,\n    tiler,\n    tile.x,\n    tile.y,\n    tile.z,\n    pixel_selection=defaults.MeanMethod(),\n)\n\nfig = figure(figsize=(30, 10))\n\nax = fig.add_subplot(1, 2, 1)\nax.imshow(img.data_as_image())\n\nax = fig.add_subplot(1, 2, 2)\nax.imshow(img.mask)\n</pre> tile = tiles[0]  img, assets_used = mosaic_reader(     assets,     tiler,     tile.x,     tile.y,     tile.z,     pixel_selection=defaults.MeanMethod(), )  fig = figure(figsize=(30, 10))  ax = fig.add_subplot(1, 2, 1) ax.imshow(img.data_as_image())  ax = fig.add_subplot(1, 2, 2) ax.imshow(img.mask) Out[11]: <pre>&lt;matplotlib.image.AxesImage at 0x2a5351cd0&gt;</pre> <p>Print the number and list of assets used to construct the image</p> In\u00a0[12]: Copied! <pre>print(len(assets_used))\nprint(assets_used)\n</pre> print(len(assets_used)) print(assets_used) <pre>23\n['https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190830_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190827_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2A_36RTT_20190825_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190820_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2A_36RTT_20190815_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2B_36RTT_20190810_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/8/S2A_36RTT_20190805_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/7/S2B_36RTT_20190731_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/7/S2A_36RTT_20190726_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/7/S2B_36RTT_20190721_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/7/S2B_36RTT_20190718_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/7/S2A_36RTT_20190716_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/7/S2B_36RTT_20190711_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/7/S2A_36RTT_20190706_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/7/S2B_36RTT_20190701_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/6/S2A_36RTT_20190626_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/6/S2B_36RTT_20190621_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/6/S2B_36RTT_20190618_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/6/S2A_36RTT_20190616_1_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/6/S2B_36RTT_20190611_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/6/S2A_36RTT_20190606_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/6/S2A_36RTT_20190603_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/36/R/TT/2019/6/S2B_36RTT_20190601_0_L2A/TCI.tif']\n</pre> In\u00a0[13]: Copied! <pre>stac_item = \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/{sceneid}\"\nstac_assets = [stac_item.format(sceneid=scene) for scene in sceneid]\n</pre> stac_item = \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/{sceneid}\" stac_assets = [stac_item.format(sceneid=scene) for scene in sceneid] In\u00a0[14]: Copied! <pre># Fisrt, let's checkout the STDEV of the NDVI values\n# Because we need to use multiple STAC assets, it's easier to use the STACReader\ndef custom_tiler(asset, *args, **kwargs):\n    with STACReader(asset) as stac:\n        return stac.tile(*args, expression=\"(B08_b1-B04_b1)/(B08_b1+B04_b1)\")\n\ntile = tiles[0]\n\nimg, assets_used = mosaic_reader(\n    stac_assets,\n    custom_tiler,\n    tile.x,\n    tile.y,\n    tile.z,\n    pixel_selection=defaults.StdevMethod(),\n)\n\nfig = figure(figsize=(30, 10))\n\nax = fig.add_subplot(1, 2, 1)\nax.imshow(img.data_as_image())\n\nax = fig.add_subplot(1, 2, 2)\nax.imshow(img.mask)\n</pre> # Fisrt, let's checkout the STDEV of the NDVI values # Because we need to use multiple STAC assets, it's easier to use the STACReader def custom_tiler(asset, *args, **kwargs):     with STACReader(asset) as stac:         return stac.tile(*args, expression=\"(B08_b1-B04_b1)/(B08_b1+B04_b1)\")  tile = tiles[0]  img, assets_used = mosaic_reader(     stac_assets,     custom_tiler,     tile.x,     tile.y,     tile.z,     pixel_selection=defaults.StdevMethod(), )  fig = figure(figsize=(30, 10))  ax = fig.add_subplot(1, 2, 1) ax.imshow(img.data_as_image())  ax = fig.add_subplot(1, 2, 2) ax.imshow(img.mask) Out[14]: <pre>&lt;matplotlib.image.AxesImage at 0x2a6309730&gt;</pre> In\u00a0[15]: Copied! <pre>print(len(assets_used))\nprint(assets_used)\n</pre> print(len(assets_used)) print(assets_used) <pre>23\n['https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190830_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190827_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190825_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190820_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190815_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190810_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190805_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190731_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190726_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190721_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190718_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190716_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190711_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190706_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190701_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190626_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190621_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190618_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190616_1_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190611_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190606_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190603_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190601_0_L2A']\n</pre> In\u00a0[16]: Copied! <pre># We create a custom tiler function that will read the TCI asset and add a 4th representing the NDVI \ndef custom_tiler(asset, *args, **kwargs):\n    with STACReader(asset) as stac:\n        img = stac.tile(*args, assets=\"visual\")\n        ndvi = stac.tile(*args, expression=\"(B08_b1-B04_b1)/(B08_b1+B04_b1)\")\n        return ImageData(numpy.concatenate((img.data, ndvi.data)), img.mask, crs=img.crs, bounds=img.bounds)\n</pre> # We create a custom tiler function that will read the TCI asset and add a 4th representing the NDVI  def custom_tiler(asset, *args, **kwargs):     with STACReader(asset) as stac:         img = stac.tile(*args, assets=\"visual\")         ndvi = stac.tile(*args, expression=\"(B08_b1-B04_b1)/(B08_b1+B04_b1)\")         return ImageData(numpy.concatenate((img.data, ndvi.data)), img.mask, crs=img.crs, bounds=img.bounds) In\u00a0[21]: Copied! <pre>class CustomFourthBandH(MosaicMethodBase):\n    \"\"\"Feed the mosaic tile with the Mean pixel value.\"\"\"\n\n    @property\n    def data(self):\n        \"\"\"Return data and mask.\"\"\"\n        if self.mosaic is not None:\n            return self.mosaic[:-1].copy()\n\n        return None\n\n    def feed(self, array):\n        \"\"\"Add data to mosaic.\"\"\"\n\n        if self.mosaic is None:\n            self.mosaic = array\n            return\n\n        pidex = (\n            numpy.bitwise_and(array.data[-1] &gt; self.mosaic.data[-1], ~array.mask) | self.mosaic.mask\n        )\n\n        mask = numpy.where(pidex, array.mask, self.mosaic.mask)\n        self.mosaic = numpy.ma.where(pidex, array, self.mosaic)\n        self.mosaic.mask = mask\n</pre> class CustomFourthBandH(MosaicMethodBase):     \"\"\"Feed the mosaic tile with the Mean pixel value.\"\"\"      @property     def data(self):         \"\"\"Return data and mask.\"\"\"         if self.mosaic is not None:             return self.mosaic[:-1].copy()          return None      def feed(self, array):         \"\"\"Add data to mosaic.\"\"\"          if self.mosaic is None:             self.mosaic = array             return          pidex = (             numpy.bitwise_and(array.data[-1] &gt; self.mosaic.data[-1], ~array.mask) | self.mosaic.mask         )          mask = numpy.where(pidex, array.mask, self.mosaic.mask)         self.mosaic = numpy.ma.where(pidex, array, self.mosaic)         self.mosaic.mask = mask In\u00a0[22]: Copied! <pre>tile = tiles[0]\n\nimg, assets_used = mosaic_reader(\n    stac_assets,\n    custom_tiler,\n    tile.x,\n    tile.y,\n    tile.z,\n    pixel_selection=CustomFourthBandH(),\n)\n\nfig = figure(figsize=(30, 10))\n\nax = fig.add_subplot(1, 2, 1)\n\n# NOTE: because we are using NDVI + Visual, the output array, will be in float32\nax.imshow(img.data_as_image().astype(\"uint8\"))\n\nax = fig.add_subplot(1, 2, 2)\nax.imshow(img.mask)\n</pre> tile = tiles[0]  img, assets_used = mosaic_reader(     stac_assets,     custom_tiler,     tile.x,     tile.y,     tile.z,     pixel_selection=CustomFourthBandH(), )  fig = figure(figsize=(30, 10))  ax = fig.add_subplot(1, 2, 1)  # NOTE: because we are using NDVI + Visual, the output array, will be in float32 ax.imshow(img.data_as_image().astype(\"uint8\"))  ax = fig.add_subplot(1, 2, 2) ax.imshow(img.mask) Out[22]: <pre>&lt;matplotlib.image.AxesImage at 0x287153430&gt;</pre> In\u00a0[23]: Copied! <pre>print(len(assets_used))\nprint(assets_used)\n</pre> print(len(assets_used)) print(assets_used) <pre>23\n['https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190830_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190827_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190825_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190820_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190815_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190810_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190805_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190731_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190726_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190721_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190718_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190716_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190711_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190706_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190701_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190626_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190621_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190618_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190616_1_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190611_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190606_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_36RTT_20190603_0_L2A', 'https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_36RTT_20190601_0_L2A']\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Using-rio-tiler-mosaic/#rio-tilermosaic","title":"rio-tiler.mosaic\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>rasterio</li> <li>ipyleaflet</li> <li>rio-tiler~= 5.0</li> <li>matplotlib</li> </ul>"},{"location":"examples/Using-rio-tiler-mosaic/#data","title":"Data\u00b6","text":"<p>For this demo we will use the Sentinel-2 data stored as COGs on AWS.</p>"},{"location":"examples/Using-rio-tiler-mosaic/#sentinel-2-cogs","title":"Sentinel 2 COGs\u00b6","text":"<p>Thanks to Digital Earth Africa and in collaboration with Sinergise, Element 84, Amazon Web Services (AWS) and the Committee on Earth Observation Satellites (CEOS), Sentinel 2 (Level 2) data over Africa, usually stored as JPEG2000, has been translated to COG more important a STAC database and API has been setup.</p> <p>https://www.digitalearthafrica.org/news/operational-and-ready-use-satellite-data-now-available-across-africa</p> <p>The API is provided by @element84 and follows the latest specification: https://earth-search.aws.element84.com/v0</p>"},{"location":"examples/Using-rio-tiler-mosaic/#search-for-data","title":"Search for data\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/#define-area-of-interest-aoi","title":"Define Area of Interest (AOI)\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/#stac-search","title":"STAC Search\u00b6","text":"<p>Use STAC API to search for data over our AOI</p> <p>Doc: https://github.com/radiantearth/stac-api-spec</p>"},{"location":"examples/Using-rio-tiler-mosaic/#define-the-tiler","title":"Define the tiler\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/#firstmethod-fill-with-the-first-value-available","title":"FirstMethod: Fill with the first value available\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/#meanmethod-get-the-mean-from-all-the-stack-of-data","title":"MeanMethod: Get the mean from all the stack of data\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/#create-custom-pixel_selection-class","title":"Create Custom pixel_selection class\u00b6","text":""},{"location":"examples/Using-rio-tiler-mosaic/#1-using-a-4th-band-for-decision-highest-ndvi","title":"1. Using a 4th band for decision: highest NDVI\u00b6","text":""},{"location":"examples/Using-rio-tiler/","title":"Introduction to rio-tiler","text":"<p>The goal of this notebook is to give a quick introduction of the main rio-tiler features.</p> In\u00a0[1]: Copied! <pre># !pip install rio-tiler matplotlib\n</pre> # !pip install rio-tiler matplotlib In\u00a0[2]: Copied! <pre>import morecantile\nfrom rio_tiler.io import Reader\nfrom rio_tiler.profiles import img_profiles\nfrom rio_tiler.models import ImageData\n\nfrom matplotlib.pyplot import plot, imshow, subplots\n</pre> import morecantile from rio_tiler.io import Reader from rio_tiler.profiles import img_profiles from rio_tiler.models import ImageData  from matplotlib.pyplot import plot, imshow, subplots In\u00a0[3]: Copied! <pre># For this DEMO we will use this file\nsrc_path = \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\"\n</pre> # For this DEMO we will use this file src_path = \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\" In\u00a0[4]: Copied! <pre>?Reader\n</pre> ?Reader In\u00a0[5]: Copied! <pre># As for Rasterio, using context manager is a good way to \n# make sure the dataset are closed when we exit.\nwith Reader(src_path) as src:\n    print(\"rasterio dataset:\")\n    print(src.dataset)\n    print()\n    print(\"metadata from rasterio:\")\n    print(src.dataset.meta)\n    print()\n    # Using rio-tiler Info() method\n    info = src.info()\n    print(\"rio-tiler dataset info:\")\n    print(src.info().json(exclude_none=True))\n\nprint(src.dataset.closed)\n</pre> # As for Rasterio, using context manager is a good way to  # make sure the dataset are closed when we exit. with Reader(src_path) as src:     print(\"rasterio dataset:\")     print(src.dataset)     print()     print(\"metadata from rasterio:\")     print(src.dataset.meta)     print()     # Using rio-tiler Info() method     info = src.info()     print(\"rio-tiler dataset info:\")     print(src.info().json(exclude_none=True))  print(src.dataset.closed) <pre>rasterio dataset:\n&lt;open DatasetReader name='https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif' mode='r'&gt;\n\nmetadata from rasterio:\n{'driver': 'GTiff', 'dtype': 'float32', 'nodata': -9999.0, 'width': 2000, 'height': 2000, 'count': 1, 'crs': CRS.from_epsg(2056), 'transform': Affine(0.5, 0.0, 2573000.0,\n       0.0, -0.5, 1086000.0)}\n\nrio-tiler dataset info:\n{\"bounds\": [7.090624928537461, 45.91605844102823, 7.1035698381384185, 45.925093000254144], \"minzoom\": 15, \"maxzoom\": 18, \"band_metadata\": [[\"b1\", {\"STATISTICS_COVARIANCES\": \"10685.98787505646\", \"STATISTICS_EXCLUDEDVALUES\": \"-9999\", \"STATISTICS_MAXIMUM\": \"2015.0944824219\", \"STATISTICS_MEAN\": \"1754.471184271\", \"STATISTICS_MINIMUM\": \"1615.8128662109\", \"STATISTICS_SKIPFACTORX\": \"1\", \"STATISTICS_SKIPFACTORY\": \"1\", \"STATISTICS_STDDEV\": \"103.37305197708\"}]], \"band_descriptions\": [[\"b1\", \"\"]], \"dtype\": \"float32\", \"nodata_type\": \"Nodata\", \"colorinterp\": [\"gray\"], \"count\": 1, \"height\": 2000, \"overviews\": [2, 4, 8], \"width\": 2000, \"driver\": \"GTiff\", \"nodata_value\": -9999.0}\nTrue\n</pre> In\u00a0[6]: Copied! <pre>with Reader(src_path) as src:\n    meta = src.statistics(max_size=256)\n\n    assert isinstance(meta, dict)\n    print(list(meta))\n    print(meta[\"b1\"].model_dump())\n</pre> with Reader(src_path) as src:     meta = src.statistics(max_size=256)      assert isinstance(meta, dict)     print(list(meta))     print(meta[\"b1\"].model_dump()) <pre>['b1']\n{'min': 1615.81982421875, 'max': 2015.094482421875, 'mean': 1754.59130859375, 'count': 65536.0, 'sum': 114988896.0, 'std': 103.58233071843753, 'median': 1721.3946533203125, 'majority': 1957.414794921875, 'minority': 1615.81982421875, 'unique': 61645.0, 'histogram': [[10417.0, 15877.0, 9360.0, 6441.0, 5490.0, 4938.0, 4231.0, 3141.0, 3532.0, 2109.0], [1615.81982421875, 1655.747314453125, 1695.6748046875, 1735.6021728515625, 1775.5296630859375, 1815.4571533203125, 1855.3846435546875, 1895.3121337890625, 1935.239501953125, 1975.1669921875, 2015.094482421875]], 'valid_percent': 100.0, 'masked_pixels': 0.0, 'valid_pixels': 65536.0, 'percentile_2': 1626.7143310546876, 'percentile_98': 1987.7415161132812}\n</pre> In\u00a0[7]: Copied! <pre># Band 1\nplot(meta[\"b1\"].histogram[1][0:-1], meta[\"b1\"].histogram[0])\n</pre> # Band 1 plot(meta[\"b1\"].histogram[1][0:-1], meta[\"b1\"].histogram[0]) Out[7]: <pre>[&lt;matplotlib.lines.Line2D at 0x1686ec190&gt;]</pre> In\u00a0[8]: Copied! <pre>with Reader(src_path) as src:\n    # By default `preview()` will return an array with its longest dimension lower or equal to 1024px\n    data = src.preview()\n    print(data.data.shape)\n    assert isinstance(data, ImageData)\n</pre> with Reader(src_path) as src:     # By default `preview()` will return an array with its longest dimension lower or equal to 1024px     data = src.preview()     print(data.data.shape)     assert isinstance(data, ImageData) <pre>(1, 1024, 1024)\n</pre> In\u00a0[9]: Copied! <pre>print(f\"width: {data.width}\")\nprint(f\"height: {data.height}\")\nprint(f\"bands: {data.count}\")\nprint(f\"crs: {data.crs}\")\nprint(f\"bounds: {data.bounds}\")\nprint(f\"metadata: {data.metadata}\")\nprint(f\"assets: {data.assets}\")\nprint(f\"dataset stats: {data.dataset_statistics}\")  # If stored in the original dataset\n\nprint(type(data.data))\nprint(type(data.mask))\n</pre> print(f\"width: {data.width}\") print(f\"height: {data.height}\") print(f\"bands: {data.count}\") print(f\"crs: {data.crs}\") print(f\"bounds: {data.bounds}\") print(f\"metadata: {data.metadata}\") print(f\"assets: {data.assets}\") print(f\"dataset stats: {data.dataset_statistics}\")  # If stored in the original dataset  print(type(data.data)) print(type(data.mask)) <pre>width: 1024\nheight: 1024\nbands: 1\ncrs: EPSG:2056\nbounds: BoundingBox(left=2573000.0, bottom=1085000.0, right=2574000.0, top=1086000.0)\nmetadata: {'AREA_OR_POINT': 'Area'}\nassets: ['https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif']\ndataset stats: [(1615.8128662109, 2015.0944824219)]\n&lt;class 'numpy.ndarray'&gt;\n&lt;class 'numpy.ndarray'&gt;\n</pre> In\u00a0[10]: Copied! <pre># Rasterio doesn't use the same axis order than visualization libraries (e.g matplotlib, PIL)\n# in order to display the data we need to change the order (using rasterio.plot.array_to_image).\n# the ImageData class wraps the rasterio function in the `data_as_image()` method.\nprint(type(data))\nprint(data.data.shape)\n\nimage = data.data_as_image()\n# data_as_image() returns a numpy.ndarray\nprint(type(image))\nprint(image.shape)\n\nimshow(image)\n</pre> # Rasterio doesn't use the same axis order than visualization libraries (e.g matplotlib, PIL) # in order to display the data we need to change the order (using rasterio.plot.array_to_image). # the ImageData class wraps the rasterio function in the `data_as_image()` method. print(type(data)) print(data.data.shape)  image = data.data_as_image() # data_as_image() returns a numpy.ndarray print(type(image)) print(image.shape)  imshow(image) <pre>&lt;class 'rio_tiler.models.ImageData'&gt;\n(1, 1024, 1024)\n&lt;class 'numpy.ndarray'&gt;\n(1024, 1024, 1)\n</pre> Out[10]: <pre>&lt;matplotlib.image.AxesImage at 0x16855e4f0&gt;</pre> In\u00a0[11]: Copied! <pre>src_path = \"https://njogis-imagery.s3.amazonaws.com/2020/cog/I7D16.tif\"\n</pre> src_path = \"https://njogis-imagery.s3.amazonaws.com/2020/cog/I7D16.tif\" In\u00a0[12]: Copied! <pre>with Reader(src_path) as src:\n    info = src.info()\n    print(\"rio-tiler dataset info:\")\n    print(info.json(exclude_none=True))\n</pre> with Reader(src_path) as src:     info = src.info()     print(\"rio-tiler dataset info:\")     print(info.json(exclude_none=True)) <pre>rio-tiler dataset info:\n{\"bounds\": [-74.3095632062702, 40.603994417539994, -74.29151245384847, 40.61775082944064], \"minzoom\": 14, \"maxzoom\": 19, \"band_metadata\": [[\"b1\", {}], [\"b2\", {}], [\"b3\", {}], [\"b4\", {}]], \"band_descriptions\": [[\"b1\", \"\"], [\"b2\", \"\"], [\"b3\", \"\"], [\"b4\", \"\"]], \"dtype\": \"uint16\", \"nodata_type\": \"None\", \"colorinterp\": [\"red\", \"green\", \"blue\", \"undefined\"], \"count\": 4, \"height\": 5000, \"overviews\": [2, 4, 8, 16], \"width\": 5000, \"driver\": \"GTiff\"}\n</pre> In\u00a0[13]: Copied! <pre>with Reader(src_path) as src:\n    meta = src.statistics()\n\nprint(list(meta))\n    \nfig, axs = subplots(1, 4, sharey=True, tight_layout=True, dpi=150)\n# Red (index 1)\naxs[0].plot(meta[\"b1\"].histogram[1][0:-1], meta[\"b1\"].histogram[0])\n\n# Green (index 2)\naxs[1].plot(meta[\"b2\"].histogram[1][0:-1], meta[\"b2\"].histogram[0])\n\n# Blue (index 3)\naxs[2].plot(meta[\"b3\"].histogram[1][0:-1], meta[\"b3\"].histogram[0])\n\n# Nir (index 3)\naxs[3].plot(meta[\"b4\"].histogram[1][0:-1], meta[\"b4\"].histogram[0])\n</pre> with Reader(src_path) as src:     meta = src.statistics()  print(list(meta))      fig, axs = subplots(1, 4, sharey=True, tight_layout=True, dpi=150) # Red (index 1) axs[0].plot(meta[\"b1\"].histogram[1][0:-1], meta[\"b1\"].histogram[0])  # Green (index 2) axs[1].plot(meta[\"b2\"].histogram[1][0:-1], meta[\"b2\"].histogram[0])  # Blue (index 3) axs[2].plot(meta[\"b3\"].histogram[1][0:-1], meta[\"b3\"].histogram[0])  # Nir (index 3) axs[3].plot(meta[\"b4\"].histogram[1][0:-1], meta[\"b4\"].histogram[0]) <pre>['b1', 'b2', 'b3', 'b4']\n</pre> Out[13]: <pre>[&lt;matplotlib.lines.Line2D at 0x168bfe4c0&gt;]</pre> In\u00a0[14]: Copied! <pre>with Reader(src_path) as src:\n    # Return only the third band\n    nir_band = src.preview(indexes=4)\n    print(nir_band.data.shape)\n    print(nir_band.data.dtype)\n\nimshow(nir_band.data_as_image())\n</pre> with Reader(src_path) as src:     # Return only the third band     nir_band = src.preview(indexes=4)     print(nir_band.data.shape)     print(nir_band.data.dtype)  imshow(nir_band.data_as_image()) <pre>(1, 1024, 1024)\nuint16\n</pre> Out[14]: <pre>&lt;matplotlib.image.AxesImage at 0x168d35220&gt;</pre> In\u00a0[15]: Copied! <pre>with Reader(src_path) as src:\n    # Return only the third band\n    nrg = src.preview(indexes=(4,3,1))\n    \n    # Data is in Uint16 so we need to rescale\n    nrg.rescale(((nrg.data.min(), nrg.data.max()),))\n\nimshow(nrg.data_as_image())\n</pre> with Reader(src_path) as src:     # Return only the third band     nrg = src.preview(indexes=(4,3,1))          # Data is in Uint16 so we need to rescale     nrg.rescale(((nrg.data.min(), nrg.data.max()),))  imshow(nrg.data_as_image()) Out[15]: <pre>&lt;matplotlib.image.AxesImage at 0x168d79fd0&gt;</pre> In\u00a0[16]: Copied! <pre>with Reader(src_path) as src:\n    # Apply NDVI band math\n    # (NIR - RED) / (NIR + RED)\n    ndvi = src.preview(expression=\"(b4-b1)/(b4+b1)\")\n    print(ndvi.data.shape)\n    print(ndvi.data.dtype)\n    print(\"NDVI range: \", ndvi.data.min(), ndvi.data.max())\n\nndvi.rescale(in_range=((-1,1),))\nimshow(ndvi.data_as_image())\n</pre> with Reader(src_path) as src:     # Apply NDVI band math     # (NIR - RED) / (NIR + RED)     ndvi = src.preview(expression=\"(b4-b1)/(b4+b1)\")     print(ndvi.data.shape)     print(ndvi.data.dtype)     print(\"NDVI range: \", ndvi.data.min(), ndvi.data.max())  ndvi.rescale(in_range=((-1,1),)) imshow(ndvi.data_as_image()) <pre>(1, 1024, 1024)\nfloat64\nNDVI range:  -0.2865547317109613 0.844091888413218\n</pre> Out[16]: <pre>&lt;matplotlib.image.AxesImage at 0x168e1d0a0&gt;</pre> In\u00a0[17]: Copied! <pre>with Reader(src_path) as src:\n    print(f\"Bounds in dataset CRS: {src.bounds}\")\n    print(f\"Bounds WGS84: {src.geographic_bounds}\")\n    print(f\"MinZoom (WebMercator): {src.minzoom}\")\n    print(f\"MaxZoom (WebMercator): {src.maxzoom}\")\n</pre> with Reader(src_path) as src:     print(f\"Bounds in dataset CRS: {src.bounds}\")     print(f\"Bounds WGS84: {src.geographic_bounds}\")     print(f\"MinZoom (WebMercator): {src.minzoom}\")     print(f\"MaxZoom (WebMercator): {src.maxzoom}\") <pre>Bounds in dataset CRS: (544999.99999999, 645000.0, 549999.99999999, 650000.0)\nBounds WGS84: (-74.3095632062702, 40.603994417539994, -74.29151245384847, 40.61775082944064)\nMinZoom (WebMercator): 14\nMaxZoom (WebMercator): 19\n</pre> In\u00a0[18]: Copied! <pre># rio-tiler defaults to the WebMercator Grids. The grid definition is provided by the morecantile module\n# Docs: https://github.com/developmentseed/morecantile\ntms = morecantile.tms.get(\"WebMercatorQuad\")\nprint(repr(tms))\n\n# Get the list of tiles for the COG minzoom \nwith Reader(src_path) as cog:\n    tile_cover = list(tms.tiles(*cog.geographic_bounds, zooms=cog.minzoom))\n\nprint(f\"Nb of Z{cog.minzoom} Mercator tiles: {len(tile_cover)}\")\nprint(tile_cover)\n</pre> # rio-tiler defaults to the WebMercator Grids. The grid definition is provided by the morecantile module # Docs: https://github.com/developmentseed/morecantile tms = morecantile.tms.get(\"WebMercatorQuad\") print(repr(tms))  # Get the list of tiles for the COG minzoom  with Reader(src_path) as cog:     tile_cover = list(tms.tiles(*cog.geographic_bounds, zooms=cog.minzoom))  print(f\"Nb of Z{cog.minzoom} Mercator tiles: {len(tile_cover)}\") print(tile_cover) <pre>&lt;TileMatrixSet title='Google Maps Compatible for the World' id='WebMercatorQuad' crs='http://www.opengis.net/def/crs/EPSG/0/3857&gt;\nNb of Z14 Mercator tiles: 2\n[Tile(x=4810, y=6165, z=14), Tile(x=4810, y=6166, z=14)]\n</pre> In\u00a0[19]: Copied! <pre>with Reader(src_path) as src:\n    img_1 = src.tile(*tile_cover[0])\n    img_1.rescale(((0, 40000),))\n    print(img_1.data.shape)\n\n    img_2 = src.tile(*tile_cover[1])\n    img_2.rescale(((0, 40000),))\n\n    print(img_2.data.shape)\n</pre> with Reader(src_path) as src:     img_1 = src.tile(*tile_cover[0])     img_1.rescale(((0, 40000),))     print(img_1.data.shape)      img_2 = src.tile(*tile_cover[1])     img_2.rescale(((0, 40000),))      print(img_2.data.shape) <pre>(4, 256, 256)\n(4, 256, 256)\n</pre> In\u00a0[20]: Copied! <pre># Show the first 3 bands (RGB)\nimshow(img_1.data_as_image()[:,:,0:3])\n</pre> # Show the first 3 bands (RGB) imshow(img_1.data_as_image()[:,:,0:3]) Out[20]: <pre>&lt;matplotlib.image.AxesImage at 0x168cd6ac0&gt;</pre> In\u00a0[21]: Copied! <pre>imshow(img_2.data_as_image()[:,:,0:3])\n</pre> imshow(img_2.data_as_image()[:,:,0:3]) Out[21]: <pre>&lt;matplotlib.image.AxesImage at 0x168ebef10&gt;</pre> In\u00a0[22]: Copied! <pre>with Reader(src_path) as src:\n    ndvi = src.tile(*tile_cover[0], expression=\"(b4-b1)/(b4+b1)\")\n    print(ndvi.data.shape)\n\nndvi.rescale(in_range=((-1,1),))\nimshow(ndvi.data[0])\n</pre> with Reader(src_path) as src:     ndvi = src.tile(*tile_cover[0], expression=\"(b4-b1)/(b4+b1)\")     print(ndvi.data.shape)  ndvi.rescale(in_range=((-1,1),)) imshow(ndvi.data[0]) <pre>(1, 256, 256)\n</pre> Out[22]: <pre>&lt;matplotlib.image.AxesImage at 0x168f79280&gt;</pre> In\u00a0[23]: Copied! <pre>with Reader(src_path) as src:\n    # By default `part()` will read the highest resolution. We can limit this by using the `max_size` option.\n    img = src.part((-74.30680274963379, 40.60748547709819, -74.29478645324707, 40.61567903099978), max_size=1024)\n    print(\"data shape: \", img.data.shape)\n    print(\"bounds: \", img.bounds)\n    print(\"CRS: \", img.crs)\n</pre> with Reader(src_path) as src:     # By default `part()` will read the highest resolution. We can limit this by using the `max_size` option.     img = src.part((-74.30680274963379, 40.60748547709819, -74.29478645324707, 40.61567903099978), max_size=1024)     print(\"data shape: \", img.data.shape)     print(\"bounds: \", img.bounds)     print(\"CRS: \", img.crs) <pre>data shape:  (4, 699, 1024)\nbounds:  BoundingBox(left=-74.30680274963379, bottom=40.60748547709819, right=-74.29478645324707, top=40.61567903099978)\nCRS:  EPSG:4326\n</pre> In\u00a0[24]: Copied! <pre>img.rescale(((0, 40000),))\n\nimshow(img.data_as_image()[:,:,0:3])\n</pre> img.rescale(((0, 40000),))  imshow(img.data_as_image()[:,:,0:3]) Out[24]: <pre>&lt;matplotlib.image.AxesImage at 0x168fd6d90&gt;</pre> In\u00a0[25]: Copied! <pre>with Reader(src_path) as src:\n    pt = src.point(-74.30680274963379, 40.60748547709819)\n\n    print(\"RGB-Nir values:\")\n    print([(b, pt.data[ii]) for ii, b in enumerate(pt.band_names)])\n\n    print(\"NDVI values:\")\n    ndvi = pt.apply_expression(\"(b4-b1)/(b4+b1)\")\n    print([(b, ndvi.data[ii]) for ii, b in enumerate(ndvi.band_names)])\n</pre> with Reader(src_path) as src:     pt = src.point(-74.30680274963379, 40.60748547709819)      print(\"RGB-Nir values:\")     print([(b, pt.data[ii]) for ii, b in enumerate(pt.band_names)])      print(\"NDVI values:\")     ndvi = pt.apply_expression(\"(b4-b1)/(b4+b1)\")     print([(b, ndvi.data[ii]) for ii, b in enumerate(ndvi.band_names)]) <pre>RGB-Nir values:\n[('b1', 11002), ('b2', 15954), ('b3', 14478), ('b4', 32050)]\nNDVI values:\n[('(b4-b1)/(b4+b1)', 0.48889714763541764)]\n</pre> In\u00a0[26]: Copied! <pre>feat = {\n  \"type\": \"Feature\",\n  \"properties\": {},\n  \"geometry\": {\n    \"type\": \"Polygon\",\n    \"coordinates\": [\n      [\n        [\n          -74.30384159088135,\n          40.614245638811646\n        ],\n        [\n          -74.30680274963379,\n          40.61121586776988\n        ],\n        [\n          -74.30590152740477,\n          40.608967884350946\n        ],\n        [\n          -74.30272579193115,\n          40.60748547709819\n        ],\n        [\n          -74.29875612258911,\n          40.60786015456402\n        ],\n        [\n          -74.2960524559021,\n          40.61012446497514\n        ],\n        [\n          -74.29478645324707,\n          40.61390357476733\n        ],\n        [\n          -74.29882049560547,\n          40.61515780103489\n        ],\n        [\n          -74.30294036865233,\n          40.61567903099978\n        ],\n        [\n          -74.3035626411438,\n          40.61502749290829\n        ],\n        [\n          -74.30384159088135,\n          40.614245638811646\n        ]\n      ]\n    ]\n  }\n}\n</pre> feat = {   \"type\": \"Feature\",   \"properties\": {},   \"geometry\": {     \"type\": \"Polygon\",     \"coordinates\": [       [         [           -74.30384159088135,           40.614245638811646         ],         [           -74.30680274963379,           40.61121586776988         ],         [           -74.30590152740477,           40.608967884350946         ],         [           -74.30272579193115,           40.60748547709819         ],         [           -74.29875612258911,           40.60786015456402         ],         [           -74.2960524559021,           40.61012446497514         ],         [           -74.29478645324707,           40.61390357476733         ],         [           -74.29882049560547,           40.61515780103489         ],         [           -74.30294036865233,           40.61567903099978         ],         [           -74.3035626411438,           40.61502749290829         ],         [           -74.30384159088135,           40.614245638811646         ]       ]     ]   } } In\u00a0[27]: Copied! <pre>with Reader(src_path) as src:\n    # we use the feature to define the bounds and the mask\n    # but we use `dst_crs` options to keep the projection from the input dataset\n    # By default `feature()` will read the highest resolution. We can limit this by using the `max_size` option.\n    img = src.feature(feat, dst_crs=src.crs, max_size=1024)\n    print(\"data shape: \", img.data.shape)\n    print(\"bounds: \", img.bounds)\n    print(\"CRS: \", img.crs)\n</pre> with Reader(src_path) as src:     # we use the feature to define the bounds and the mask     # but we use `dst_crs` options to keep the projection from the input dataset     # By default `feature()` will read the highest resolution. We can limit this by using the `max_size` option.     img = src.feature(feat, dst_crs=src.crs, max_size=1024)     print(\"data shape: \", img.data.shape)     print(\"bounds: \", img.bounds)     print(\"CRS: \", img.crs) <pre>data shape:  (4, 917, 1024)\nbounds:  BoundingBox(left=545757.1269694079, bottom=646262.0947405763, right=549099.8472835454, top=649254.4633358676)\nCRS:  EPSG:6527\n</pre> In\u00a0[28]: Copied! <pre>img.rescale(((0, 40000),))\nimshow(img.data_as_image()[:,:,0:3])\n</pre> img.rescale(((0, 40000),)) imshow(img.data_as_image()[:,:,0:3]) Out[28]: <pre>&lt;matplotlib.image.AxesImage at 0x16abd3c10&gt;</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Using-rio-tiler/#introduction-to-rio-tiler","title":"Introduction to rio-tiler\u00b6","text":""},{"location":"examples/Using-rio-tiler/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>rio-tiler~= 5.0</li> <li>matplotlib</li> </ul>"},{"location":"examples/Using-rio-tiler/#rio_tileriocogreader","title":"rio_tiler.io.COGReader\u00b6","text":"<p>In <code>rio-tiler</code> 2.0 we introduced COGReader (renamed Reader in 4.0), which is a python class providing usefull methods to read and inspect any GDAL/rasterio raster dataset.</p> <p>Docs: https://cogeotiff.github.io/rio-tiler/readers/#cogreader</p>"},{"location":"examples/Using-rio-tiler/#info","title":"Info\u00b6","text":"<p>Read GDAL/Rasterio dataset metadata</p>"},{"location":"examples/Using-rio-tiler/#statistics","title":"Statistics\u00b6","text":"<p>Return basic data statistics</p>"},{"location":"examples/Using-rio-tiler/#plot-histogram-values","title":"Plot Histogram values\u00b6","text":""},{"location":"examples/Using-rio-tiler/#preview","title":"Preview\u00b6","text":"<p>Read a low resolution version of the data (useful when working with COG, because this method will only fetch the overview layer it needs)</p>"},{"location":"examples/Using-rio-tiler/#the-imagedata-class","title":"The ImageData class\u00b6","text":"<p>To ease data manipulation, <code>rio-tiler</code> version 2.0 uses a new <code>ImageData</code> class that holds the arrays returned by rio-tiler/rasterio low level functions.</p> <p>Docs: https://cogeotiff.github.io/rio-tiler/models/#imagedata</p>"},{"location":"examples/Using-rio-tiler/#display-the-data","title":"Display the data\u00b6","text":""},{"location":"examples/Using-rio-tiler/#multi-spectral-data","title":"Multi Spectral Data\u00b6","text":"<p>For this demo we will use some High resolution RGB-Nir data hosted on AWS.</p>"},{"location":"examples/Using-rio-tiler/#using-expression","title":"Using Expression\u00b6","text":"<p><code>rio-tiler</code> reader methods accept <code>indexes</code> option to select the bands you want to read, but also <code>expression</code> to perform band math.</p>"},{"location":"examples/Using-rio-tiler/#tile","title":"Tile\u00b6","text":"<p>Read data for a specific slippy map tile coordinates</p>"},{"location":"examples/Using-rio-tiler/#part","title":"Part\u00b6","text":"<p>Read data for a given bounding box</p>"},{"location":"examples/Using-rio-tiler/#point","title":"Point\u00b6","text":"<p>Read the pixel value for a specific lon/lat coordinate</p>"},{"location":"examples/Using-rio-tiler/#featuregeojson","title":"Feature/GeoJSON\u00b6","text":"<p>Read value for a geojson feature defined area</p>"},{"location":"examples/Using-tms/","title":"Introduction to TileMatrixSets","text":"<p>The goal of this notebook is to give a quick introduction to the new TMS option in rio-tiler.</p> In\u00a0[1]: Copied! <pre># !pip install rio-tiler\n# !pip install ipyleaflet\n</pre> # !pip install rio-tiler # !pip install ipyleaflet In\u00a0[2]: Copied! <pre>import morecantile\nfrom ipyleaflet import (\n    Map,\n    basemaps,\n    basemap_to_tiles,\n    TileLayer,\n    WMSLayer,\n    GeoJSON,\n    projections\n)\n</pre> import morecantile from ipyleaflet import (     Map,     basemaps,     basemap_to_tiles,     TileLayer,     WMSLayer,     GeoJSON,     projections ) In\u00a0[3]: Copied! <pre># For this DEMO we will use this file\nsrc_path = \"https://njogis-imagery.s3.amazonaws.com/2020/cog/I7D16.tif\"\n</pre> # For this DEMO we will use this file src_path = \"https://njogis-imagery.s3.amazonaws.com/2020/cog/I7D16.tif\" In\u00a0[4]: Copied! <pre>import json\nfrom concurrent import futures\n\nfrom tornado import web\nfrom tornado import gen\nfrom tornado.httpserver import HTTPServer\nfrom tornado.concurrent import run_on_executor\n\nfrom rio_tiler.io import Reader\nfrom rio_tiler.errors import TileOutsideBounds\nfrom rio_tiler.profiles import img_profiles\n\nclass TileServer:\n    \n    def __init__(self, src_path):\n        \"\"\"Initialize Tornado app.\"\"\"\n        self.server = None\n        self.app = web.Application([\n            (r\"^/tiles/(\\w+)/(\\d+)/(\\d+)/(\\d+)\", TileHandler, {\"url\": src_path}),\n        ])\n\n    def start(self):\n        \"\"\"Start tile server.\"\"\"\n        self.server = HTTPServer(self.app)\n        self.server.listen(8080)\n  \n    def stop(self):\n        \"\"\"Stop tile server.\"\"\"\n        if self.server:\n            self.server.stop()\n\n\nclass TileHandler(web.RequestHandler):\n    \"\"\"Tile requests handler.\"\"\"\n\n    executor = futures.ThreadPoolExecutor(max_workers=16)\n\n    def initialize(self, url):\n        \"\"\"Initialize tiles handler.\"\"\"\n        self.url = url\n\n    @run_on_executor\n    def _get_tile(self, tms, z, x, y):\n\n        try:\n            with Reader(self.url, tms=morecantile.tms.get(tms)) as cog:\n                img = cog.tile(x, y, z, indexes=(1,2,3))\n        except TileOutsideBounds:\n            raise web.HTTPError(404)\n\n        prof = img_profiles.get(\"PNG\", {})\n        return img.render(img_format=\"PNG\", **prof)\n\n    @gen.coroutine\n    def get(self, tms, z, x, y):\n        \"\"\"Retunrs tile data and header.\"\"\"\n        self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n        self.set_header(\"Access-Control-Allow-Methods\", \"GET\")\n        self.set_header(\"Content-Type\", \"image/png\")\n        self.set_header(\"Cache-Control\", \"no-store, no-cache, must-revalidate\")\n        res = yield self._get_tile(tms, int(z), int(x), int(y))\n        self.write(res)\n\n\nts = TileServer(src_path)\nts.start()\n</pre> import json from concurrent import futures  from tornado import web from tornado import gen from tornado.httpserver import HTTPServer from tornado.concurrent import run_on_executor  from rio_tiler.io import Reader from rio_tiler.errors import TileOutsideBounds from rio_tiler.profiles import img_profiles  class TileServer:          def __init__(self, src_path):         \"\"\"Initialize Tornado app.\"\"\"         self.server = None         self.app = web.Application([             (r\"^/tiles/(\\w+)/(\\d+)/(\\d+)/(\\d+)\", TileHandler, {\"url\": src_path}),         ])      def start(self):         \"\"\"Start tile server.\"\"\"         self.server = HTTPServer(self.app)         self.server.listen(8080)        def stop(self):         \"\"\"Stop tile server.\"\"\"         if self.server:             self.server.stop()   class TileHandler(web.RequestHandler):     \"\"\"Tile requests handler.\"\"\"      executor = futures.ThreadPoolExecutor(max_workers=16)      def initialize(self, url):         \"\"\"Initialize tiles handler.\"\"\"         self.url = url      @run_on_executor     def _get_tile(self, tms, z, x, y):          try:             with Reader(self.url, tms=morecantile.tms.get(tms)) as cog:                 img = cog.tile(x, y, z, indexes=(1,2,3))         except TileOutsideBounds:             raise web.HTTPError(404)          prof = img_profiles.get(\"PNG\", {})         return img.render(img_format=\"PNG\", **prof)      @gen.coroutine     def get(self, tms, z, x, y):         \"\"\"Retunrs tile data and header.\"\"\"         self.set_header(\"Access-Control-Allow-Origin\", \"*\")         self.set_header(\"Access-Control-Allow-Methods\", \"GET\")         self.set_header(\"Content-Type\", \"image/png\")         self.set_header(\"Cache-Control\", \"no-store, no-cache, must-revalidate\")         res = yield self._get_tile(tms, int(z), int(x), int(y))         self.write(res)   ts = TileServer(src_path) ts.start() <p>List the supported TMS from morecantile</p> In\u00a0[11]: Copied! <pre>print(\"Supported TMS:\")\nfor name in morecantile.tms.list():\n    print(\"-\", name)\n</pre> print(\"Supported TMS:\") for name in morecantile.tms.list():     print(\"-\", name) <pre>Supported TMS:\n- CanadianNAD83_LCC\n- EuropeanETRS89_LAEAQuad\n- LINZAntarticaMapTilegrid\n- NZTM2000Quad\n- UPSAntarcticWGS84Quad\n- UPSArcticWGS84Quad\n- UTM31WGS84Quad\n- WGS1984Quad\n- WebMercatorQuad\n- WorldCRS84Quad\n- WorldMercatorWGS84Quad\n</pre> In\u00a0[12]: Copied! <pre>with Reader(src_path) as cog:\n    info = cog.info()\n    \nprint(info.model_dump(exclude_none=True))\n\nbounds = info.bounds\ncenter = ((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2)\nm = Map(center=center, zoom=info.minzoom, basemap={})\n\nlayer = TileLayer(\n    url=\"http://127.0.0.1:8080/tiles/WebMercatorQuad/{z}/{x}/{y}\",\n    min_zoom=info.minzoom,\n    max_zoom=info.maxzoom,\n    opacity=1,\n)\nm.add_layer(layer)\nm\n</pre> with Reader(src_path) as cog:     info = cog.info()      print(info.model_dump(exclude_none=True))  bounds = info.bounds center = ((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2) m = Map(center=center, zoom=info.minzoom, basemap={})  layer = TileLayer(     url=\"http://127.0.0.1:8080/tiles/WebMercatorQuad/{z}/{x}/{y}\",     min_zoom=info.minzoom,     max_zoom=info.maxzoom,     opacity=1, ) m.add_layer(layer) m <pre>{'bounds': BoundingBox(left=-74.3095632062702, bottom=40.603994417539994, right=-74.29151245384847, top=40.61775082944064), 'minzoom': 14, 'maxzoom': 19, 'band_metadata': [('b1', {}), ('b2', {}), ('b3', {}), ('b4', {})], 'band_descriptions': [('b1', ''), ('b2', ''), ('b3', ''), ('b4', '')], 'dtype': 'uint16', 'nodata_type': 'None', 'colorinterp': ['red', 'green', 'blue', 'undefined'], 'overviews': [2, 4, 8, 16], 'count': 4, 'driver': 'GTiff', 'width': 5000, 'height': 5000}\n</pre> Out[12]: <pre>Map(center=[40.610872623490316, -74.30053783005934], controls=(ZoomControl(options=['position', 'zoom_in_text'\u2026</pre> In\u00a0[13]: Copied! <pre>with Reader(src_path, tms=morecantile.tms.get(\"WorldCRS84Quad\")) as cog:\n    info = cog.info()\nprint(info.model_dump(exclude_none=True))\n\nbounds = info.bounds\ncenter = ((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2)\nm = Map(center=center, zoom=info.minzoom, basemap={}, crs=projections.EPSG4326)\n\nlayer = TileLayer(\n    url=\"http://127.0.0.1:8080/tiles/WorldCRS84Quad/{z}/{x}/{y}\",\n    min_zoom=info.minzoom,\n    max_zoom=info.maxzoom,\n    opacity=1,\n)\nm.add_layer(layer)\nm\n</pre> with Reader(src_path, tms=morecantile.tms.get(\"WorldCRS84Quad\")) as cog:     info = cog.info() print(info.model_dump(exclude_none=True))  bounds = info.bounds center = ((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2) m = Map(center=center, zoom=info.minzoom, basemap={}, crs=projections.EPSG4326)  layer = TileLayer(     url=\"http://127.0.0.1:8080/tiles/WorldCRS84Quad/{z}/{x}/{y}\",     min_zoom=info.minzoom,     max_zoom=info.maxzoom,     opacity=1, ) m.add_layer(layer) m <pre>{'bounds': BoundingBox(left=-74.3095632062702, bottom=40.603994417539994, right=-74.29151245384847, top=40.61775082944064), 'minzoom': 13, 'maxzoom': 18, 'band_metadata': [('b1', {}), ('b2', {}), ('b3', {}), ('b4', {})], 'band_descriptions': [('b1', ''), ('b2', ''), ('b3', ''), ('b4', '')], 'dtype': 'uint16', 'nodata_type': 'None', 'colorinterp': ['red', 'green', 'blue', 'undefined'], 'overviews': [2, 4, 8, 16], 'count': 4, 'driver': 'GTiff', 'width': 5000, 'height': 5000}\n</pre> Out[13]: <pre>Map(center=[40.610872623490316, -74.30053783005934], controls=(ZoomControl(options=['position', 'zoom_in_text'\u2026</pre> <pre>WARNING:tornado.access:404 GET /tiles/WorldCRS84Quad/13/4810/2246 (127.0.0.1) 162.19ms\nWARNING:tornado.access:404 GET /tiles/WorldCRS84Quad/13/4809/2247 (127.0.0.1) 156.98ms\nWARNING:tornado.access:404 GET /tiles/WorldCRS84Quad/13/4811/2247 (127.0.0.1) 157.02ms\nWARNING:tornado.access:404 GET /tiles/WorldCRS84Quad/13/4811/2246 (127.0.0.1) 69.55ms\nWARNING:tornado.access:404 GET /tiles/WorldCRS84Quad/13/4809/2246 (127.0.0.1) 79.31ms\nWARNING:tornado.access:404 GET /tiles/WorldCRS84Quad/13/4809/2248 (127.0.0.1) 101.73ms\nWARNING:tornado.access:404 GET /tiles/WorldCRS84Quad/13/4811/2248 (127.0.0.1) 73.75ms\nWARNING:tornado.access:404 GET /tiles/WorldCRS84Quad/13/4808/2247 (127.0.0.1) 108.00ms\nWARNING:tornado.access:404 GET /tiles/WorldCRS84Quad/13/4812/2247 (127.0.0.1) 81.00ms\n</pre> In\u00a0[14]: Copied! <pre>ts.stop()\n</pre> ts.stop() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Using-tms/#introduction-to-tilematrixsets","title":"Introduction to TileMatrixSets\u00b6","text":""},{"location":"examples/Using-tms/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>rio-tiler~= 5.0</li> <li>ipyleaflet</li> </ul>"},{"location":"examples/Using-tms/#data","title":"Data\u00b6","text":"<p>For this demo we will use some High resolution RGB-Nir data hosted on AWS.</p>"},{"location":"examples/Using-tms/#tile-server","title":"Tile Server\u00b6","text":"<p>For this demo, we need to create a minimal tile server.</p>"},{"location":"examples/Using-tms/#webmercator-tms","title":"WebMercator TMS\u00b6","text":""},{"location":"examples/Using-tms/#wgs84-tms","title":"WGS84 TMS\u00b6","text":""},{"location":"migrations/v2_migration/","title":"v1.0 -> v2.0","text":"<p><code>rio-tiler</code> version 2.0 introduced many breaking changes. This document aims to help with migrating your code to use <code>rio-tiler</code> 2.0.</p>"},{"location":"migrations/v2_migration/#python-3-only","title":"Python 3 only","text":"<p>First and foremost is the drop of Python 2 support. We are in 2020 and Python 2 is officially dead. For ease of maintenance we decided to remove Python 2 support and to continue with only Python 3. Python 3.6 or later is required.</p> <p>If you need help moving from Python 2 to 3 check out the official transition documentation.</p>"},{"location":"migrations/v2_migration/#type-hints","title":"Type hints","text":"<p>As part of switching to Python 3, we also embraced modern code style with the adoption of type hints. Python 3.6+ has new syntax support for optional \"type hinting\" -- declaring the type of a variable -- which enables an improved development experience in editors and tools.</p> <p>This does not require any changes to your code as long as you're using Python 3.6+.</p> <p>For more information see:</p> <ul> <li>fastapi.tiangolo.com/python-types/</li> <li>kishstats.com/python/2019/01/07/python-type-hinting.html</li> <li>mypy.readthedocs.io/en/stable/cheat_sheet_py3.html</li> </ul> <p>Typing example:</p> <pre><code>def get_vrt_transform(\n    src_dst: Union[DatasetReader, DatasetWriter, WarpedVRT],\n    bounds: Tuple[float, float, float, float],\n    dst_crs: CRS = constants.WEB_MERCATOR_CRS,\n) -&gt; Tuple[Affine, int, int]:\n</code></pre>"},{"location":"migrations/v2_migration/#rasterio-117","title":"Rasterio &gt;= 1.1.7","text":"<p>Rasterio 1.1.7 or newer is required.</p>"},{"location":"migrations/v2_migration/#mercantile-morecantile","title":"Mercantile -&gt; Morecantile","text":"<p>With Morecantile we can support more than the Web Mercator TMS.</p> <p>See tms</p>"},{"location":"migrations/v2_migration/#new-rio_tilerio-submodules","title":"New rio_tiler.io submodules","text":"<p>We created revised submodules for working with COGs and STAC:</p> <ul> <li><code>rio_tiler.io.cogeo</code> is a modified version of the previous <code>rio_tiler.main.tile</code>.</li> <li><code>rio_tiler.io.stac</code> is a new module to work with SpatioTemporal Asset Catalogs (STAC).</li> </ul> <p>We now support reading files through a <code>ContextManager</code> to enable accessing the source rasterio dataset.</p> <pre><code># v1\nfrom rio_tiler.main import tile as cogTiler\ntile, mask = cogTiler('my_tif.tif', 691559, 956905, 21, tilesize=256)\n\n# v2\nfrom rio_tiler.io import COGReader\nwith COGReader(\"my_tif.tif\") as cog:\n    img = cog.tile(691559, 956905, 21, tilesize=256)\n\n    print(cog.dataset) # rasterio dataset (returned by rasterio.open())\n    print(cog.dataset.meta) # rasterio metadata\n    print(cog.bounds)       # WGS84 bounds\n    print(cog.colormap)     # internal colormap\n</code></pre> <p>Expression support is now directly available in the <code>COGReader</code></p> <pre><code>with COGReader(\"my_tif.tif\") as cog:\n    tile, mask = cog.tile(691559, 956905, 21, expression=\"b1/b2\")\n</code></pre> <p>See <code>COGReader</code> amd <code>STACReader</code> for more info.</p>"},{"location":"migrations/v2_migration/#internal-api-rio_tilerreader","title":"Internal API: rio_tiler.reader","text":"<p>Internal tile/data reading functions have been refactored and moved to a new <code>rio_tiler.reader</code> submodule.</p>"},{"location":"migrations/v2_migration/#tile","title":"tile","text":"<p>In <code>rio_tiler</code> v1 most of the magic was happening in <code>rio_tiler.utils._tile_read</code>. In the version 2, this function is now split in two, <code>rio_tiler.reader.part</code> and <code>rio_tiler_reader.read</code>, to reduce code reutilisation and to make the code more robust. The <code>part</code> function now takes <code>height</code> and <code>width</code> instead of a unique <code>tilesize</code> to specify the output array size.</p> <pre><code># v1\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    # get tile bounds and read raster\n    mercator_tile = mercantile.Tile(x=tile_x, y=tile_y, z=tile_z)\n    tile_bounds = mercantile.xy_bounds(mercator_tile)\n\n    t, m = rio_tiler.utils._tile_read(src_dst, tile_bounds, 256)\n\n# v2\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    t, m = rio_tiler.reader.tile(src_dst, tile_x, tile_y, tile_z, 256) # Will check if tile is valid\n\n    # Or\n    mercator_tile = mercantile.Tile(x=tile_x, y=tile_y, z=tile_z)\n    tile_bounds = mercantile.xy_bounds(mercator_tile)\n    t, m = rio_tiler.reader.part(src_dst, tile_bounds, 256, 256)\n</code></pre> <p>Options changes:</p> <ul> <li><code>tile_edge_padding</code> -&gt; <code>padding</code>, and set to 0 by default</li> <li><code>minimum_tile_cover</code> -&gt; <code>minimum_overlap</code></li> <li><code>warp_vrt_option</code> -&gt; <code>vrt_options</code></li> <li><code>unscale</code> (New): add ability to apply scale and offset to the data (Default: False)</li> <li><code>force_binary_mask</code> (New): force mask to either be 0 or 255, set to <code>True</code> by default.</li> <li><code>post_process</code> (New): add post process callback to apply operation on the data and mask arrays.</li> </ul> <pre><code># v1\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    mercator_tile = mercantile.Tile(x=tile_x, y=tile_y, z=tile_z)\n    tile_bounds = mercantile.xy_bounds(mercator_tile)\n    t, m = rio_tiler.utils._tile_read(src_dst, tile_bounds, 256, tile_edge_padding=4, minimum_tile_cover=0.3)\n\n# v2\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    t, m = rio_tiler.reader.tile(src_dst, tile_x, tile_y, tile_z, 256, padding=4, minimum_overlap=0.3)\n</code></pre>"},{"location":"migrations/v2_migration/#alpha-band","title":"Alpha band","text":"<p>Since the first version, <code>rio-tiler</code> returns a tuple of (data, mask) in most of the <code>reading</code> function. This design was made early and without thinking about datasets with an alpha channel, which resulted in issues like #126, where a user gets a 4 bands data array + a mask (instead of 3 bands + mask).</p> <p>In version 2, when no <code>indexes</code> options are passed, we remove the alpha channel from the output data array.</p> <pre><code># v1\nwith rasterio.open(\"my_tif_alpha.tif\") as src_dst:\n    t, m = rio_tiler.utils._tile_read(src_dst, tile_bounds, 256, indexes=(1,2,3))\n\n# v2\nwith rasterio.open(\"my_tif_alpha.tif\") as src_dst:\n    # because rio-tiler will remove the alpha band we don't need to use the indexes option\n    t, m = rio_tiler.reader.tile(src_dst, tile_x, tile_y, tile_z, 256)\n</code></pre>"},{"location":"migrations/v2_migration/#metadata","title":"metadata","text":"<p><code>rio_tiler.utils._raster_get_stats</code> has been replaced by <code>rio_tiler.reader.metadata</code> which uses the new <code>reader.part</code> and <code>reader.preview</code> functions. Meaning that now you can get metadata for a specific area by passing a bbox.</p> <p>To limit the data transfer (with the idea of getting the metadata from the COG overviews) we use the <code>max_size</code> options, meaning the <code>overview_level</code> options have been removed.</p> <pre><code># v1\nimport rio_tiler\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    meta = rio_tiler.utils._raster_get_stats(src_dst)\n\n# v2\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    meta = rio_tiler.reader.metadata(src_dst)\n</code></pre> <p>Options changes</p> <ul> <li>removed <code>histogram_bins</code> and <code>histogram_range</code> which should now be passed in <code>hist_options</code> (e.g: hist_options={bins=10, range=(0, 10)})</li> <li>removed <code>overview_level</code></li> <li>added <code>bounds</code></li> </ul> <p>Output</p> <p>The output has also been updated. The new <code>metadata</code> output doesn't return min/max zoom and bounds is return in WGS84 by default.</p> <pre><code># v1\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    rio_tiler.utils._raster_get_stats(src_dst)\n\n&gt; {\n    \"bounds\": {\n        \"value\": [-119.05915661478785, 13.102845359730287, -84.91821332299578, 33.995073647795806],\n        \"crs\": \"EPSG:4326\"\n    },\n    \"minzoom\": 3,\n    \"maxzoom\": 12,\n    \"band_descriptions\": [\n        [1,  \"band1\"]\n    ],\n    \"statistics\": {\n        \"1\": {\n            \"pc\": [1, 17],\n            \"min\": 1,\n            \"max\": 18,\n            \"std\": 4.418616203143802,\n            \"histogram\": [\n                [...],\n                [...]\n            ]\n        }\n    }\n}\n\n# v2\nwith rasterio.open(\"my_tif.tif\") as src_dst:\n    rio_tiler.reader.metadata(src_dst)\n\n&gt; {\n    \"bounds\": [-119.05915661478785, 13.102845359730287, -84.91821332299578, 33.995073647795806],\n    \"statistics\": {\n        \"1\": {\n            \"percentiles\": [1, 16],\n            \"min\": 1,\n            \"max\": 18,\n            \"std\": 4.069636227214257,\n            \"histogram\": [\n                [...],\n                [...]\n            ]\n        }\n    },\n    \"nodata_type\": \"Nodata\",\n    \"band_metadata\": [[\"1\", {}]],\n    \"band_descriptions\": [[\"1\", \"\"]],\n    \"dtype\": \"int8\",\n    \"colorinterp\": [\"palette\"],\n    \"colormap\": {\n        \"0\": [0, 0, 0, 0],\n        \"1\": [0, 61, 0, 255 ],\n        \"2\": [148, 56, 112, 255],\n        ...\n    }\n}\n</code></pre>"},{"location":"migrations/v2_migration/#colormaps","title":"colormaps","text":"<p>In addition to a new colormap specific submodule <code>rio_tiler.colormap</code>, and colormap holder <code>rio_tiler.colormap.cmap</code>, in version 2, colormaps are now RGBA values.</p> <p>We also removed <code>PIL</code> colormap compatibility.</p> <pre><code># v1\ncmap = rio_tiler.utils.get_colormap(\"viridis\", format=\"gdal\")\nprint(cmap[0])\n&gt; [68, 1, 84]\n\n# v2\nfrom rio_tiler.colormap import cmap\n\ncolormap = cmap.get(\"viridis\")\nprint(colormap[0])\n&gt; [68, 1, 84, 255]\n</code></pre>"},{"location":"migrations/v2_migration/#render","title":"render","text":"<p>In version 1, to create an image blob from an array we used the <code>rio_tiler.utils.array_to_image</code> function. We have renamed and slightly refactored the function but it works the same.</p> <pre><code># v1\nimg = rio_tiler.utils.array_to_image(tile, mask, img_format=\"PNG\")\n\n# v2\nimg = rio_tiler.utils.render(tile, mask, img_format=\"PNG\")\n</code></pre>"},{"location":"migrations/v2_migration/#pydantic-models","title":"Pydantic models","text":"<p>The <code>.io</code> readers now returns pydantic models hosting the results. This enables easy API definition.</p> <p>See models</p>"},{"location":"migrations/v2_migration/#mission-specific-changes","title":"Mission specific changes","text":"<p>Mission-specific tilers have been moved to the <code>rio-tiler-pds</code> package.</p>"},{"location":"migrations/v3_migration/","title":"v2.0 -> v3.0","text":"<p><code>rio-tiler</code> version 3.0 introduced many breaking changes. This document aims to help with migrating your code to use <code>rio-tiler</code> 3.0.</p>"},{"location":"migrations/v3_migration/#morecantile-20-30","title":"Morecantile 2.0 -&gt; 3.0","text":"<p>Morecantile 3.0 switched from rasterio to pyproj for the coordinates transformation processes (github.com/developmentseed/morecantile/blob/master/CHANGES.md#300a0-2021-09-09). Morecantile and Pyproj require python &gt;= 3.7 which means rio-tiler had to remove python 3.6 supports.</p>"},{"location":"migrations/v3_migration/#bounds-and-crs-properties","title":"Bounds and CRS properties","text":"<p>Previously the <code>BaseReader.bounds</code> property was set to the <code>wgs84</code> representation of the dataset bounds but to accommodate to non-earth dataset we changed this and decided to store the native dataset <code>bounds</code>. We've also added <code>BaseReader.crs</code> to make sure user can work with the <code>bounds</code> property.</p> <p>We've added a <code>BaseReader.geographic_bounds</code>, which will return the <code>bounds</code> in WGS84.</p> <pre><code># v2\nfrom rio_tiler.io import COGReader\nwith COGReader(\"my_tif.tif\") as cog:\n    print(cog.bounds)       # bounds in WGS84\n\n# v3\nwith COGReader(\"my_tif.tif\") as cog:\n    print(cog.bounds)       # dataset bounds\n    assert cog.bounds == cog.dataset.bounds  # bounds should be equal to the dataset bounds\n    print(cog.crs)\n    assert cog.crs == cog.dataset.crs\n\n    print(cog.geographic_bounds)  # bounds in WGS84 projection\n</code></pre> <p>Note a <code>geographic_crs</code> attribute is available in <code>COGReader</code> and <code>STACReader</code> to control which CRS to use for the transformation from the dataset's CRS.  <code>geographic_crs</code> is outside the <code>__init__</code> method for Abstract Base Classes (e.g <code>BaseReader</code>)</p> <pre><code>MARS2000_SPHERE = CRS.from_proj4(\"+proj=longlat +R=3396190 +no_defs\")\nMARS_MERCATOR = CRS.from_proj4(\n    \"+proj=merc +R=3396190 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +no_defs\"\n)\nMARS_TMS = TileMatrixSet.custom(\n    [\n        -179.9999999999996,\n        -85.05112877980656,\n        179.9999999999996,\n        85.05112877980656,\n    ],\n    MARS_MERCATOR,\n    extent_crs=MARS2000_SPHERE,\n    title=\"Web Mercator Mars\",\n    geographic_crs=MARS2000_SPHERE,\n)\nwith COGReader(\n    \"martian_dataset.tif\",\n    tms=MARS_TMS,\n    geographic_crs=rasterio.crs.CRS.from_proj4(\"+proj=longlat +R=3396190 +no_defs\"),\n) as cog:\n    ...\n</code></pre>"},{"location":"migrations/v3_migration/#no-more-max_size","title":"No more <code>max_size</code>","text":"<p>We've removed the default option <code>max_size=1024</code> in <code>BaseReader.part</code> and <code>BaseReader.feature</code> to return the highest resolution dataset by default.</p> <pre><code># v2\nfrom rio_tiler.io import COGReader\nwith COGReader(\"my_tif.tif\") as cog:\n    data = cog.part(bbox)\n    assert data.width =&lt; 1024\n    assert data.height =&lt; 1024\n\n# v3\nwith COGReader(\"my_tif.tif\") as cog:\n    data = cog.part(bbox) # Can return data &gt; 1024x1024\n    data = cog.part(bbox, max_size=1024)  # will return the same result as in rio-tiler v2\n</code></pre>"},{"location":"migrations/v3_migration/#metadata-and-statistics","title":"Metadata and Statistics","text":"<p>The <code>BaseReader.metadata</code> method has been deprecated in rio-tiler v3. The method was previously returning a combination of the <code>info()</code> and <code>stats()</code> methods responses.</p> <p>The reader's <code>.stats()</code> methods were also deprecated in favor of the newly <code>.statistics()</code> method which will return more verbose statistics.</p> <pre><code># v2\nfrom rio_tiler.io import COGReader\nwith COGReader(\"my_tif.tif\") as cog:\n    data = cog.stats(bbox)\n\n&gt;&gt;&gt; {'1': ImageStatistics(percentiles=[1.0, 6896.0], min=1.0, max=7872.0, std=2271.0065537857326, histogram=[[503460.0, 0.0, 0.0, 161792.0, 283094.0, 0.0, 0.0, 0.0, 87727.0, 9431.0], [1.0, 788.1, 1575.2, 2362.3, 3149.4, 3936.5, 4723.6, 5510.7, 6297.8, 7084.900000000001, 7872.0]], valid_percent=100.0)}\n\n# v3\nwith COGReader(\"my_tif.tif\") as cog:\n    data = cog.cog.statistics(bbox)\n\n&gt;&gt;&gt; {'1': BandStatistics(min=1.0, max=7872.0, mean=2107.524612053134, count=1045504.0, sum=2203425412.0, std=2271.0065537857326, median=2800.0, majority=1.0, minority=7072.0, unique=15.0, histogram=[[503460.0, 0.0, 0.0, 161792.0, 283094.0, 0.0, 0.0, 0.0, 87727.0, 9431.0], [1.0, 788.1, 1575.2, 2362.3, 3149.4, 3936.5, 4723.6, 5510.7, 6297.8, 7084.900000000001, 7872.0]], valid_percent=100.0, masked_pixels=0.0, valid_pixels=1045504.0, percentile_2=1.0, percentile_98=6896.0)}\n</code></pre>"},{"location":"migrations/v3_migration/#asset_expression-and-asset_indexes","title":"<code>asset_expression</code> and <code>asset_indexes</code>","text":"<p>In 3.0, we changed how <code>asset_expression</code> was defined in <code>rio_tiler.io.MultiBaseReader</code> (the base class of STAC like datasets). In 2.0, it was defined as a <code>string</code> (e.g <code>b1+100</code>) and would be applied to all <code>assets</code> and in 3.0 it's now a <code>dict</code> in form of <code>{\"asset 1\": \"expression for asset 1\", ...}</code>.</p> <pre><code># v2\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        asset_expression=\"b1*2\",  # expression was applied to each asset\n    )\n\n# v3\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        asset_expression={\"data1\": \"b1*2\", \"data2\": \"b2*100\"},  # we can now pass per asset expression\n    )\n</code></pre> <p>We also added <code>asset_indexes</code> to return specific indexes per asset.</p> <pre><code># v2\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        indexes=1,  # first band of each asset would be returned\n    )\n\n# v3\nwith STACReader(\"mystac.json\") as stac:\n    img = stac.preview(\n        assets=(\"data1\", \"data2\"),\n        asset_indexes={\"data1\": (1, 2), \"data2\": (3,)},  # we can now pass per asset Indexes\n    )\n</code></pre>"},{"location":"migrations/v3_migration/#type-hints","title":"Type hints","text":"<p>We have moved rio-tiler's custom type definitions from <code>rio_tiler.constants</code> to <code>rio_tiler.types</code> submodules.</p> <pre><code># v2\nfrom rio_tiler.constants import BBox, ColorTuple, Indexes, NoData, NumType\n\n# v3\nfrom rio_tiler.types import BBox, ColorTuple, Indexes, NoData, NumType\n</code></pre> <p>New types have also been added:</p> <ul> <li><code>DataMaskType = Tuple[numpy.ndarray, numpy.ndarray]</code>: Tuple holding the data and the mask arrays (mostly used in <code>rio_tiler.readers.*</code> functions)</li> <li><code>ColorTuple  = Tuple[int, int, int, int]</code>: RGBA ColorMap entry</li> <li><code>IntervalTuple = Tuple[NumType, NumType]</code>: Min/Max interval entry (for colormap or rescaling)</li> <li><code>GDALColorMapType = Dict[int, ColorTuple]</code>: GDAL compatible colormap</li> <li><code>IntervalColorMapType = Sequence[Tuple[IntervalTuple, ColorTuple]]</code>: Intervals colormap</li> <li><code>ColorMapType = Union[GDALColorMapType, IntervalColorMapType]</code>: Supported colormap types</li> </ul>"},{"location":"migrations/v3_migration/#deprecation","title":"Deprecation","text":"<ul> <li><code>rio_tiler.io.base.BaseReader.metadata()</code> method</li> <li><code>rio_tiler.io.base.BaseReader.stats()</code> method</li> <li><code>rio_tiler.io.base.BaseReader.spatial_info()</code> method</li> <li><code>rio_tiler.io.base.BaseReader.center</code> property</li> <li><code>rio_tiler.models.Metadata</code> model</li> <li><code>rio_tiler.models.ImageStatistics</code> model</li> <li><code>rio_tiler.reader.stats</code> function</li> <li><code>rio_tiler.reader.metadata</code> function</li> <li><code>rio_tiler.utils._stats</code> function</li> </ul>"},{"location":"migrations/v4_migration/","title":"Breaking changes","text":"<p><code>rio-tiler</code> version 4.0 introduced many breaking changes. This document aims to help with migrating your code to use <code>rio-tiler</code> 4.0.</p>"},{"location":"migrations/v4_migration/#python-38","title":"Python &gt;=3.8","text":"<p>As for rasterio, we removed python 3.7 support (rasterio/rasterio#2445)</p>"},{"location":"migrations/v4_migration/#cogreader-reader","title":"COGReader -&gt; Reader","text":"<p>Because the main reader will not only work with COG but most of GDAL supported raster, we choose to rename it to <code>Reader</code>.</p> <pre><code># before\nfrom rio_tiler.io import COGReader\nfrom rio_tiler.io.cogeo import COGReader\n\n# now\nfrom rio_tiler.io import Reader\nfrom rio_tiler.io.rasterio import Reader\n</code></pre> <p>Note: We created <code>rio_tiler.io.COGReader</code> alias to <code>Reader</code> for compatibility.</p>"},{"location":"migrations/v4_migration/#rio_tileriocogeo-rio_tileriorasterio","title":"rio_tiler.io.cogeo -&gt; rio_tiler.io.rasterio","text":"<p>Reader's submodule now reflect the backend they use (rasterio, xarray, stac, ...)</p> <pre><code># before\nfrom rio_tiler.io.cogeo import COGReader\n\n# now\nfrom rio_tiler.io.rasterio import Reader\n</code></pre>"},{"location":"migrations/v4_migration/#band-names","title":"Band names","text":"<p>Band names are now prefixed with <code>b</code> (e.g <code>b1</code>, <code>b2</code>)</p> <pre><code># before\nwith COGReader(\n  \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\"\n) as src:\n    stats = src.statistics()\n   print(list(stats))\n   &gt;&gt;&gt; [\"1\", \"2\", \"3\"]\n\n    info = src.info()\n    print(info.band_metadata)\n    &gt;&gt;&gt; [(\"1\", {}), (\"2\", {}), (\"3\", {})]\n\n    print(info.band_descriptions)\n    &gt;&gt;&gt; [(\"1\", \"\"), (\"2\", \"\"), (\"3\", \"\")]\n\n# now\nwith Reader(\n  \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\"\n) as src:\n    stats = src.statistics()\n    print(list(stats))\n    &gt;&gt;&gt; [\"b1\", \"b2\", \"b3\"]\n\n    info = src.info()\n    print(info.band_metadata)\n    &gt;&gt;&gt; [(\"b1\", {}), (\"b2\", {}), (\"b3\", {})]\n\n    print(info.band_descriptions)\n    &gt;&gt;&gt; [(\"b1\", \"\"), (\"b2\", \"\"), (\"b3\", \"\")]\n</code></pre>"},{"location":"migrations/v4_migration/#multibasereader-_get_asset_url","title":"MultiBaseReader <code>_get_asset_url</code>","text":"<p>We replaced <code>_get_asset_url</code> method in <code>MultibaseReader</code> by <code>_get_asset_info</code> which should return a dictionary in form of <code>{\"url\": ..., \"env\": ...}</code> (ref: cogeotiff/rio-tiler!552)</p> <pre><code># before\nwith STACReader(\"stac.json\") as stac:\n    print(stac._get_asset_url(\"green\"))\n    &gt;&gt;&gt; \"green.tif\"\n\n# new\nwith STACReader(\"stac.json\") as stac:\n    print(stac._get_asset_info(\"green\"))\n    &gt;&gt;&gt; {\"url\": \"green.tif\", \"env\": {}}\n</code></pre>"},{"location":"migrations/v4_migration/#multibasereader-expressions","title":"MultiBaseReader Expressions","text":"<p>We updated the <code>expression</code> format for <code>MultiBaseReader</code> (e.g STAC) to include band names and not only the asset name</p> <pre><code># before\nwith STACReader(\"stac.json\") as stac:\n    stac.tile(701, 102, 8, expression=\"green/red\")\n\n# now\nwith STACReader(\"stac.json\") as stac:\n    stac.tile(701, 102, 8, expression=\"green_b1/red_b1\")\n</code></pre> <p>In addition we also removed <code>asset_expression</code> option in <code>MultiBaseReader</code>. This can be achieved directly using expression.</p> <pre><code># before\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    img = stac.tile(\n        145,\n        103,\n        8,\n        tilesize=256,\n        assets=[\"B01\", \"B02\"],\n        asset_expression={\n            \"B01\": \"b1+500\",  # add 500 to the first band\n            \"B02\": \"b1-100\",  # substract 100 to the first band\n        }\n    )\n\n# now\nwith STACReader(stac_url, exclude_assets={\"thumbnail\"},) as stac:\n    img = stac.tile(\n        145,\n        103,\n        8,\n        tilesize=256,\n        expression=\"B01_b1+500;B02_b1-100\",\n    )\n</code></pre>"},{"location":"migrations/v4_migration/#no-more-gcpcogreader","title":"No more GCPCOGReader","text":"<p><code>rio_tiler.io.Reader</code> will now recognize if the files has internal GCPS.</p> <pre><code># before\nfrom rio_tiler.io import GCPCOGReader\n\nwith GCPCOGReader(\"my_tif_with_gcps.tif\") as src:\n    pass\n\n# now\nfrom rio_tiler.io import Reader\n\nwith Reader(\"my_tif_with_gcps.tif\") as src:\n    pass\n</code></pre>"},{"location":"migrations/v4_migration/#pointdata-object","title":"PointData object","text":"<p>As for method returning <code>images</code>, methods returning point values (<code>Reader.point()</code>) now return a <code>PointData</code> object.</p> <pre><code># before\nwith COGReader(\"cog.tif\") as cog:\n    print(cog.point(10.20, -42.0))\n    &gt;&gt;&gt; [0, 0, 0]\n\n# now\nwith Reader(\"cog.tif\") as src:\n    print(src.point(10.20, -42.0))\n    &gt;&gt;&gt; PointData(\n        data=array([3744], dtype=uint16),\n        mask=array([255], dtype=uint8),\n        band_names=['b1'],\n        coordinates=(10.20, -42),\n        crs=CRS.from_epsg(4326),\n        assets=['cog.tif'],\n        metadata={}\n    )\n</code></pre>"},{"location":"migrations/v4_migration/#low-level-reader-methods-return-imagedata-and-pointdata-objects","title":"Low-level reader methods return ImageData and PointData objects","text":"<p><code>rio_tiler.reader.read</code> and <code>rio_tiler.readers.part</code> now return <code>ImageData</code> object instead of <code>Tuple[ndarray, ndarray]</code>.</p> <pre><code>from rio_tiler.reader import read, part, point\nfrom rio_tiler.models import ImageData, PointData\n\n# before\nwith rasterio.open(\"image.tif\") as src:\n    data, mask = read(src)\n    pts = point(10.20, -42.0)\n    print(pts)\n    &gt;&gt;&gt; [0, 0, 0]\n\n# now\nwith rasterio.open(\"image.tif\") as src:\n    img = read(src)\n    assert isinstance(img, ImageData)\n\n    pts = point(src, (10.20, -42.0))\n    assert isinstance(pts, PointData)\n    print(pts)\n    &gt;&gt;&gt; PointData(\n        data=array([3744], dtype=uint16),\n        mask=array([255], dtype=uint8),\n        band_names=['b1'],\n        coordinates=(10.20, -42),\n        crs=CRS.from_epsg(4326),\n        assets=['cog.tif'],\n        metadata={}\n    )\n</code></pre>"},{"location":"migrations/v4_migration/#reader-options","title":"Reader options","text":"<p>We removed <code>nodata</code>, <code>unscale</code>, <code>resampling_method</code>, <code>vrt_options</code> and <code>post_process</code> options to <code>rio_tiler.io.Reader</code> init method and replaced with a global <code>options</code>: <pre><code># before\nwith COGReader(\"cog.tif\", nodata=1, resampling_method=\"bilinear\") as cog:\n    data = cog.preview()\n\n# now\nwith Reader(COGEO, options={\"nodata\": 1, \"resampling_method\": \"bilinear\"}) as src:\n    data = src.preview()\n</code></pre></p>"},{"location":"migrations/v4_migration/#base-classes-minzoom-and-maxzoom","title":"Base classes minzoom and maxzoom","text":"<p>We moved min/max zoom attribute from the <code>SpatialMixin</code> to the base classes definition directly. This means that each class should now take care of the definition of those two variables.</p> <pre><code># before\n@attr.s\nclass BandFileReader(MultiBandReader):\n    \"\"\"Test MultiBand\"\"\"\n\n    input: str = attr.ib()\n    tms: morecantile.TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)\n\n    reader: Type[BaseReader] = attr.ib(init=False, default=Reader)\n    reader_options: Dict = attr.ib(factory=dict)\n\n    def __attrs_post_init__(self):\n        ...\n\n# now\n@attr.s\nclass BandFileReader(MultiBandReader):\n    \"\"\"Test MultiBand\"\"\"\n\n    input: str = attr.ib()\n    tms: morecantile.TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)\n\n    reader: Type[BaseReader] = attr.ib(init=False, default=Reader)\n    reader_options: Dict = attr.ib(factory=dict)\n\n    minzoom: int = attr.ib()\n    maxzoom: int = attr.ib()\n\n    @minzoom.default\n    def _minzoom(self):\n        return self.tms.minzoom\n\n    @maxzoom.default\n    def _maxzoom(self):\n        return self.tms.maxzoom\n\n    def __attrs_post_init__(self):\n        ...\n</code></pre>"},{"location":"migrations/v4_migration/#new-features","title":"New Features","text":""},{"location":"migrations/v4_migration/#non-geo-reader","title":"Non-Geo reader","text":"<p>Because not all raster are geo-referenced, we added <code>rio_tiler.io.ImageReader</code> to allow opening and reading non-geo images. All methods are returning data in the pixel coordinate system.</p> <pre><code>with ImageReader(\"image.jpg\") as src:\n    info = src.info()\n\n    stats = src.statistics()\n\n    # Part of the image (Origin is top-lef, coordinates should be in form of (left, bottom, right, top))\n    im = src.part((0, 100, 100, 0))\n\n    # 256x256 Tile (Origin of the TMS is top-lef)\n    im = src.tile(0, 0, src.maxzoom)\n\n    # read pixel x=10, y=5 (Origin is top-left)\n    pt = src.point(10, 5)\n</code></pre>"},{"location":"migrations/v4_migration/#xarray-reader","title":"Xarray reader","text":"<p>We added an optional xarray compatible reader in rio-tiler v4.0. The reader takes a xarray.DataArray as input which should have a CRS and geo-spatial variables (x,y or longitude,latitude).</p> <pre><code>import rioxarray\nimport xarray\nfrom rio_tiler.io import XarrayReader\n\nwith xarray.open_dataset(\n    \"https://ncsa.osn.xsede.org/Pangeo/pangeo-forge/noaa-coastwatch-geopolar-sst-feedstock/noaa-coastwatch-geopolar-sst.zarr\",\n    engine=\"zarr\",\n    decode_coords=\"all\"\n) as src:\n    ds = src[\"analysed_sst\"][:1]\n    # the SST dataset do not have a CRS info\n    # so we need to add it to `virtualy` within the Xarray DataArray\n    ds.rio.write_crs(\"epsg:4326\", inplace=True)\n\n    with XarrayReader(ds) as dst:\n        print(dst.info())\n        img = dst.tile(1, 1, 2)\n</code></pre> <p>Note: Users might experience some really bad performance depending on the chunking of the original zarr.</p>"},{"location":"migrations/v4_migration/#dataset-statistics","title":"Dataset Statistics","text":"<p>Starting with rio-tiler 4.0, if the input dataset has <code>statistics</code> (e.g <code>STATISTICS_MINIMUM</code>, <code>STATISTICS_MAXIMUM</code>) within its metadata, rio-tiler will try to use it to rescale automatically the output image.</p> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\") as src:\n    info = src.info()\n    print(info.band_metadata)\n    &gt;&gt;&gt; [('b1',\n    {'STATISTICS_COVARIANCES': '10685.98787505646',\n    'STATISTICS_EXCLUDEDVALUES': '-9999',\n    'STATISTICS_MAXIMUM': '2015.0944824219',\n    'STATISTICS_MEAN': '1754.471184271',\n    'STATISTICS_MINIMUM': '1615.8128662109',\n    'STATISTICS_SKIPFACTORX': '1',\n    'STATISTICS_SKIPFACTORY': '1',\n    'STATISTICS_STDDEV': '103.37305197708'})]\n\n    img = src.preview()\n    # The min/max statistics are saved within every output image object\n    print(img.dataset_statistics)\n    &gt;&gt;&gt; [(1615.8128662109, 2015.0944824219)]\n\n    buffer = img.render()\n    &gt;&gt;&gt; rio-tiler/rio_tiler/models.py:516: InvalidDatatypeWarning: Invalid type: `float32` for the `PNG` driver. Data will be rescaled using min/max type bounds  or dataset_statistics.\n</code></pre>"},{"location":"migrations/v5_migration/","title":"v4.0 -> v5.0","text":"<p><code>rio-tiler</code> version 5.0 introduced many breaking changes. This document aims to help with migrating your code to use <code>rio-tiler</code> 5.0.</p>"},{"location":"migrations/v5_migration/#per_dataset-per_band-mask","title":"PER_DATASET -&gt; PER_BAND mask","text":"<p>When we started to work on rio-tiler we chose to use <code>PER_DATASET</code> mask, a 2D <code>(height, width)</code> array which represent the masked array for the whole dataset, as <code>Alpha</code> or <code>Mask</code> bands are designed for. The <code>PER_DATASET</code> model suffers precision when dealing with datasets that use <code>nodata</code> value because combining all <code>band nodata mask</code> will exclude good data (see github.com/cogeotiff/rio-tiler/issues/579#issuecomment-1455223893).</p> <p>To support the <code>PER_BAND</code> model, we updated the <code>ImageData</code> class to use <code>numpy.ma.MaskedArray</code> which will hold both the data and the mask with the same shape. The <code>image data</code> is now hosted in <code>.array</code> ImageData/PointData attribute.</p> <pre><code># before\nwith COGReader(\"cog.tif\") as src:\n    img = src.preview(width=128, height=128, max_size=None)\n    assert isinstance(img.data, numpy.ndarray)\n    assert img.data.shape == (3, 128, 128)\n\n    assert isinstance(img.mask, numpy.ndarray)\n    assert img.mask.shape == (128, 128)\n\n# now\nwith COGReader(\"cog.tif\") as src:\n    img = src.preview(width=128, height=128, max_size=None)\n    assert isinstance(img.array, numpy.ma.MaskedArray)\n    assert img.array.data.shape == (3, 128, 128)\n    assert img.array.mask.shape == (3, 128, 128)\n</code></pre> <p>For compatibility reason we kept <code>data</code> and <code>mask</code> as properties in the <code>ImageData</code> class. <code>ImageData().mask</code> will represent the <code>PER_DATASET</code> mask.</p> <pre><code>with COGReader(\"cog.tif\") as src:\n    img = src.preview(width=128, height=128, max_size=None)\n    assert isinstance(img.array, numpy.ma.MaskedArray)\n\n    assert img.data.shape == (3, 128, 128)\n    assert img.mask.shape == (128, 128)\n</code></pre>"},{"location":"migrations/v5_migration/#imagedatapointdata","title":"ImageData/PointData","text":"<p>As explained, the <code>ImageData</code> and <code>PointData</code> classes now use <code>MaskedArray</code> as input.</p> <pre><code># before\narr = numpy.zeros((1, 256, 256))\nmask = numpy.zeros((256, 256), dtype=\"uint8\")\nim = ImageData(arr, mask)\n\n# now\narr = numpy.ma.MaskedArray(numpy.zeros((1, 256, 256)))\narr.mask = False\nim = ImageData(arr)\n</code></pre>"},{"location":"migrations/v5_migration/#post_process-callback","title":"post_process callback","text":"<p>Introduced in <code>2.0</code>, <code>rio-tiler</code>'s low level reader (<code>rio_tiler.reader.read</code>) accept a <code>post_process</code> option which should be a Callable that take some data as input and returns modified data. Because of the changes in ImageData input type (now as MaskedArray), the <code>post_process</code> callback should be design to be of type <code>Callable[[numpy.ma.MaskedArray], numpy.ma.MaskedArray]</code>.</p> <pre><code># before\ndef callback(data: numpy.ndarray, mask: numpy.ndarray) -&gt; Tuple[numpy.ndarray, numpy.ndarray]:\n    mask.fill(255)\n    data = data * 2\n    return data, mask\n\nwith Reader(\"cog.tif\") as src:\n    im = src.preview(post_process=callback)\n\n# now\ndef callback(data: numpy.ma.MaskedArray) -&gt; numpy.ma.MaskedArray:\n    data = data * 2\n    return data\n\nwith Reader(\"cog.tif\") as src:\n    im = src.preview(post_process=callback)\n</code></pre>"},{"location":"migrations/v5_migration/#mosaicmethod","title":"MosaicMethod","text":"<p>The <code>.data</code> property of <code>rio-tiler</code>'s MosaicMethods should now return <code>numpy.ma.MaskedArray</code>. This change should be almost non-breaking because the MosaicMethod where designed using MaskedArrays.</p> <pre><code># before\ndef data(self) -&gt; Tuple[Optional[numpy.ndarray], Optional[numpy.ndarray]]:\n    \"\"\"Return data and mask.\"\"\"\n    if self.tile is not None:\n        data = numpy.ma.getdata(self.tile)\n        mask = ~numpy.logical_or.reduce(numpy.ma.getmaskarray(self.tile))  # create PER_DATASET Mask\n        return (data, mask * numpy.uint8(255))\n\n    else:\n        return None, None\n\n# now\n@property\ndef data(self) -&gt; Optional[numpy.ma.MaskedArray]:\n    \"\"\"Return data.\"\"\"\n    return self.mosaic  # `tile` has been renamed `array`\n</code></pre>"},{"location":"migrations/v5_migration/#reprojection-and-resizing-resampling-methods","title":"Reprojection and Resizing resampling methods","text":"<p>With <code>rio-tiler &gt;=5.0</code>, you can now select with resampling method to use for the <code>reprojection</code> and <code>resizing</code> processes independently by using the <code>reproject_method</code> and <code>resampling_method</code> options in <code>rio_tiler.reader</code>'s function.</p> <p>The <code>resampling_method</code> option will control the <code>IO</code> resampling (e.g resizing) while the <code>reproject_method</code> will be using in the <code>WarpedVRT</code> for the reprojection.</p> <pre><code># before\nwith Reader(\"cog.tif\") as src:\n    im = src.preview(\n        dst_crs=\"epsg:4326\",\n        resampling_method=\"bilinear\",  # use `bilinear` for both resizing and reprojection\n    )\n\n# now\nwith Reader(\"cog.tif\") as src:\n    im = src.preview(\n        dst_crs=\"epsg:4326\",\n        resampling_method=\"cubic\",  # use `cubic` for resizing\n        reproject_method=\"bilinear\",  # use `bilinear` for reprojection\n    )\n</code></pre> <p>Important</p> <p>In the <code>XarrayReader</code> we are still using only one <code>resampling_method</code> option because we are using <code>rioxarray</code> for read and reprojection processes and it does not have both options available.</p>"},{"location":"migrations/v5_migration/#boto3-optional-dependency","title":"Boto3 Optional dependency","text":"<p>When needing to access STAC items using <code>s3://</code> urls, you'll need to have <code>boto3</code> installed in your python environment.</p> <pre><code>python -m pip install rio-tiler[\"s3\"]  # or python -m pip install rio-tiler rasterio[\"s3\"]\n</code></pre> <p>Note: if you want to access <code>s3://</code> raster dataset you'll also need <code>boto3</code> in your environment (<code>rasterio</code>'s dependency).</p>"},{"location":"migrations/v5_migration/#changes-in-methodfunctionvariable-names","title":"changes in method/function/variable names","text":"<p>Some function or method names have changed in <code>rio-tiler</code> V5</p> <ul> <li> <p><code>rio_tiler.mosaic.methods.LastBandHigh</code> -&gt; <code>rio_tiler.mosaic.methods.LastBandHighMethod</code></p> </li> <li> <p><code>rio_tiler.mosaic.methods.LastBandLow</code> -&gt; <code>rio_tiler.mosaic.methods.LastBandLowMethod</code></p> </li> <li> <p>in the <code>MosaicMethodBase</code> the variable <code>tile</code> has been renamed <code>mosaic</code></p> </li> <li> <p><code>rio_tiler.utils.aws_get_object</code> -&gt; <code>rio_tiler.io.stac.aws_get_object</code></p> </li> <li> <p>In <code>ImageData</code>/<code>PointData</code> objects the pixel values are stored in a variable named <code>array</code> (it was <code>data</code> previously). A <code>.data</code> property has been added for compatibility.</p> </li> <li> <p>In <code>ImageData</code>/<code>PointData</code> the <code>.mask</code> attribute has been replaced by a <code>.mask</code> property</p> </li> </ul>"}]}